var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// src/utils/validateNodeVersion.js
var require_validateNodeVersion = __commonJS({
  "src/utils/validateNodeVersion.js"(exports2, module2) {
    "use strict";
    module2.exports = () => {
      if (process.version.slice(1).split(".")[0] < 12) {
        console.log("Serverless Cloud requires Node.js 12+");
        process.exit(-1);
      }
    };
  }
});

// src/utils/setStage.js
var require_setStage = __commonJS({
  "src/utils/setStage.js"(exports2, module2) {
    "use strict";
    module2.exports = () => {
      if (!process.env.SERVERLESS_CLOUD_ENDPOINT) {
        const stage = process.env.CLOUD_STAGE;
        process.env.SERVERLESS_CLOUD_ENDPOINT = stage === "prod" || stage === void 0 ? "https://api.cloud.serverless.com" : `https://${stage === "dev" ? "api" : stage}.cloud.serverless-dev.com`;
      }
      if (!process.env.SERVERLESS_PLATFORM_STAGE) {
        process.env.SERVERLESS_PLATFORM_STAGE = process.env.SERVERLESS_CLOUD_ENDPOINT.indexOf("serverless.com") === -1 ? "dev" : "prod";
      }
    };
  }
});

// src/utils/isCI.js
var require_isCI = __commonJS({
  "src/utils/isCI.js"(exports2, module2) {
    var isCI2 = !!process.env.SERVERLESS_ACCESS_KEY;
    module2.exports = isCI2;
  }
});

// ../node_modules/figures/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "../node_modules/figures/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// ../node_modules/figures/index.js
var require_figures = __commonJS({
  "../node_modules/figures/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var { platform } = process;
    var main = {
      tick: "\u2714",
      cross: "\u2716",
      star: "\u2605",
      square: "\u2587",
      squareSmall: "\u25FB",
      squareSmallFilled: "\u25FC",
      play: "\u25B6",
      circle: "\u25EF",
      circleFilled: "\u25C9",
      circleDotted: "\u25CC",
      circleDouble: "\u25CE",
      circleCircle: "\u24DE",
      circleCross: "\u24E7",
      circlePipe: "\u24BE",
      circleQuestionMark: "?\u20DD",
      bullet: "\u25CF",
      dot: "\u2024",
      line: "\u2500",
      ellipsis: "\u2026",
      pointer: "\u276F",
      pointerSmall: "\u203A",
      info: "\u2139",
      warning: "\u26A0",
      hamburger: "\u2630",
      smiley: "\u32E1",
      mustache: "\u0DF4",
      heart: "\u2665",
      nodejs: "\u2B22",
      arrowUp: "\u2191",
      arrowDown: "\u2193",
      arrowLeft: "\u2190",
      arrowRight: "\u2192",
      radioOn: "\u25C9",
      radioOff: "\u25EF",
      checkboxOn: "\u2612",
      checkboxOff: "\u2610",
      checkboxCircleOn: "\u24E7",
      checkboxCircleOff: "\u24BE",
      questionMarkPrefix: "?\u20DD",
      oneHalf: "\xBD",
      oneThird: "\u2153",
      oneQuarter: "\xBC",
      oneFifth: "\u2155",
      oneSixth: "\u2159",
      oneSeventh: "\u2150",
      oneEighth: "\u215B",
      oneNinth: "\u2151",
      oneTenth: "\u2152",
      twoThirds: "\u2154",
      twoFifths: "\u2156",
      threeQuarters: "\xBE",
      threeFifths: "\u2157",
      threeEighths: "\u215C",
      fourFifths: "\u2158",
      fiveSixths: "\u215A",
      fiveEighths: "\u215D",
      sevenEighths: "\u215E"
    };
    var windows = {
      tick: "\u221A",
      cross: "\xD7",
      star: "*",
      square: "\u2588",
      squareSmall: "[ ]",
      squareSmallFilled: "[\u2588]",
      play: "\u25BA",
      circle: "( )",
      circleFilled: "(*)",
      circleDotted: "( )",
      circleDouble: "( )",
      circleCircle: "(\u25CB)",
      circleCross: "(\xD7)",
      circlePipe: "(\u2502)",
      circleQuestionMark: "(?)",
      bullet: "*",
      dot: ".",
      line: "\u2500",
      ellipsis: "...",
      pointer: ">",
      pointerSmall: "\xBB",
      info: "i",
      warning: "\u203C",
      hamburger: "\u2261",
      smiley: "\u263A",
      mustache: "\u250C\u2500\u2510",
      heart: main.heart,
      nodejs: "\u2666",
      arrowUp: main.arrowUp,
      arrowDown: main.arrowDown,
      arrowLeft: main.arrowLeft,
      arrowRight: main.arrowRight,
      radioOn: "(*)",
      radioOff: "( )",
      checkboxOn: "[\xD7]",
      checkboxOff: "[ ]",
      checkboxCircleOn: "(\xD7)",
      checkboxCircleOff: "( )",
      questionMarkPrefix: "\uFF1F",
      oneHalf: "1/2",
      oneThird: "1/3",
      oneQuarter: "1/4",
      oneFifth: "1/5",
      oneSixth: "1/6",
      oneSeventh: "1/7",
      oneEighth: "1/8",
      oneNinth: "1/9",
      oneTenth: "1/10",
      twoThirds: "2/3",
      twoFifths: "2/5",
      threeQuarters: "3/4",
      threeFifths: "3/5",
      threeEighths: "3/8",
      fourFifths: "4/5",
      fiveSixths: "5/6",
      fiveEighths: "5/8",
      sevenEighths: "7/8"
    };
    if (platform === "linux") {
      main.questionMarkPrefix = "?";
    }
    var figures = platform === "win32" ? windows : main;
    var fn = (string) => {
      if (figures === main) {
        return string;
      }
      for (const [key, value] of Object.entries(main)) {
        if (value === figures[key]) {
          continue;
        }
        string = string.replace(new RegExp(escapeStringRegexp(value), "g"), figures[key]);
      }
      return string;
    };
    module2.exports = Object.assign(fn, figures);
    module2.exports.main = main;
    module2.exports.windows = windows;
  }
});

// ../node_modules/color-name/index.js
var require_color_name = __commonJS({
  "../node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// ../node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "../node_modules/color-convert/conversions.js"(exports2, module2) {
    var cssKeywords = require_color_name();
    var reverseKeywords = {};
    for (const key of Object.keys(cssKeywords)) {
      reverseKeywords[cssKeywords[key]] = key;
    }
    var convert = {
      rgb: { channels: 3, labels: "rgb" },
      hsl: { channels: 3, labels: "hsl" },
      hsv: { channels: 3, labels: "hsv" },
      hwb: { channels: 3, labels: "hwb" },
      cmyk: { channels: 4, labels: "cmyk" },
      xyz: { channels: 3, labels: "xyz" },
      lab: { channels: 3, labels: "lab" },
      lch: { channels: 3, labels: "lch" },
      hex: { channels: 1, labels: ["hex"] },
      keyword: { channels: 1, labels: ["keyword"] },
      ansi16: { channels: 1, labels: ["ansi16"] },
      ansi256: { channels: 1, labels: ["ansi256"] },
      hcg: { channels: 3, labels: ["h", "c", "g"] },
      apple: { channels: 3, labels: ["r16", "g16", "b16"] },
      gray: { channels: 1, labels: ["gray"] }
    };
    module2.exports = convert;
    for (const model of Object.keys(convert)) {
      if (!("channels" in convert[model])) {
        throw new Error("missing channels property: " + model);
      }
      if (!("labels" in convert[model])) {
        throw new Error("missing channel labels property: " + model);
      }
      if (convert[model].labels.length !== convert[model].channels) {
        throw new Error("channel and label counts mismatch: " + model);
      }
      const { channels, labels } = convert[model];
      delete convert[model].channels;
      delete convert[model].labels;
      Object.defineProperty(convert[model], "channels", { value: channels });
      Object.defineProperty(convert[model], "labels", { value: labels });
    }
    convert.rgb.hsl = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const min = Math.min(r, g, b);
      const max = Math.max(r, g, b);
      const delta = max - min;
      let h;
      let s;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      const l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [h, s * 100, l * 100];
    };
    convert.rgb.hsv = function(rgb) {
      let rdif;
      let gdif;
      let bdif;
      let h;
      let s;
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const v = Math.max(r, g, b);
      const diff = v - Math.min(r, g, b);
      const diffc = function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      };
      if (diff === 0) {
        h = 0;
        s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      const r = rgb[0];
      const g = rgb[1];
      let b = rgb[2];
      const h = convert.rgb.hsl(rgb)[0];
      const w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };
    convert.rgb.cmyk = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const k = Math.min(1 - r, 1 - g, 1 - b);
      const c = (1 - r - k) / (1 - k) || 0;
      const m = (1 - g - k) / (1 - k) || 0;
      const y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    function comparativeDistance(x, y) {
      return (x[0] - y[0]) ** 2 + (x[1] - y[1]) ** 2 + (x[2] - y[2]) ** 2;
    }
    convert.rgb.keyword = function(rgb) {
      const reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      let currentClosestDistance = Infinity;
      let currentClosestKeyword;
      for (const keyword of Object.keys(cssKeywords)) {
        const value = cssKeywords[keyword];
        const distance = comparativeDistance(rgb, value);
        if (distance < currentClosestDistance) {
          currentClosestDistance = distance;
          currentClosestKeyword = keyword;
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      let r = rgb[0] / 255;
      let g = rgb[1] / 255;
      let b = rgb[2] / 255;
      r = r > 0.04045 ? ((r + 0.055) / 1.055) ** 2.4 : r / 12.92;
      g = g > 0.04045 ? ((g + 0.055) / 1.055) ** 2.4 : g / 12.92;
      b = b > 0.04045 ? ((b + 0.055) / 1.055) ** 2.4 : b / 12.92;
      const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      const z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };
    convert.rgb.lab = function(rgb) {
      const xyz = convert.rgb.xyz(rgb);
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.hsl.rgb = function(hsl) {
      const h = hsl[0] / 360;
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      let t2;
      let t3;
      let val;
      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      const t1 = 2 * l - t2;
      const rgb = [0, 0, 0];
      for (let i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      const h = hsl[0];
      let s = hsl[1] / 100;
      let l = hsl[2] / 100;
      let smin = s;
      const lmin = Math.max(l, 0.01);
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      const v = (l + s) / 2;
      const sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };
    convert.hsv.rgb = function(hsv) {
      const h = hsv[0] / 60;
      const s = hsv[1] / 100;
      let v = hsv[2] / 100;
      const hi = Math.floor(h) % 6;
      const f = h - Math.floor(h);
      const p = 255 * v * (1 - s);
      const q = 255 * v * (1 - s * f);
      const t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [v, t, p];
        case 1:
          return [q, v, p];
        case 2:
          return [p, v, t];
        case 3:
          return [p, q, v];
        case 4:
          return [t, p, v];
        case 5:
          return [v, p, q];
      }
    };
    convert.hsv.hsl = function(hsv) {
      const h = hsv[0];
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const vmin = Math.max(v, 0.01);
      let sl;
      let l;
      l = (2 - s) * v;
      const lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    };
    convert.hwb.rgb = function(hwb) {
      const h = hwb[0] / 360;
      let wh = hwb[1] / 100;
      let bl = hwb[2] / 100;
      const ratio = wh + bl;
      let f;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      const i = Math.floor(6 * h);
      const v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      const n = wh + f * (v - wh);
      let r;
      let g;
      let b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [r * 255, g * 255, b * 255];
    };
    convert.cmyk.rgb = function(cmyk) {
      const c = cmyk[0] / 100;
      const m = cmyk[1] / 100;
      const y = cmyk[2] / 100;
      const k = cmyk[3] / 100;
      const r = 1 - Math.min(1, c * (1 - k) + k);
      const g = 1 - Math.min(1, m * (1 - k) + k);
      const b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.rgb = function(xyz) {
      const x = xyz[0] / 100;
      const y = xyz[1] / 100;
      const z = xyz[2] / 100;
      let r;
      let g;
      let b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.204 + z * 1.057;
      r = r > 31308e-7 ? 1.055 * r ** (1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * g ** (1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * b ** (1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };
    convert.xyz.lab = function(xyz) {
      let x = xyz[0];
      let y = xyz[1];
      let z = xyz[2];
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 8856e-6 ? x ** (1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? y ** (1 / 3) : 7.787 * y + 16 / 116;
      z = z > 8856e-6 ? z ** (1 / 3) : 7.787 * z + 16 / 116;
      const l = 116 * y - 16;
      const a = 500 * (x - y);
      const b = 200 * (y - z);
      return [l, a, b];
    };
    convert.lab.xyz = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let x;
      let y;
      let z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      const y2 = y ** 3;
      const x2 = x ** 3;
      const z2 = z ** 3;
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 8856e-6 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };
    convert.lab.lch = function(lab) {
      const l = lab[0];
      const a = lab[1];
      const b = lab[2];
      let h;
      const hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      const c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };
    convert.lch.lab = function(lch) {
      const l = lch[0];
      const c = lch[1];
      const h = lch[2];
      const hr = h / 360 * 2 * Math.PI;
      const a = c * Math.cos(hr);
      const b = c * Math.sin(hr);
      return [l, a, b];
    };
    convert.rgb.ansi16 = function(args, saturation = null) {
      const [r, g, b] = args;
      let value = saturation === null ? convert.rgb.hsv(args)[2] : saturation;
      value = Math.round(value / 50);
      if (value === 0) {
        return 30;
      }
      let ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value === 2) {
        ansi += 60;
      }
      return ansi;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      const r = args[0];
      const g = args[1];
      const b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      const ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };
    convert.ansi16.rgb = function(args) {
      let color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [color, color, color];
      }
      const mult = (~~(args > 50) + 1) * 0.5;
      const r = (color & 1) * mult * 255;
      const g = (color >> 1 & 1) * mult * 255;
      const b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        const c = (args - 232) * 10 + 8;
        return [c, c, c];
      }
      args -= 16;
      let rem;
      const r = Math.floor(args / 36) / 5 * 255;
      const g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      const b = rem % 6 / 5 * 255;
      return [r, g, b];
    };
    convert.rgb.hex = function(args) {
      const integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      const match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [0, 0, 0];
      }
      let colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map((char) => {
          return char + char;
        }).join("");
      }
      const integer = parseInt(colorString, 16);
      const r = integer >> 16 & 255;
      const g = integer >> 8 & 255;
      const b = integer & 255;
      return [r, g, b];
    };
    convert.rgb.hcg = function(rgb) {
      const r = rgb[0] / 255;
      const g = rgb[1] / 255;
      const b = rgb[2] / 255;
      const max = Math.max(Math.max(r, g), b);
      const min = Math.min(Math.min(r, g), b);
      const chroma = max - min;
      let grayscale;
      let hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma;
      }
      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };
    convert.hsl.hcg = function(hsl) {
      const s = hsl[1] / 100;
      const l = hsl[2] / 100;
      const c = l < 0.5 ? 2 * s * l : 2 * s * (1 - l);
      let f = 0;
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [hsl[0], c * 100, f * 100];
    };
    convert.hsv.hcg = function(hsv) {
      const s = hsv[1] / 100;
      const v = hsv[2] / 100;
      const c = s * v;
      let f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [hsv[0], c * 100, f * 100];
    };
    convert.hcg.rgb = function(hcg) {
      const h = hcg[0] / 360;
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      if (c === 0) {
        return [g * 255, g * 255, g * 255];
      }
      const pure = [0, 0, 0];
      const hi = h % 1 * 6;
      const v = hi % 1;
      const w = 1 - v;
      let mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      let f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [hcg[0], f * 100, v * 100];
    };
    convert.hcg.hsl = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const l = g * (1 - c) + 0.5 * c;
      let s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [hcg[0], s * 100, l * 100];
    };
    convert.hcg.hwb = function(hcg) {
      const c = hcg[1] / 100;
      const g = hcg[2] / 100;
      const v = c + g * (1 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };
    convert.hwb.hcg = function(hwb) {
      const w = hwb[1] / 100;
      const b = hwb[2] / 100;
      const v = 1 - b;
      const c = v - w;
      let g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [hwb[0], c * 100, g * 100];
    };
    convert.apple.rgb = function(apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };
    convert.rgb.apple = function(rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };
    convert.gray.rgb = function(args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };
    convert.gray.hsl = function(args) {
      return [0, 0, args[0]];
    };
    convert.gray.hsv = convert.gray.hsl;
    convert.gray.hwb = function(gray) {
      return [0, 100, gray[0]];
    };
    convert.gray.cmyk = function(gray) {
      return [0, 0, 0, gray[0]];
    };
    convert.gray.lab = function(gray) {
      return [gray[0], 0, 0];
    };
    convert.gray.hex = function(gray) {
      const val = Math.round(gray[0] / 100 * 255) & 255;
      const integer = (val << 16) + (val << 8) + val;
      const string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      const val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  }
});

// ../node_modules/color-convert/route.js
var require_route = __commonJS({
  "../node_modules/color-convert/route.js"(exports2, module2) {
    var conversions = require_conversions();
    function buildGraph() {
      const graph = {};
      const models = Object.keys(conversions);
      for (let len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    function deriveBFS(fromModel) {
      const graph = buildGraph();
      const queue = [fromModel];
      graph[fromModel].distance = 0;
      while (queue.length) {
        const current = queue.pop();
        const adjacents = Object.keys(conversions[current]);
        for (let len = adjacents.length, i = 0; i < len; i++) {
          const adjacent = adjacents[i];
          const node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    function wrapConversion(toModel, graph) {
      const path = [graph[toModel].parent, toModel];
      let fn = conversions[graph[toModel].parent][toModel];
      let cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    module2.exports = function(fromModel) {
      const graph = deriveBFS(fromModel);
      const conversion = {};
      const models = Object.keys(graph);
      for (let len = models.length, i = 0; i < len; i++) {
        const toModel = models[i];
        const node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// ../node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "../node_modules/color-convert/index.js"(exports2, module2) {
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        return fn(args);
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    function wrapRounded(fn) {
      const wrappedFn = function(...args) {
        const arg0 = args[0];
        if (arg0 === void 0 || arg0 === null) {
          return arg0;
        }
        if (arg0.length > 1) {
          args = arg0;
        }
        const result = fn(args);
        if (typeof result === "object") {
          for (let len = result.length, i = 0; i < len; i++) {
            result[i] = Math.round(result[i]);
          }
        }
        return result;
      };
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    models.forEach((fromModel) => {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", { value: conversions[fromModel].channels });
      Object.defineProperty(convert[fromModel], "labels", { value: conversions[fromModel].labels });
      const routes = route(fromModel);
      const routeModels = Object.keys(routes);
      routeModels.forEach((toModel) => {
        const fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// ../node_modules/ansi-styles/index.js
var require_ansi_styles = __commonJS({
  "../node_modules/ansi-styles/index.js"(exports2, module2) {
    "use strict";
    var wrapAnsi16 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${code + offset}m`;
    };
    var wrapAnsi256 = (fn, offset) => (...args) => {
      const code = fn(...args);
      return `[${38 + offset};5;${code}m`;
    };
    var wrapAnsi16m = (fn, offset) => (...args) => {
      const rgb = fn(...args);
      return `[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
    };
    var ansi2ansi = (n) => n;
    var rgb2rgb = (r, g, b) => [r, g, b];
    var setLazyProperty = (object, property, get) => {
      Object.defineProperty(object, property, {
        get: () => {
          const value = get();
          Object.defineProperty(object, property, {
            value,
            enumerable: true,
            configurable: true
          });
          return value;
        },
        enumerable: true,
        configurable: true
      });
    };
    var colorConvert;
    var makeDynamicStyles = (wrap, targetSpace, identity, isBackground) => {
      if (colorConvert === void 0) {
        colorConvert = require_color_convert();
      }
      const offset = isBackground ? 10 : 0;
      const styles = {};
      for (const [sourceSpace, suite] of Object.entries(colorConvert)) {
        const name = sourceSpace === "ansi16" ? "ansi" : sourceSpace;
        if (sourceSpace === targetSpace) {
          styles[name] = wrap(identity, offset);
        } else if (typeof suite === "object") {
          styles[name] = wrap(suite[targetSpace], offset);
        }
      }
      return styles;
    };
    function assembleStyles() {
      const codes = new Map();
      const styles = {
        modifier: {
          reset: [0, 0],
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          blackBright: [90, 39],
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      };
      styles.color.gray = styles.color.blackBright;
      styles.bgColor.bgGray = styles.bgColor.bgBlackBright;
      styles.color.grey = styles.color.blackBright;
      styles.bgColor.bgGrey = styles.bgColor.bgBlackBright;
      for (const [groupName, group] of Object.entries(styles)) {
        for (const [styleName, style] of Object.entries(group)) {
          styles[styleName] = {
            open: `[${style[0]}m`,
            close: `[${style[1]}m`
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }
        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
      }
      Object.defineProperty(styles, "codes", {
        value: codes,
        enumerable: false
      });
      styles.color.close = "[39m";
      styles.bgColor.close = "[49m";
      setLazyProperty(styles.color, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, false));
      setLazyProperty(styles.color, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, false));
      setLazyProperty(styles.bgColor, "ansi", () => makeDynamicStyles(wrapAnsi16, "ansi16", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi256", () => makeDynamicStyles(wrapAnsi256, "ansi256", ansi2ansi, true));
      setLazyProperty(styles.bgColor, "ansi16m", () => makeDynamicStyles(wrapAnsi16m, "rgb", rgb2rgb, true));
      return styles;
    }
    Object.defineProperty(module2, "exports", {
      enumerable: true,
      get: assembleStyles
    });
  }
});

// ../node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "../node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// ../node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "../node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream2) {
      const level = supportsColor(stream2, stream2 && stream2.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// ../node_modules/chalk/source/util.js
var require_util = __commonJS({
  "../node_modules/chalk/source/util.js"(exports2, module2) {
    "use strict";
    var stringReplaceAll = (string, substring, replacer) => {
      let index = string.indexOf(substring);
      if (index === -1) {
        return string;
      }
      const substringLength = substring.length;
      let endIndex = 0;
      let returnValue = "";
      do {
        returnValue += string.substr(endIndex, index - endIndex) + substring + replacer;
        endIndex = index + substringLength;
        index = string.indexOf(substring, endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    var stringEncaseCRLFWithFirstIndex = (string, prefix, postfix, index) => {
      let endIndex = 0;
      let returnValue = "";
      do {
        const gotCR = string[index - 1] === "\r";
        returnValue += string.substr(endIndex, (gotCR ? index - 1 : index) - endIndex) + prefix + (gotCR ? "\r\n" : "\n") + postfix;
        endIndex = index + 1;
        index = string.indexOf("\n", endIndex);
      } while (index !== -1);
      returnValue += string.substr(endIndex);
      return returnValue;
    };
    module2.exports = {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    };
  }
});

// ../node_modules/chalk/source/templates.js
var require_templates = __commonJS({
  "../node_modules/chalk/source/templates.js"(exports2, module2) {
    "use strict";
    var TEMPLATE_REGEX = /(?:\\(u(?:[a-f\d]{4}|\{[a-f\d]{1,6}\})|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
    var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
    var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
    var ESCAPE_REGEX = /\\(u(?:[a-f\d]{4}|{[a-f\d]{1,6}})|x[a-f\d]{2}|.)|([^\\])/gi;
    var ESCAPES = new Map([
      ["n", "\n"],
      ["r", "\r"],
      ["t", "	"],
      ["b", "\b"],
      ["f", "\f"],
      ["v", "\v"],
      ["0", "\0"],
      ["\\", "\\"],
      ["e", ""],
      ["a", "\x07"]
    ]);
    function unescape2(c) {
      const u = c[0] === "u";
      const bracket = c[1] === "{";
      if (u && !bracket && c.length === 5 || c[0] === "x" && c.length === 3) {
        return String.fromCharCode(parseInt(c.slice(1), 16));
      }
      if (u && bracket) {
        return String.fromCodePoint(parseInt(c.slice(2, -1), 16));
      }
      return ESCAPES.get(c) || c;
    }
    function parseArguments(name, arguments_) {
      const results = [];
      const chunks = arguments_.trim().split(/\s*,\s*/g);
      let matches;
      for (const chunk of chunks) {
        const number = Number(chunk);
        if (!Number.isNaN(number)) {
          results.push(number);
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, (m, escape, character) => escape ? unescape2(escape) : character));
        } else {
          throw new Error(`Invalid Chalk template style argument: ${chunk} (in style '${name}')`);
        }
      }
      return results;
    }
    function parseStyle(style) {
      STYLE_REGEX.lastIndex = 0;
      const results = [];
      let matches;
      while ((matches = STYLE_REGEX.exec(style)) !== null) {
        const name = matches[1];
        if (matches[2]) {
          const args = parseArguments(name, matches[2]);
          results.push([name].concat(args));
        } else {
          results.push([name]);
        }
      }
      return results;
    }
    function buildStyle(chalk, styles) {
      const enabled = {};
      for (const layer of styles) {
        for (const style of layer.styles) {
          enabled[style[0]] = layer.inverse ? null : style.slice(1);
        }
      }
      let current = chalk;
      for (const [styleName, styles2] of Object.entries(enabled)) {
        if (!Array.isArray(styles2)) {
          continue;
        }
        if (!(styleName in current)) {
          throw new Error(`Unknown Chalk style: ${styleName}`);
        }
        current = styles2.length > 0 ? current[styleName](...styles2) : current[styleName];
      }
      return current;
    }
    module2.exports = (chalk, temporary) => {
      const styles = [];
      const chunks = [];
      let chunk = [];
      temporary.replace(TEMPLATE_REGEX, (m, escapeCharacter, inverse, style, close, character) => {
        if (escapeCharacter) {
          chunk.push(unescape2(escapeCharacter));
        } else if (style) {
          const string = chunk.join("");
          chunk = [];
          chunks.push(styles.length === 0 ? string : buildStyle(chalk, styles)(string));
          styles.push({ inverse, styles: parseStyle(style) });
        } else if (close) {
          if (styles.length === 0) {
            throw new Error("Found extraneous } in Chalk template literal");
          }
          chunks.push(buildStyle(chalk, styles)(chunk.join("")));
          chunk = [];
          styles.pop();
        } else {
          chunk.push(character);
        }
      });
      chunks.push(chunk.join(""));
      if (styles.length > 0) {
        const errMessage = `Chalk template literal is missing ${styles.length} closing bracket${styles.length === 1 ? "" : "s"} (\`}\`)`;
        throw new Error(errMessage);
      }
      return chunks.join("");
    };
  }
});

// ../node_modules/chalk/source/index.js
var require_source = __commonJS({
  "../node_modules/chalk/source/index.js"(exports2, module2) {
    "use strict";
    var ansiStyles = require_ansi_styles();
    var { stdout: stdoutColor, stderr: stderrColor } = require_supports_color();
    var {
      stringReplaceAll,
      stringEncaseCRLFWithFirstIndex
    } = require_util();
    var { isArray } = Array;
    var levelMapping = [
      "ansi",
      "ansi",
      "ansi256",
      "ansi16m"
    ];
    var styles = Object.create(null);
    var applyOptions = (object, options = {}) => {
      if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
        throw new Error("The `level` option should be an integer from 0 to 3");
      }
      const colorLevel = stdoutColor ? stdoutColor.level : 0;
      object.level = options.level === void 0 ? colorLevel : options.level;
    };
    var ChalkClass = class {
      constructor(options) {
        return chalkFactory(options);
      }
    };
    var chalkFactory = (options) => {
      const chalk2 = {};
      applyOptions(chalk2, options);
      chalk2.template = (...arguments_) => chalkTag(chalk2.template, ...arguments_);
      Object.setPrototypeOf(chalk2, Chalk.prototype);
      Object.setPrototypeOf(chalk2.template, chalk2);
      chalk2.template.constructor = () => {
        throw new Error("`chalk.constructor()` is deprecated. Use `new chalk.Instance()` instead.");
      };
      chalk2.template.Instance = ChalkClass;
      return chalk2.template;
    };
    function Chalk(options) {
      return chalkFactory(options);
    }
    for (const [styleName, style] of Object.entries(ansiStyles)) {
      styles[styleName] = {
        get() {
          const builder = createBuilder(this, createStyler(style.open, style.close, this._styler), this._isEmpty);
          Object.defineProperty(this, styleName, { value: builder });
          return builder;
        }
      };
    }
    styles.visible = {
      get() {
        const builder = createBuilder(this, this._styler, true);
        Object.defineProperty(this, "visible", { value: builder });
        return builder;
      }
    };
    var usedModels = ["rgb", "hex", "keyword", "hsl", "hsv", "hwb", "ansi", "ansi256"];
    for (const model of usedModels) {
      styles[model] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.color[levelMapping[level]][model](...arguments_), ansiStyles.color.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    for (const model of usedModels) {
      const bgModel = "bg" + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get() {
          const { level } = this;
          return function(...arguments_) {
            const styler = createStyler(ansiStyles.bgColor[levelMapping[level]][model](...arguments_), ansiStyles.bgColor.close, this._styler);
            return createBuilder(this, styler, this._isEmpty);
          };
        }
      };
    }
    var proto = Object.defineProperties(() => {
    }, __spreadProps(__spreadValues({}, styles), {
      level: {
        enumerable: true,
        get() {
          return this._generator.level;
        },
        set(level) {
          this._generator.level = level;
        }
      }
    }));
    var createStyler = (open, close, parent) => {
      let openAll;
      let closeAll;
      if (parent === void 0) {
        openAll = open;
        closeAll = close;
      } else {
        openAll = parent.openAll + open;
        closeAll = close + parent.closeAll;
      }
      return {
        open,
        close,
        openAll,
        closeAll,
        parent
      };
    };
    var createBuilder = (self2, _styler, _isEmpty) => {
      const builder = (...arguments_) => {
        if (isArray(arguments_[0]) && isArray(arguments_[0].raw)) {
          return applyStyle(builder, chalkTag(builder, ...arguments_));
        }
        return applyStyle(builder, arguments_.length === 1 ? "" + arguments_[0] : arguments_.join(" "));
      };
      Object.setPrototypeOf(builder, proto);
      builder._generator = self2;
      builder._styler = _styler;
      builder._isEmpty = _isEmpty;
      return builder;
    };
    var applyStyle = (self2, string) => {
      if (self2.level <= 0 || !string) {
        return self2._isEmpty ? "" : string;
      }
      let styler = self2._styler;
      if (styler === void 0) {
        return string;
      }
      const { openAll, closeAll } = styler;
      if (string.indexOf("") !== -1) {
        while (styler !== void 0) {
          string = stringReplaceAll(string, styler.close, styler.open);
          styler = styler.parent;
        }
      }
      const lfIndex = string.indexOf("\n");
      if (lfIndex !== -1) {
        string = stringEncaseCRLFWithFirstIndex(string, closeAll, openAll, lfIndex);
      }
      return openAll + string + closeAll;
    };
    var template;
    var chalkTag = (chalk2, ...strings) => {
      const [firstString] = strings;
      if (!isArray(firstString) || !isArray(firstString.raw)) {
        return strings.join(" ");
      }
      const arguments_ = strings.slice(1);
      const parts = [firstString.raw[0]];
      for (let i = 1; i < firstString.length; i++) {
        parts.push(String(arguments_[i - 1]).replace(/[{}\\]/g, "\\$&"), String(firstString.raw[i]));
      }
      if (template === void 0) {
        template = require_templates();
      }
      return template(chalk2, parts.join(""));
    };
    Object.defineProperties(Chalk.prototype, styles);
    var chalk = Chalk();
    chalk.supportsColor = stdoutColor;
    chalk.stderr = Chalk({ level: stderrColor ? stderrColor.level : 0 });
    chalk.stderr.supportsColor = stderrColor;
    module2.exports = chalk;
  }
});

// ../node_modules/keypress/index.js
var require_keypress = __commonJS({
  "../node_modules/keypress/index.js"(exports2, module2) {
    var EventEmitter = require("events").EventEmitter;
    var exports2 = module2.exports = keypress;
    function keypress(stream2) {
      if (isEmittingKeypress(stream2))
        return;
      var StringDecoder = require("string_decoder").StringDecoder;
      stream2._keypressDecoder = new StringDecoder("utf8");
      function onData(b) {
        if (listenerCount(stream2, "keypress") > 0) {
          var r = stream2._keypressDecoder.write(b);
          if (r)
            emitKey(stream2, r);
        } else {
          stream2.removeListener("data", onData);
          stream2.on("newListener", onNewListener);
        }
      }
      function onNewListener(event) {
        if (event == "keypress") {
          stream2.on("data", onData);
          stream2.removeListener("newListener", onNewListener);
        }
      }
      if (listenerCount(stream2, "keypress") > 0) {
        stream2.on("data", onData);
      } else {
        stream2.on("newListener", onNewListener);
      }
    }
    function isEmittingKeypress(stream2) {
      var rtn = !!stream2._keypressDecoder;
      if (!rtn) {
        stream2.listeners("data").slice(0).forEach(function(l) {
          if (l.name == "onData" && /emitKey/.test(l.toString())) {
            stream2.removeListener("data", l);
          }
        });
        stream2.listeners("newListener").slice(0).forEach(function(l) {
          if (l.name == "onNewListener" && /keypress/.test(l.toString())) {
            stream2.removeListener("newListener", l);
          }
        });
      }
      return rtn;
    }
    exports2.enableMouse = function(stream2) {
      stream2.write("[?1000h");
    };
    exports2.disableMouse = function(stream2) {
      stream2.write("[?1000l");
    };
    var listenerCount = EventEmitter.listenerCount;
    if (!listenerCount) {
      listenerCount = function(emitter, event) {
        return emitter.listeners(event).length;
      };
    }
    var metaKeyCodeRe = /^(?:\x1b)([a-zA-Z0-9])$/;
    var functionKeyCodeRe = /^(?:\x1b+)(O|N|\[|\[\[)(?:(\d+)(?:;(\d+))?([~^$])|(?:1;)?(\d+)?([a-zA-Z]))/;
    function emitKey(stream2, s) {
      var ch, key = {
        name: void 0,
        ctrl: false,
        meta: false,
        shift: false
      }, parts;
      if (Buffer.isBuffer(s)) {
        if (s[0] > 127 && s[1] === void 0) {
          s[0] -= 128;
          s = "" + s.toString(stream2.encoding || "utf-8");
        } else {
          s = s.toString(stream2.encoding || "utf-8");
        }
      }
      key.sequence = s;
      if (s === "\r") {
        key.name = "return";
      } else if (s === "\n") {
        key.name = "enter";
      } else if (s === "	") {
        key.name = "tab";
      } else if (s === "\b" || s === "\x7F" || s === "\x7F" || s === "\b") {
        key.name = "backspace";
        key.meta = s.charAt(0) === "";
      } else if (s === "" || s === "") {
        key.name = "escape";
        key.meta = s.length === 2;
      } else if (s === " " || s === " ") {
        key.name = "space";
        key.meta = s.length === 2;
      } else if (s <= "") {
        key.name = String.fromCharCode(s.charCodeAt(0) + "a".charCodeAt(0) - 1);
        key.ctrl = true;
      } else if (s.length === 1 && s >= "a" && s <= "z") {
        key.name = s;
      } else if (s.length === 1 && s >= "A" && s <= "Z") {
        key.name = s.toLowerCase();
        key.shift = true;
      } else if (parts = metaKeyCodeRe.exec(s)) {
        key.name = parts[1].toLowerCase();
        key.meta = true;
        key.shift = /^[A-Z]$/.test(parts[1]);
      } else if (parts = functionKeyCodeRe.exec(s)) {
        var code = (parts[1] || "") + (parts[2] || "") + (parts[4] || "") + (parts[6] || ""), modifier = (parts[3] || parts[5] || 1) - 1;
        key.ctrl = !!(modifier & 4);
        key.meta = !!(modifier & 10);
        key.shift = !!(modifier & 1);
        key.code = code;
        switch (code) {
          case "OP":
            key.name = "f1";
            break;
          case "OQ":
            key.name = "f2";
            break;
          case "OR":
            key.name = "f3";
            break;
          case "OS":
            key.name = "f4";
            break;
          case "[11~":
            key.name = "f1";
            break;
          case "[12~":
            key.name = "f2";
            break;
          case "[13~":
            key.name = "f3";
            break;
          case "[14~":
            key.name = "f4";
            break;
          case "[[A":
            key.name = "f1";
            break;
          case "[[B":
            key.name = "f2";
            break;
          case "[[C":
            key.name = "f3";
            break;
          case "[[D":
            key.name = "f4";
            break;
          case "[[E":
            key.name = "f5";
            break;
          case "[15~":
            key.name = "f5";
            break;
          case "[17~":
            key.name = "f6";
            break;
          case "[18~":
            key.name = "f7";
            break;
          case "[19~":
            key.name = "f8";
            break;
          case "[20~":
            key.name = "f9";
            break;
          case "[21~":
            key.name = "f10";
            break;
          case "[23~":
            key.name = "f11";
            break;
          case "[24~":
            key.name = "f12";
            break;
          case "[A":
            key.name = "up";
            break;
          case "[B":
            key.name = "down";
            break;
          case "[C":
            key.name = "right";
            break;
          case "[D":
            key.name = "left";
            break;
          case "[E":
            key.name = "clear";
            break;
          case "[F":
            key.name = "end";
            break;
          case "[H":
            key.name = "home";
            break;
          case "OA":
            key.name = "up";
            break;
          case "OB":
            key.name = "down";
            break;
          case "OC":
            key.name = "right";
            break;
          case "OD":
            key.name = "left";
            break;
          case "OE":
            key.name = "clear";
            break;
          case "OF":
            key.name = "end";
            break;
          case "OH":
            key.name = "home";
            break;
          case "[1~":
            key.name = "home";
            break;
          case "[2~":
            key.name = "insert";
            break;
          case "[3~":
            key.name = "delete";
            break;
          case "[4~":
            key.name = "end";
            break;
          case "[5~":
            key.name = "pageup";
            break;
          case "[6~":
            key.name = "pagedown";
            break;
          case "[[5~":
            key.name = "pageup";
            break;
          case "[[6~":
            key.name = "pagedown";
            break;
          case "[7~":
            key.name = "home";
            break;
          case "[8~":
            key.name = "end";
            break;
          case "[a":
            key.name = "up";
            key.shift = true;
            break;
          case "[b":
            key.name = "down";
            key.shift = true;
            break;
          case "[c":
            key.name = "right";
            key.shift = true;
            break;
          case "[d":
            key.name = "left";
            key.shift = true;
            break;
          case "[e":
            key.name = "clear";
            key.shift = true;
            break;
          case "[2$":
            key.name = "insert";
            key.shift = true;
            break;
          case "[3$":
            key.name = "delete";
            key.shift = true;
            break;
          case "[5$":
            key.name = "pageup";
            key.shift = true;
            break;
          case "[6$":
            key.name = "pagedown";
            key.shift = true;
            break;
          case "[7$":
            key.name = "home";
            key.shift = true;
            break;
          case "[8$":
            key.name = "end";
            key.shift = true;
            break;
          case "Oa":
            key.name = "up";
            key.ctrl = true;
            break;
          case "Ob":
            key.name = "down";
            key.ctrl = true;
            break;
          case "Oc":
            key.name = "right";
            key.ctrl = true;
            break;
          case "Od":
            key.name = "left";
            key.ctrl = true;
            break;
          case "Oe":
            key.name = "clear";
            key.ctrl = true;
            break;
          case "[2^":
            key.name = "insert";
            key.ctrl = true;
            break;
          case "[3^":
            key.name = "delete";
            key.ctrl = true;
            break;
          case "[5^":
            key.name = "pageup";
            key.ctrl = true;
            break;
          case "[6^":
            key.name = "pagedown";
            key.ctrl = true;
            break;
          case "[7^":
            key.name = "home";
            key.ctrl = true;
            break;
          case "[8^":
            key.name = "end";
            key.ctrl = true;
            break;
          case "[Z":
            key.name = "tab";
            key.shift = true;
            break;
          default:
            key.name = "undefined";
            break;
        }
      } else if (s.length > 1 && s[0] !== "") {
        Array.prototype.forEach.call(s, function(c) {
          emitKey(stream2, c);
        });
        return;
      }
      if (key.code == "[M") {
        key.name = "mouse";
        var s = key.sequence;
        var b = s.charCodeAt(3);
        key.x = s.charCodeAt(4) - 32;
        key.y = s.charCodeAt(5) - 32;
        key.scroll = 0;
        key.ctrl = !!(1 << 4 & b);
        key.meta = !!(1 << 3 & b);
        key.shift = !!(1 << 2 & b);
        key.release = (3 & b) === 3;
        if (1 << 6 & b) {
          key.scroll = 1 & b ? 1 : -1;
        }
        if (!key.release && !key.scroll) {
          key.button = b & 3;
        }
      }
      if (key.name === void 0) {
        key = void 0;
      }
      if (s.length === 1) {
        ch = s;
      }
      if (key && key.name == "mouse") {
        stream2.emit("mousepress", key);
      } else if (key || ch) {
        stream2.emit("keypress", ch, key);
      }
    }
  }
});

// ../node_modules/ansi-escapes/index.js
var require_ansi_escapes = __commonJS({
  "../node_modules/ansi-escapes/index.js"(exports2, module2) {
    "use strict";
    var ansiEscapes = module2.exports;
    module2.exports.default = ansiEscapes;
    var ESC = "[";
    var OSC = "]";
    var BEL = "\x07";
    var SEP = ";";
    var isTerminalApp = process.env.TERM_PROGRAM === "Apple_Terminal";
    ansiEscapes.cursorTo = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      if (typeof y !== "number") {
        return ESC + (x + 1) + "G";
      }
      return ESC + (y + 1) + ";" + (x + 1) + "H";
    };
    ansiEscapes.cursorMove = (x, y) => {
      if (typeof x !== "number") {
        throw new TypeError("The `x` argument is required");
      }
      let ret = "";
      if (x < 0) {
        ret += ESC + -x + "D";
      } else if (x > 0) {
        ret += ESC + x + "C";
      }
      if (y < 0) {
        ret += ESC + -y + "A";
      } else if (y > 0) {
        ret += ESC + y + "B";
      }
      return ret;
    };
    ansiEscapes.cursorUp = (count = 1) => ESC + count + "A";
    ansiEscapes.cursorDown = (count = 1) => ESC + count + "B";
    ansiEscapes.cursorForward = (count = 1) => ESC + count + "C";
    ansiEscapes.cursorBackward = (count = 1) => ESC + count + "D";
    ansiEscapes.cursorLeft = ESC + "G";
    ansiEscapes.cursorSavePosition = isTerminalApp ? "7" : ESC + "s";
    ansiEscapes.cursorRestorePosition = isTerminalApp ? "8" : ESC + "u";
    ansiEscapes.cursorGetPosition = ESC + "6n";
    ansiEscapes.cursorNextLine = ESC + "E";
    ansiEscapes.cursorPrevLine = ESC + "F";
    ansiEscapes.cursorHide = ESC + "?25l";
    ansiEscapes.cursorShow = ESC + "?25h";
    ansiEscapes.eraseLines = (count) => {
      let clear = "";
      for (let i = 0; i < count; i++) {
        clear += ansiEscapes.eraseLine + (i < count - 1 ? ansiEscapes.cursorUp() : "");
      }
      if (count) {
        clear += ansiEscapes.cursorLeft;
      }
      return clear;
    };
    ansiEscapes.eraseEndLine = ESC + "K";
    ansiEscapes.eraseStartLine = ESC + "1K";
    ansiEscapes.eraseLine = ESC + "2K";
    ansiEscapes.eraseDown = ESC + "J";
    ansiEscapes.eraseUp = ESC + "1J";
    ansiEscapes.eraseScreen = ESC + "2J";
    ansiEscapes.scrollUp = ESC + "S";
    ansiEscapes.scrollDown = ESC + "T";
    ansiEscapes.clearScreen = "c";
    ansiEscapes.clearTerminal = process.platform === "win32" ? `${ansiEscapes.eraseScreen}${ESC}0f` : `${ansiEscapes.eraseScreen}${ESC}3J${ESC}H`;
    ansiEscapes.beep = BEL;
    ansiEscapes.link = (text, url) => {
      return [
        OSC,
        "8",
        SEP,
        SEP,
        url,
        BEL,
        text,
        OSC,
        "8",
        SEP,
        SEP,
        BEL
      ].join("");
    };
    ansiEscapes.image = (buffer, options = {}) => {
      let ret = `${OSC}1337;File=inline=1`;
      if (options.width) {
        ret += `;width=${options.width}`;
      }
      if (options.height) {
        ret += `;height=${options.height}`;
      }
      if (options.preserveAspectRatio === false) {
        ret += ";preserveAspectRatio=0";
      }
      return ret + ":" + buffer.toString("base64") + BEL;
    };
    ansiEscapes.iTerm = {
      setCwd: (cwd = process.cwd()) => `${OSC}50;CurrentDir=${cwd}${BEL}`,
      annotation: (message, options = {}) => {
        let ret = `${OSC}1337;`;
        const hasX = typeof options.x !== "undefined";
        const hasY = typeof options.y !== "undefined";
        if ((hasX || hasY) && !(hasX && hasY && typeof options.length !== "undefined")) {
          throw new Error("`x`, `y` and `length` must be defined when `x` or `y` is defined");
        }
        message = message.replace(/\|/g, "");
        ret += options.isHidden ? "AddHiddenAnnotation=" : "AddAnnotation=";
        if (options.length > 0) {
          ret += (hasX ? [message, options.length, options.x, options.y] : [options.length, message]).join("|");
        } else {
          ret += message;
        }
        return ret + BEL;
      }
    };
  }
});

// ../node_modules/strip-ansi/node_modules/ansi-regex/index.js
var require_ansi_regex = __commonJS({
  "../node_modules/strip-ansi/node_modules/ansi-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = ({ onlyFirst = false } = {}) => {
      const pattern = [
        "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)",
        "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"
      ].join("|");
      return new RegExp(pattern, onlyFirst ? void 0 : "g");
    };
  }
});

// ../node_modules/strip-ansi/index.js
var require_strip_ansi = __commonJS({
  "../node_modules/strip-ansi/index.js"(exports2, module2) {
    "use strict";
    var ansiRegex = require_ansi_regex();
    module2.exports = (string) => typeof string === "string" ? string.replace(ansiRegex(), "") : string;
  }
});

// ../node_modules/minimist/index.js
var require_minimist = __commonJS({
  "../node_modules/minimist/index.js"(exports2, module2) {
    module2.exports = function(args, opts) {
      if (!opts)
        opts = {};
      var flags = { bools: {}, strings: {}, unknownFn: null };
      if (typeof opts["unknown"] === "function") {
        flags.unknownFn = opts["unknown"];
      }
      if (typeof opts["boolean"] === "boolean" && opts["boolean"]) {
        flags.allBools = true;
      } else {
        [].concat(opts["boolean"]).filter(Boolean).forEach(function(key2) {
          flags.bools[key2] = true;
        });
      }
      var aliases = {};
      Object.keys(opts.alias || {}).forEach(function(key2) {
        aliases[key2] = [].concat(opts.alias[key2]);
        aliases[key2].forEach(function(x) {
          aliases[x] = [key2].concat(aliases[key2].filter(function(y) {
            return x !== y;
          }));
        });
      });
      [].concat(opts.string).filter(Boolean).forEach(function(key2) {
        flags.strings[key2] = true;
        if (aliases[key2]) {
          flags.strings[aliases[key2]] = true;
        }
      });
      var defaults = opts["default"] || {};
      var argv = { _: [] };
      Object.keys(flags.bools).forEach(function(key2) {
        setArg(key2, defaults[key2] === void 0 ? false : defaults[key2]);
      });
      var notFlags = [];
      if (args.indexOf("--") !== -1) {
        notFlags = args.slice(args.indexOf("--") + 1);
        args = args.slice(0, args.indexOf("--"));
      }
      function argDefined(key2, arg2) {
        return flags.allBools && /^--[^=]+$/.test(arg2) || flags.strings[key2] || flags.bools[key2] || aliases[key2];
      }
      function setArg(key2, val, arg2) {
        if (arg2 && flags.unknownFn && !argDefined(key2, arg2)) {
          if (flags.unknownFn(arg2) === false)
            return;
        }
        var value2 = !flags.strings[key2] && isNumber(val) ? Number(val) : val;
        setKey(argv, key2.split("."), value2);
        (aliases[key2] || []).forEach(function(x) {
          setKey(argv, x.split("."), value2);
        });
      }
      function setKey(obj, keys, value2) {
        var o = obj;
        for (var i2 = 0; i2 < keys.length - 1; i2++) {
          var key2 = keys[i2];
          if (key2 === "__proto__")
            return;
          if (o[key2] === void 0)
            o[key2] = {};
          if (o[key2] === Object.prototype || o[key2] === Number.prototype || o[key2] === String.prototype)
            o[key2] = {};
          if (o[key2] === Array.prototype)
            o[key2] = [];
          o = o[key2];
        }
        var key2 = keys[keys.length - 1];
        if (key2 === "__proto__")
          return;
        if (o === Object.prototype || o === Number.prototype || o === String.prototype)
          o = {};
        if (o === Array.prototype)
          o = [];
        if (o[key2] === void 0 || flags.bools[key2] || typeof o[key2] === "boolean") {
          o[key2] = value2;
        } else if (Array.isArray(o[key2])) {
          o[key2].push(value2);
        } else {
          o[key2] = [o[key2], value2];
        }
      }
      function aliasIsBoolean(key2) {
        return aliases[key2].some(function(x) {
          return flags.bools[x];
        });
      }
      for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        if (/^--.+=/.test(arg)) {
          var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
          var key = m[1];
          var value = m[2];
          if (flags.bools[key]) {
            value = value !== "false";
          }
          setArg(key, value, arg);
        } else if (/^--no-.+/.test(arg)) {
          var key = arg.match(/^--no-(.+)/)[1];
          setArg(key, false, arg);
        } else if (/^--.+/.test(arg)) {
          var key = arg.match(/^--(.+)/)[1];
          var next = args[i + 1];
          if (next !== void 0 && !/^-/.test(next) && !flags.bools[key] && !flags.allBools && (aliases[key] ? !aliasIsBoolean(key) : true)) {
            setArg(key, next, arg);
            i++;
          } else if (/^(true|false)$/.test(next)) {
            setArg(key, next === "true", arg);
            i++;
          } else {
            setArg(key, flags.strings[key] ? "" : true, arg);
          }
        } else if (/^-[^-]+/.test(arg)) {
          var letters = arg.slice(1, -1).split("");
          var broken = false;
          for (var j = 0; j < letters.length; j++) {
            var next = arg.slice(j + 2);
            if (next === "-") {
              setArg(letters[j], next, arg);
              continue;
            }
            if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
              setArg(letters[j], next.split("=")[1], arg);
              broken = true;
              break;
            }
            if (/[A-Za-z]/.test(letters[j]) && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
              setArg(letters[j], next, arg);
              broken = true;
              break;
            }
            if (letters[j + 1] && letters[j + 1].match(/\W/)) {
              setArg(letters[j], arg.slice(j + 2), arg);
              broken = true;
              break;
            } else {
              setArg(letters[j], flags.strings[letters[j]] ? "" : true, arg);
            }
          }
          var key = arg.slice(-1)[0];
          if (!broken && key !== "-") {
            if (args[i + 1] && !/^(-|--)[^-]/.test(args[i + 1]) && !flags.bools[key] && (aliases[key] ? !aliasIsBoolean(key) : true)) {
              setArg(key, args[i + 1], arg);
              i++;
            } else if (args[i + 1] && /^(true|false)$/.test(args[i + 1])) {
              setArg(key, args[i + 1] === "true", arg);
              i++;
            } else {
              setArg(key, flags.strings[key] ? "" : true, arg);
            }
          }
        } else {
          if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
            argv._.push(flags.strings["_"] || !isNumber(arg) ? arg : Number(arg));
          }
          if (opts.stopEarly) {
            argv._.push.apply(argv._, args.slice(i + 1));
            break;
          }
        }
      }
      Object.keys(defaults).forEach(function(key2) {
        if (!hasKey(argv, key2.split("."))) {
          setKey(argv, key2.split("."), defaults[key2]);
          (aliases[key2] || []).forEach(function(x) {
            setKey(argv, x.split("."), defaults[key2]);
          });
        }
      });
      if (opts["--"]) {
        argv["--"] = new Array();
        notFlags.forEach(function(key2) {
          argv["--"].push(key2);
        });
      } else {
        notFlags.forEach(function(key2) {
          argv._.push(key2);
        });
      }
      return argv;
    };
    function hasKey(obj, keys) {
      var o = obj;
      keys.slice(0, -1).forEach(function(key2) {
        o = o[key2] || {};
      });
      var key = keys[keys.length - 1];
      return key in o;
    }
    function isNumber(x) {
      if (typeof x === "number")
        return true;
      if (/^0x[0-9a-f]+$/i.test(x))
        return true;
      return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
    }
  }
});

// ../node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "../node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal;
  }
});

// ../node_modules/lodash/_root.js
var require_root = __commonJS({
  "../node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    module2.exports = root;
  }
});

// ../node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "../node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root = require_root();
    var Symbol2 = root.Symbol;
    module2.exports = Symbol2;
  }
});

// ../node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "../node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    module2.exports = copyArray;
  }
});

// ../node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "../node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var nativeObjectToString = objectProto.toString;
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function getRawTag(value) {
      var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
      try {
        value[symToStringTag] = void 0;
        var unmasked = true;
      } catch (e) {
      }
      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    module2.exports = getRawTag;
  }
});

// ../node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "../node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto = Object.prototype;
    var nativeObjectToString = objectProto.toString;
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
    module2.exports = objectToString;
  }
});

// ../node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "../node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var getRawTag = require_getRawTag();
    var objectToString = require_objectToString();
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    module2.exports = baseGetTag;
  }
});

// ../node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "../node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject;
  }
});

// ../node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "../node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObject = require_isObject();
    var asyncTag = "[object AsyncFunction]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var proxyTag = "[object Proxy]";
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }
    module2.exports = isFunction;
  }
});

// ../node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "../node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root = require_root();
    var coreJsData = root["__core-js_shared__"];
    module2.exports = coreJsData;
  }
});

// ../node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "../node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData = require_coreJsData();
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    module2.exports = isMasked;
  }
});

// ../node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "../node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    module2.exports = toSource;
  }
});

// ../node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "../node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isMasked = require_isMasked();
    var isObject = require_isObject();
    var toSource = require_toSource();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    module2.exports = baseIsNative;
  }
});

// ../node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "../node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    module2.exports = getValue;
  }
});

// ../node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "../node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative = require_baseIsNative();
    var getValue = require_getValue();
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    module2.exports = getNative;
  }
});

// ../node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "../node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var DataView = getNative(root, "DataView");
    module2.exports = DataView;
  }
});

// ../node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "../node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Map2 = getNative(root, "Map");
    module2.exports = Map2;
  }
});

// ../node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "../node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Promise2 = getNative(root, "Promise");
    module2.exports = Promise2;
  }
});

// ../node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "../node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var Set2 = getNative(root, "Set");
    module2.exports = Set2;
  }
});

// ../node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "../node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative = require_getNative();
    var root = require_root();
    var WeakMap = getNative(root, "WeakMap");
    module2.exports = WeakMap;
  }
});

// ../node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "../node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView = require_DataView();
    var Map2 = require_Map();
    var Promise2 = require_Promise();
    var Set2 = require_Set();
    var WeakMap = require_WeakMap();
    var baseGetTag = require_baseGetTag();
    var toSource = require_toSource();
    var mapTag = "[object Map]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var setTag = "[object Set]";
    var weakMapTag = "[object WeakMap]";
    var dataViewTag = "[object DataView]";
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap);
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
      getTag = function(value) {
        var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    module2.exports = getTag;
  }
});

// ../node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "../node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    module2.exports = isLength;
  }
});

// ../node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "../node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction = require_isFunction();
    var isLength = require_isLength();
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    module2.exports = isArrayLike;
  }
});

// ../node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "../node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray = Array.isArray;
    module2.exports = isArray;
  }
});

// ../node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "../node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike;
  }
});

// ../node_modules/lodash/isString.js
var require_isString = __commonJS({
  "../node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isArray = require_isArray();
    var isObjectLike = require_isObjectLike();
    var stringTag = "[object String]";
    function isString(value) {
      return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
    }
    module2.exports = isString;
  }
});

// ../node_modules/lodash/_iteratorToArray.js
var require_iteratorToArray = __commonJS({
  "../node_modules/lodash/_iteratorToArray.js"(exports2, module2) {
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    module2.exports = iteratorToArray;
  }
});

// ../node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "../node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray;
  }
});

// ../node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "../node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    module2.exports = setToArray;
  }
});

// ../node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "../node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string) {
      return string.split("");
    }
    module2.exports = asciiToArray;
  }
});

// ../node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "../node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    module2.exports = hasUnicode;
  }
});

// ../node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "../node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// ../node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "../node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    module2.exports = stringToArray;
  }
});

// ../node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "../node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module2.exports = arrayMap;
  }
});

// ../node_modules/lodash/_baseValues.js
var require_baseValues = __commonJS({
  "../node_modules/lodash/_baseValues.js"(exports2, module2) {
    var arrayMap = require_arrayMap();
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    module2.exports = baseValues;
  }
});

// ../node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "../node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    module2.exports = baseTimes;
  }
});

// ../node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "../node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }
    module2.exports = baseIsArguments;
  }
});

// ../node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "../node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments = require_baseIsArguments();
    var isObjectLike = require_isObjectLike();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var isArguments = baseIsArguments(function() {
      return arguments;
    }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
    };
    module2.exports = isArguments;
  }
});

// ../node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "../node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse() {
      return false;
    }
    module2.exports = stubFalse;
  }
});

// ../node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "../node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root = require_root();
    var stubFalse = require_stubFalse();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer;
  }
});

// ../node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "../node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex;
  }
});

// ../node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "../node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag = require_baseGetTag();
    var isLength = require_isLength();
    var isObjectLike = require_isObjectLike();
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }
    module2.exports = baseIsTypedArray;
  }
});

// ../node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "../node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary;
  }
});

// ../node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "../node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  }
});

// ../node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "../node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray = require_baseIsTypedArray();
    var baseUnary = require_baseUnary();
    var nodeUtil = require_nodeUtil();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    module2.exports = isTypedArray;
  }
});

// ../node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "../node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes = require_baseTimes();
    var isArguments = require_isArguments();
    var isArray = require_isArray();
    var isBuffer = require_isBuffer();
    var isIndex = require_isIndex();
    var isTypedArray = require_isTypedArray();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys;
  }
});

// ../node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "../node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto = Object.prototype;
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    module2.exports = isPrototype;
  }
});

// ../node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "../node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg;
  }
});

// ../node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "../node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg = require_overArg();
    var nativeKeys = overArg(Object.keys, Object);
    module2.exports = nativeKeys;
  }
});

// ../node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "../node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype = require_isPrototype();
    var nativeKeys = require_nativeKeys();
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty2.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys;
  }
});

// ../node_modules/lodash/keys.js
var require_keys = __commonJS({
  "../node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys = require_arrayLikeKeys();
    var baseKeys = require_baseKeys();
    var isArrayLike = require_isArrayLike();
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    module2.exports = keys;
  }
});

// ../node_modules/lodash/values.js
var require_values = __commonJS({
  "../node_modules/lodash/values.js"(exports2, module2) {
    var baseValues = require_baseValues();
    var keys = require_keys();
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }
    module2.exports = values;
  }
});

// ../node_modules/lodash/toArray.js
var require_toArray = __commonJS({
  "../node_modules/lodash/toArray.js"(exports2, module2) {
    var Symbol2 = require_Symbol();
    var copyArray = require_copyArray();
    var getTag = require_getTag();
    var isArrayLike = require_isArrayLike();
    var isString = require_isString();
    var iteratorToArray = require_iteratorToArray();
    var mapToArray = require_mapToArray();
    var setToArray = require_setToArray();
    var stringToArray = require_stringToArray();
    var values = require_values();
    var mapTag = "[object Map]";
    var setTag = "[object Set]";
    var symIterator = Symbol2 ? Symbol2.iterator : void 0;
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
      return func(value);
    }
    module2.exports = toArray;
  }
});

// ../node_modules/node-emoji/lib/emoji.json
var require_emoji = __commonJS({
  "../node_modules/node-emoji/lib/emoji.json"(exports2, module2) {
    module2.exports = { "100": "\u{1F4AF}", "1234": "\u{1F522}", umbrella_with_rain_drops: "\u2614", coffee: "\u2615", aries: "\u2648", taurus: "\u2649", sagittarius: "\u2650", capricorn: "\u2651", aquarius: "\u2652", pisces: "\u2653", anchor: "\u2693", white_check_mark: "\u2705", sparkles: "\u2728", question: "\u2753", grey_question: "\u2754", grey_exclamation: "\u2755", exclamation: "\u2757", heavy_exclamation_mark: "\u2757", heavy_plus_sign: "\u2795", heavy_minus_sign: "\u2796", heavy_division_sign: "\u2797", hash: "#\uFE0F\u20E3", keycap_star: "*\uFE0F\u20E3", zero: "0\uFE0F\u20E3", one: "1\uFE0F\u20E3", two: "2\uFE0F\u20E3", three: "3\uFE0F\u20E3", four: "4\uFE0F\u20E3", five: "5\uFE0F\u20E3", six: "6\uFE0F\u20E3", seven: "7\uFE0F\u20E3", eight: "8\uFE0F\u20E3", nine: "9\uFE0F\u20E3", copyright: "\xA9\uFE0F", registered: "\xAE\uFE0F", mahjong: "\u{1F004}", black_joker: "\u{1F0CF}", a: "\u{1F170}\uFE0F", b: "\u{1F171}\uFE0F", o2: "\u{1F17E}\uFE0F", parking: "\u{1F17F}\uFE0F", ab: "\u{1F18E}", cl: "\u{1F191}", cool: "\u{1F192}", free: "\u{1F193}", id: "\u{1F194}", new: "\u{1F195}", ng: "\u{1F196}", ok: "\u{1F197}", sos: "\u{1F198}", up: "\u{1F199}", vs: "\u{1F19A}", "flag-ac": "\u{1F1E6}\u{1F1E8}", "flag-ad": "\u{1F1E6}\u{1F1E9}", "flag-ae": "\u{1F1E6}\u{1F1EA}", "flag-af": "\u{1F1E6}\u{1F1EB}", "flag-ag": "\u{1F1E6}\u{1F1EC}", "flag-ai": "\u{1F1E6}\u{1F1EE}", "flag-al": "\u{1F1E6}\u{1F1F1}", "flag-am": "\u{1F1E6}\u{1F1F2}", "flag-ao": "\u{1F1E6}\u{1F1F4}", "flag-aq": "\u{1F1E6}\u{1F1F6}", "flag-ar": "\u{1F1E6}\u{1F1F7}", "flag-as": "\u{1F1E6}\u{1F1F8}", "flag-at": "\u{1F1E6}\u{1F1F9}", "flag-au": "\u{1F1E6}\u{1F1FA}", "flag-aw": "\u{1F1E6}\u{1F1FC}", "flag-ax": "\u{1F1E6}\u{1F1FD}", "flag-az": "\u{1F1E6}\u{1F1FF}", "flag-ba": "\u{1F1E7}\u{1F1E6}", "flag-bb": "\u{1F1E7}\u{1F1E7}", "flag-bd": "\u{1F1E7}\u{1F1E9}", "flag-be": "\u{1F1E7}\u{1F1EA}", "flag-bf": "\u{1F1E7}\u{1F1EB}", "flag-bg": "\u{1F1E7}\u{1F1EC}", "flag-bh": "\u{1F1E7}\u{1F1ED}", "flag-bi": "\u{1F1E7}\u{1F1EE}", "flag-bj": "\u{1F1E7}\u{1F1EF}", "flag-bl": "\u{1F1E7}\u{1F1F1}", "flag-bm": "\u{1F1E7}\u{1F1F2}", "flag-bn": "\u{1F1E7}\u{1F1F3}", "flag-bo": "\u{1F1E7}\u{1F1F4}", "flag-bq": "\u{1F1E7}\u{1F1F6}", "flag-br": "\u{1F1E7}\u{1F1F7}", "flag-bs": "\u{1F1E7}\u{1F1F8}", "flag-bt": "\u{1F1E7}\u{1F1F9}", "flag-bv": "\u{1F1E7}\u{1F1FB}", "flag-bw": "\u{1F1E7}\u{1F1FC}", "flag-by": "\u{1F1E7}\u{1F1FE}", "flag-bz": "\u{1F1E7}\u{1F1FF}", "flag-ca": "\u{1F1E8}\u{1F1E6}", "flag-cc": "\u{1F1E8}\u{1F1E8}", "flag-cd": "\u{1F1E8}\u{1F1E9}", "flag-cf": "\u{1F1E8}\u{1F1EB}", "flag-cg": "\u{1F1E8}\u{1F1EC}", "flag-ch": "\u{1F1E8}\u{1F1ED}", "flag-ci": "\u{1F1E8}\u{1F1EE}", "flag-ck": "\u{1F1E8}\u{1F1F0}", "flag-cl": "\u{1F1E8}\u{1F1F1}", "flag-cm": "\u{1F1E8}\u{1F1F2}", cn: "\u{1F1E8}\u{1F1F3}", "flag-cn": "\u{1F1E8}\u{1F1F3}", "flag-co": "\u{1F1E8}\u{1F1F4}", "flag-cp": "\u{1F1E8}\u{1F1F5}", "flag-cr": "\u{1F1E8}\u{1F1F7}", "flag-cu": "\u{1F1E8}\u{1F1FA}", "flag-cv": "\u{1F1E8}\u{1F1FB}", "flag-cw": "\u{1F1E8}\u{1F1FC}", "flag-cx": "\u{1F1E8}\u{1F1FD}", "flag-cy": "\u{1F1E8}\u{1F1FE}", "flag-cz": "\u{1F1E8}\u{1F1FF}", de: "\u{1F1E9}\u{1F1EA}", "flag-de": "\u{1F1E9}\u{1F1EA}", "flag-dg": "\u{1F1E9}\u{1F1EC}", "flag-dj": "\u{1F1E9}\u{1F1EF}", "flag-dk": "\u{1F1E9}\u{1F1F0}", "flag-dm": "\u{1F1E9}\u{1F1F2}", "flag-do": "\u{1F1E9}\u{1F1F4}", "flag-dz": "\u{1F1E9}\u{1F1FF}", "flag-ea": "\u{1F1EA}\u{1F1E6}", "flag-ec": "\u{1F1EA}\u{1F1E8}", "flag-ee": "\u{1F1EA}\u{1F1EA}", "flag-eg": "\u{1F1EA}\u{1F1EC}", "flag-eh": "\u{1F1EA}\u{1F1ED}", "flag-er": "\u{1F1EA}\u{1F1F7}", es: "\u{1F1EA}\u{1F1F8}", "flag-es": "\u{1F1EA}\u{1F1F8}", "flag-et": "\u{1F1EA}\u{1F1F9}", "flag-eu": "\u{1F1EA}\u{1F1FA}", "flag-fi": "\u{1F1EB}\u{1F1EE}", "flag-fj": "\u{1F1EB}\u{1F1EF}", "flag-fk": "\u{1F1EB}\u{1F1F0}", "flag-fm": "\u{1F1EB}\u{1F1F2}", "flag-fo": "\u{1F1EB}\u{1F1F4}", fr: "\u{1F1EB}\u{1F1F7}", "flag-fr": "\u{1F1EB}\u{1F1F7}", "flag-ga": "\u{1F1EC}\u{1F1E6}", gb: "\u{1F1EC}\u{1F1E7}", uk: "\u{1F1EC}\u{1F1E7}", "flag-gb": "\u{1F1EC}\u{1F1E7}", "flag-gd": "\u{1F1EC}\u{1F1E9}", "flag-ge": "\u{1F1EC}\u{1F1EA}", "flag-gf": "\u{1F1EC}\u{1F1EB}", "flag-gg": "\u{1F1EC}\u{1F1EC}", "flag-gh": "\u{1F1EC}\u{1F1ED}", "flag-gi": "\u{1F1EC}\u{1F1EE}", "flag-gl": "\u{1F1EC}\u{1F1F1}", "flag-gm": "\u{1F1EC}\u{1F1F2}", "flag-gn": "\u{1F1EC}\u{1F1F3}", "flag-gp": "\u{1F1EC}\u{1F1F5}", "flag-gq": "\u{1F1EC}\u{1F1F6}", "flag-gr": "\u{1F1EC}\u{1F1F7}", "flag-gs": "\u{1F1EC}\u{1F1F8}", "flag-gt": "\u{1F1EC}\u{1F1F9}", "flag-gu": "\u{1F1EC}\u{1F1FA}", "flag-gw": "\u{1F1EC}\u{1F1FC}", "flag-gy": "\u{1F1EC}\u{1F1FE}", "flag-hk": "\u{1F1ED}\u{1F1F0}", "flag-hm": "\u{1F1ED}\u{1F1F2}", "flag-hn": "\u{1F1ED}\u{1F1F3}", "flag-hr": "\u{1F1ED}\u{1F1F7}", "flag-ht": "\u{1F1ED}\u{1F1F9}", "flag-hu": "\u{1F1ED}\u{1F1FA}", "flag-ic": "\u{1F1EE}\u{1F1E8}", "flag-id": "\u{1F1EE}\u{1F1E9}", "flag-ie": "\u{1F1EE}\u{1F1EA}", "flag-il": "\u{1F1EE}\u{1F1F1}", "flag-im": "\u{1F1EE}\u{1F1F2}", "flag-in": "\u{1F1EE}\u{1F1F3}", "flag-io": "\u{1F1EE}\u{1F1F4}", "flag-iq": "\u{1F1EE}\u{1F1F6}", "flag-ir": "\u{1F1EE}\u{1F1F7}", "flag-is": "\u{1F1EE}\u{1F1F8}", it: "\u{1F1EE}\u{1F1F9}", "flag-it": "\u{1F1EE}\u{1F1F9}", "flag-je": "\u{1F1EF}\u{1F1EA}", "flag-jm": "\u{1F1EF}\u{1F1F2}", "flag-jo": "\u{1F1EF}\u{1F1F4}", jp: "\u{1F1EF}\u{1F1F5}", "flag-jp": "\u{1F1EF}\u{1F1F5}", "flag-ke": "\u{1F1F0}\u{1F1EA}", "flag-kg": "\u{1F1F0}\u{1F1EC}", "flag-kh": "\u{1F1F0}\u{1F1ED}", "flag-ki": "\u{1F1F0}\u{1F1EE}", "flag-km": "\u{1F1F0}\u{1F1F2}", "flag-kn": "\u{1F1F0}\u{1F1F3}", "flag-kp": "\u{1F1F0}\u{1F1F5}", kr: "\u{1F1F0}\u{1F1F7}", "flag-kr": "\u{1F1F0}\u{1F1F7}", "flag-kw": "\u{1F1F0}\u{1F1FC}", "flag-ky": "\u{1F1F0}\u{1F1FE}", "flag-kz": "\u{1F1F0}\u{1F1FF}", "flag-la": "\u{1F1F1}\u{1F1E6}", "flag-lb": "\u{1F1F1}\u{1F1E7}", "flag-lc": "\u{1F1F1}\u{1F1E8}", "flag-li": "\u{1F1F1}\u{1F1EE}", "flag-lk": "\u{1F1F1}\u{1F1F0}", "flag-lr": "\u{1F1F1}\u{1F1F7}", "flag-ls": "\u{1F1F1}\u{1F1F8}", "flag-lt": "\u{1F1F1}\u{1F1F9}", "flag-lu": "\u{1F1F1}\u{1F1FA}", "flag-lv": "\u{1F1F1}\u{1F1FB}", "flag-ly": "\u{1F1F1}\u{1F1FE}", "flag-ma": "\u{1F1F2}\u{1F1E6}", "flag-mc": "\u{1F1F2}\u{1F1E8}", "flag-md": "\u{1F1F2}\u{1F1E9}", "flag-me": "\u{1F1F2}\u{1F1EA}", "flag-mf": "\u{1F1F2}\u{1F1EB}", "flag-mg": "\u{1F1F2}\u{1F1EC}", "flag-mh": "\u{1F1F2}\u{1F1ED}", "flag-mk": "\u{1F1F2}\u{1F1F0}", "flag-ml": "\u{1F1F2}\u{1F1F1}", "flag-mm": "\u{1F1F2}\u{1F1F2}", "flag-mn": "\u{1F1F2}\u{1F1F3}", "flag-mo": "\u{1F1F2}\u{1F1F4}", "flag-mp": "\u{1F1F2}\u{1F1F5}", "flag-mq": "\u{1F1F2}\u{1F1F6}", "flag-mr": "\u{1F1F2}\u{1F1F7}", "flag-ms": "\u{1F1F2}\u{1F1F8}", "flag-mt": "\u{1F1F2}\u{1F1F9}", "flag-mu": "\u{1F1F2}\u{1F1FA}", "flag-mv": "\u{1F1F2}\u{1F1FB}", "flag-mw": "\u{1F1F2}\u{1F1FC}", "flag-mx": "\u{1F1F2}\u{1F1FD}", "flag-my": "\u{1F1F2}\u{1F1FE}", "flag-mz": "\u{1F1F2}\u{1F1FF}", "flag-na": "\u{1F1F3}\u{1F1E6}", "flag-nc": "\u{1F1F3}\u{1F1E8}", "flag-ne": "\u{1F1F3}\u{1F1EA}", "flag-nf": "\u{1F1F3}\u{1F1EB}", "flag-ng": "\u{1F1F3}\u{1F1EC}", "flag-ni": "\u{1F1F3}\u{1F1EE}", "flag-nl": "\u{1F1F3}\u{1F1F1}", "flag-no": "\u{1F1F3}\u{1F1F4}", "flag-np": "\u{1F1F3}\u{1F1F5}", "flag-nr": "\u{1F1F3}\u{1F1F7}", "flag-nu": "\u{1F1F3}\u{1F1FA}", "flag-nz": "\u{1F1F3}\u{1F1FF}", "flag-om": "\u{1F1F4}\u{1F1F2}", "flag-pa": "\u{1F1F5}\u{1F1E6}", "flag-pe": "\u{1F1F5}\u{1F1EA}", "flag-pf": "\u{1F1F5}\u{1F1EB}", "flag-pg": "\u{1F1F5}\u{1F1EC}", "flag-ph": "\u{1F1F5}\u{1F1ED}", "flag-pk": "\u{1F1F5}\u{1F1F0}", "flag-pl": "\u{1F1F5}\u{1F1F1}", "flag-pm": "\u{1F1F5}\u{1F1F2}", "flag-pn": "\u{1F1F5}\u{1F1F3}", "flag-pr": "\u{1F1F5}\u{1F1F7}", "flag-ps": "\u{1F1F5}\u{1F1F8}", "flag-pt": "\u{1F1F5}\u{1F1F9}", "flag-pw": "\u{1F1F5}\u{1F1FC}", "flag-py": "\u{1F1F5}\u{1F1FE}", "flag-qa": "\u{1F1F6}\u{1F1E6}", "flag-re": "\u{1F1F7}\u{1F1EA}", "flag-ro": "\u{1F1F7}\u{1F1F4}", "flag-rs": "\u{1F1F7}\u{1F1F8}", ru: "\u{1F1F7}\u{1F1FA}", "flag-ru": "\u{1F1F7}\u{1F1FA}", "flag-rw": "\u{1F1F7}\u{1F1FC}", "flag-sa": "\u{1F1F8}\u{1F1E6}", "flag-sb": "\u{1F1F8}\u{1F1E7}", "flag-sc": "\u{1F1F8}\u{1F1E8}", "flag-sd": "\u{1F1F8}\u{1F1E9}", "flag-se": "\u{1F1F8}\u{1F1EA}", "flag-sg": "\u{1F1F8}\u{1F1EC}", "flag-sh": "\u{1F1F8}\u{1F1ED}", "flag-si": "\u{1F1F8}\u{1F1EE}", "flag-sj": "\u{1F1F8}\u{1F1EF}", "flag-sk": "\u{1F1F8}\u{1F1F0}", "flag-sl": "\u{1F1F8}\u{1F1F1}", "flag-sm": "\u{1F1F8}\u{1F1F2}", "flag-sn": "\u{1F1F8}\u{1F1F3}", "flag-so": "\u{1F1F8}\u{1F1F4}", "flag-sr": "\u{1F1F8}\u{1F1F7}", "flag-ss": "\u{1F1F8}\u{1F1F8}", "flag-st": "\u{1F1F8}\u{1F1F9}", "flag-sv": "\u{1F1F8}\u{1F1FB}", "flag-sx": "\u{1F1F8}\u{1F1FD}", "flag-sy": "\u{1F1F8}\u{1F1FE}", "flag-sz": "\u{1F1F8}\u{1F1FF}", "flag-ta": "\u{1F1F9}\u{1F1E6}", "flag-tc": "\u{1F1F9}\u{1F1E8}", "flag-td": "\u{1F1F9}\u{1F1E9}", "flag-tf": "\u{1F1F9}\u{1F1EB}", "flag-tg": "\u{1F1F9}\u{1F1EC}", "flag-th": "\u{1F1F9}\u{1F1ED}", "flag-tj": "\u{1F1F9}\u{1F1EF}", "flag-tk": "\u{1F1F9}\u{1F1F0}", "flag-tl": "\u{1F1F9}\u{1F1F1}", "flag-tm": "\u{1F1F9}\u{1F1F2}", "flag-tn": "\u{1F1F9}\u{1F1F3}", "flag-to": "\u{1F1F9}\u{1F1F4}", "flag-tr": "\u{1F1F9}\u{1F1F7}", "flag-tt": "\u{1F1F9}\u{1F1F9}", "flag-tv": "\u{1F1F9}\u{1F1FB}", "flag-tw": "\u{1F1F9}\u{1F1FC}", "flag-tz": "\u{1F1F9}\u{1F1FF}", "flag-ua": "\u{1F1FA}\u{1F1E6}", "flag-ug": "\u{1F1FA}\u{1F1EC}", "flag-um": "\u{1F1FA}\u{1F1F2}", "flag-un": "\u{1F1FA}\u{1F1F3}", us: "\u{1F1FA}\u{1F1F8}", "flag-us": "\u{1F1FA}\u{1F1F8}", "flag-uy": "\u{1F1FA}\u{1F1FE}", "flag-uz": "\u{1F1FA}\u{1F1FF}", "flag-va": "\u{1F1FB}\u{1F1E6}", "flag-vc": "\u{1F1FB}\u{1F1E8}", "flag-ve": "\u{1F1FB}\u{1F1EA}", "flag-vg": "\u{1F1FB}\u{1F1EC}", "flag-vi": "\u{1F1FB}\u{1F1EE}", "flag-vn": "\u{1F1FB}\u{1F1F3}", "flag-vu": "\u{1F1FB}\u{1F1FA}", "flag-wf": "\u{1F1FC}\u{1F1EB}", "flag-ws": "\u{1F1FC}\u{1F1F8}", "flag-xk": "\u{1F1FD}\u{1F1F0}", "flag-ye": "\u{1F1FE}\u{1F1EA}", "flag-yt": "\u{1F1FE}\u{1F1F9}", "flag-za": "\u{1F1FF}\u{1F1E6}", "flag-zm": "\u{1F1FF}\u{1F1F2}", "flag-zw": "\u{1F1FF}\u{1F1FC}", koko: "\u{1F201}", sa: "\u{1F202}\uFE0F", u7121: "\u{1F21A}", u6307: "\u{1F22F}", u7981: "\u{1F232}", u7a7a: "\u{1F233}", u5408: "\u{1F234}", u6e80: "\u{1F235}", u6709: "\u{1F236}", u6708: "\u{1F237}\uFE0F", u7533: "\u{1F238}", u5272: "\u{1F239}", u55b6: "\u{1F23A}", ideograph_advantage: "\u{1F250}", accept: "\u{1F251}", cyclone: "\u{1F300}", foggy: "\u{1F301}", closed_umbrella: "\u{1F302}", night_with_stars: "\u{1F303}", sunrise_over_mountains: "\u{1F304}", sunrise: "\u{1F305}", city_sunset: "\u{1F306}", city_sunrise: "\u{1F307}", rainbow: "\u{1F308}", bridge_at_night: "\u{1F309}", ocean: "\u{1F30A}", volcano: "\u{1F30B}", milky_way: "\u{1F30C}", earth_africa: "\u{1F30D}", earth_americas: "\u{1F30E}", earth_asia: "\u{1F30F}", globe_with_meridians: "\u{1F310}", new_moon: "\u{1F311}", waxing_crescent_moon: "\u{1F312}", first_quarter_moon: "\u{1F313}", moon: "\u{1F314}", waxing_gibbous_moon: "\u{1F314}", full_moon: "\u{1F315}", waning_gibbous_moon: "\u{1F316}", last_quarter_moon: "\u{1F317}", waning_crescent_moon: "\u{1F318}", crescent_moon: "\u{1F319}", new_moon_with_face: "\u{1F31A}", first_quarter_moon_with_face: "\u{1F31B}", last_quarter_moon_with_face: "\u{1F31C}", full_moon_with_face: "\u{1F31D}", sun_with_face: "\u{1F31E}", star2: "\u{1F31F}", stars: "\u{1F320}", thermometer: "\u{1F321}\uFE0F", mostly_sunny: "\u{1F324}\uFE0F", sun_small_cloud: "\u{1F324}\uFE0F", barely_sunny: "\u{1F325}\uFE0F", sun_behind_cloud: "\u{1F325}\uFE0F", partly_sunny_rain: "\u{1F326}\uFE0F", sun_behind_rain_cloud: "\u{1F326}\uFE0F", rain_cloud: "\u{1F327}\uFE0F", snow_cloud: "\u{1F328}\uFE0F", lightning: "\u{1F329}\uFE0F", lightning_cloud: "\u{1F329}\uFE0F", tornado: "\u{1F32A}\uFE0F", tornado_cloud: "\u{1F32A}\uFE0F", fog: "\u{1F32B}\uFE0F", wind_blowing_face: "\u{1F32C}\uFE0F", hotdog: "\u{1F32D}", taco: "\u{1F32E}", burrito: "\u{1F32F}", chestnut: "\u{1F330}", seedling: "\u{1F331}", evergreen_tree: "\u{1F332}", deciduous_tree: "\u{1F333}", palm_tree: "\u{1F334}", cactus: "\u{1F335}", hot_pepper: "\u{1F336}\uFE0F", tulip: "\u{1F337}", cherry_blossom: "\u{1F338}", rose: "\u{1F339}", hibiscus: "\u{1F33A}", sunflower: "\u{1F33B}", blossom: "\u{1F33C}", corn: "\u{1F33D}", ear_of_rice: "\u{1F33E}", herb: "\u{1F33F}", four_leaf_clover: "\u{1F340}", maple_leaf: "\u{1F341}", fallen_leaf: "\u{1F342}", leaves: "\u{1F343}", mushroom: "\u{1F344}", tomato: "\u{1F345}", eggplant: "\u{1F346}", grapes: "\u{1F347}", melon: "\u{1F348}", watermelon: "\u{1F349}", tangerine: "\u{1F34A}", lemon: "\u{1F34B}", banana: "\u{1F34C}", pineapple: "\u{1F34D}", apple: "\u{1F34E}", green_apple: "\u{1F34F}", pear: "\u{1F350}", peach: "\u{1F351}", cherries: "\u{1F352}", strawberry: "\u{1F353}", hamburger: "\u{1F354}", pizza: "\u{1F355}", meat_on_bone: "\u{1F356}", poultry_leg: "\u{1F357}", rice_cracker: "\u{1F358}", rice_ball: "\u{1F359}", rice: "\u{1F35A}", curry: "\u{1F35B}", ramen: "\u{1F35C}", spaghetti: "\u{1F35D}", bread: "\u{1F35E}", fries: "\u{1F35F}", sweet_potato: "\u{1F360}", dango: "\u{1F361}", oden: "\u{1F362}", sushi: "\u{1F363}", fried_shrimp: "\u{1F364}", fish_cake: "\u{1F365}", icecream: "\u{1F366}", shaved_ice: "\u{1F367}", ice_cream: "\u{1F368}", doughnut: "\u{1F369}", cookie: "\u{1F36A}", chocolate_bar: "\u{1F36B}", candy: "\u{1F36C}", lollipop: "\u{1F36D}", custard: "\u{1F36E}", honey_pot: "\u{1F36F}", cake: "\u{1F370}", bento: "\u{1F371}", stew: "\u{1F372}", fried_egg: "\u{1F373}", cooking: "\u{1F373}", fork_and_knife: "\u{1F374}", tea: "\u{1F375}", sake: "\u{1F376}", wine_glass: "\u{1F377}", cocktail: "\u{1F378}", tropical_drink: "\u{1F379}", beer: "\u{1F37A}", beers: "\u{1F37B}", baby_bottle: "\u{1F37C}", knife_fork_plate: "\u{1F37D}\uFE0F", champagne: "\u{1F37E}", popcorn: "\u{1F37F}", ribbon: "\u{1F380}", gift: "\u{1F381}", birthday: "\u{1F382}", jack_o_lantern: "\u{1F383}", christmas_tree: "\u{1F384}", santa: "\u{1F385}", fireworks: "\u{1F386}", sparkler: "\u{1F387}", balloon: "\u{1F388}", tada: "\u{1F389}", confetti_ball: "\u{1F38A}", tanabata_tree: "\u{1F38B}", crossed_flags: "\u{1F38C}", bamboo: "\u{1F38D}", dolls: "\u{1F38E}", flags: "\u{1F38F}", wind_chime: "\u{1F390}", rice_scene: "\u{1F391}", school_satchel: "\u{1F392}", mortar_board: "\u{1F393}", medal: "\u{1F396}\uFE0F", reminder_ribbon: "\u{1F397}\uFE0F", studio_microphone: "\u{1F399}\uFE0F", level_slider: "\u{1F39A}\uFE0F", control_knobs: "\u{1F39B}\uFE0F", film_frames: "\u{1F39E}\uFE0F", admission_tickets: "\u{1F39F}\uFE0F", carousel_horse: "\u{1F3A0}", ferris_wheel: "\u{1F3A1}", roller_coaster: "\u{1F3A2}", fishing_pole_and_fish: "\u{1F3A3}", microphone: "\u{1F3A4}", movie_camera: "\u{1F3A5}", cinema: "\u{1F3A6}", headphones: "\u{1F3A7}", art: "\u{1F3A8}", tophat: "\u{1F3A9}", circus_tent: "\u{1F3AA}", ticket: "\u{1F3AB}", clapper: "\u{1F3AC}", performing_arts: "\u{1F3AD}", video_game: "\u{1F3AE}", dart: "\u{1F3AF}", slot_machine: "\u{1F3B0}", "8ball": "\u{1F3B1}", game_die: "\u{1F3B2}", bowling: "\u{1F3B3}", flower_playing_cards: "\u{1F3B4}", musical_note: "\u{1F3B5}", notes: "\u{1F3B6}", saxophone: "\u{1F3B7}", guitar: "\u{1F3B8}", musical_keyboard: "\u{1F3B9}", trumpet: "\u{1F3BA}", violin: "\u{1F3BB}", musical_score: "\u{1F3BC}", running_shirt_with_sash: "\u{1F3BD}", tennis: "\u{1F3BE}", ski: "\u{1F3BF}", basketball: "\u{1F3C0}", checkered_flag: "\u{1F3C1}", snowboarder: "\u{1F3C2}", "woman-running": "\u{1F3C3}\u200D\u2640\uFE0F", "man-running": "\u{1F3C3}\u200D\u2642\uFE0F", runner: "\u{1F3C3}\u200D\u2642\uFE0F", running: "\u{1F3C3}\u200D\u2642\uFE0F", "woman-surfing": "\u{1F3C4}\u200D\u2640\uFE0F", "man-surfing": "\u{1F3C4}\u200D\u2642\uFE0F", surfer: "\u{1F3C4}\u200D\u2642\uFE0F", sports_medal: "\u{1F3C5}", trophy: "\u{1F3C6}", horse_racing: "\u{1F3C7}", football: "\u{1F3C8}", rugby_football: "\u{1F3C9}", "woman-swimming": "\u{1F3CA}\u200D\u2640\uFE0F", "man-swimming": "\u{1F3CA}\u200D\u2642\uFE0F", swimmer: "\u{1F3CA}\u200D\u2642\uFE0F", "woman-lifting-weights": "\u{1F3CB}\uFE0F\u200D\u2640\uFE0F", "man-lifting-weights": "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F", weight_lifter: "\u{1F3CB}\uFE0F\u200D\u2642\uFE0F", "woman-golfing": "\u{1F3CC}\uFE0F\u200D\u2640\uFE0F", "man-golfing": "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F", golfer: "\u{1F3CC}\uFE0F\u200D\u2642\uFE0F", racing_motorcycle: "\u{1F3CD}\uFE0F", racing_car: "\u{1F3CE}\uFE0F", cricket_bat_and_ball: "\u{1F3CF}", volleyball: "\u{1F3D0}", field_hockey_stick_and_ball: "\u{1F3D1}", ice_hockey_stick_and_puck: "\u{1F3D2}", table_tennis_paddle_and_ball: "\u{1F3D3}", snow_capped_mountain: "\u{1F3D4}\uFE0F", camping: "\u{1F3D5}\uFE0F", beach_with_umbrella: "\u{1F3D6}\uFE0F", building_construction: "\u{1F3D7}\uFE0F", house_buildings: "\u{1F3D8}\uFE0F", cityscape: "\u{1F3D9}\uFE0F", derelict_house_building: "\u{1F3DA}\uFE0F", classical_building: "\u{1F3DB}\uFE0F", desert: "\u{1F3DC}\uFE0F", desert_island: "\u{1F3DD}\uFE0F", national_park: "\u{1F3DE}\uFE0F", stadium: "\u{1F3DF}\uFE0F", house: "\u{1F3E0}", house_with_garden: "\u{1F3E1}", office: "\u{1F3E2}", post_office: "\u{1F3E3}", european_post_office: "\u{1F3E4}", hospital: "\u{1F3E5}", bank: "\u{1F3E6}", atm: "\u{1F3E7}", hotel: "\u{1F3E8}", love_hotel: "\u{1F3E9}", convenience_store: "\u{1F3EA}", school: "\u{1F3EB}", department_store: "\u{1F3EC}", factory: "\u{1F3ED}", izakaya_lantern: "\u{1F3EE}", lantern: "\u{1F3EE}", japanese_castle: "\u{1F3EF}", european_castle: "\u{1F3F0}", "rainbow-flag": "\u{1F3F3}\uFE0F\u200D\u{1F308}", transgender_flag: "\u{1F3F3}\uFE0F\u200D\u26A7\uFE0F", waving_white_flag: "\u{1F3F3}\uFE0F", pirate_flag: "\u{1F3F4}\u200D\u2620\uFE0F", "flag-england": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0065}\u{E006E}\u{E0067}\u{E007F}", "flag-scotland": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0073}\u{E0063}\u{E0074}\u{E007F}", "flag-wales": "\u{1F3F4}\u{E0067}\u{E0062}\u{E0077}\u{E006C}\u{E0073}\u{E007F}", waving_black_flag: "\u{1F3F4}", rosette: "\u{1F3F5}\uFE0F", label: "\u{1F3F7}\uFE0F", badminton_racquet_and_shuttlecock: "\u{1F3F8}", bow_and_arrow: "\u{1F3F9}", amphora: "\u{1F3FA}", "skin-tone-2": "\u{1F3FB}", "skin-tone-3": "\u{1F3FC}", "skin-tone-4": "\u{1F3FD}", "skin-tone-5": "\u{1F3FE}", "skin-tone-6": "\u{1F3FF}", rat: "\u{1F400}", mouse2: "\u{1F401}", ox: "\u{1F402}", water_buffalo: "\u{1F403}", cow2: "\u{1F404}", tiger2: "\u{1F405}", leopard: "\u{1F406}", rabbit2: "\u{1F407}", black_cat: "\u{1F408}\u200D\u2B1B", cat2: "\u{1F408}", dragon: "\u{1F409}", crocodile: "\u{1F40A}", whale2: "\u{1F40B}", snail: "\u{1F40C}", snake: "\u{1F40D}", racehorse: "\u{1F40E}", ram: "\u{1F40F}", goat: "\u{1F410}", sheep: "\u{1F411}", monkey: "\u{1F412}", rooster: "\u{1F413}", chicken: "\u{1F414}", service_dog: "\u{1F415}\u200D\u{1F9BA}", dog2: "\u{1F415}", pig2: "\u{1F416}", boar: "\u{1F417}", elephant: "\u{1F418}", octopus: "\u{1F419}", shell: "\u{1F41A}", bug: "\u{1F41B}", ant: "\u{1F41C}", bee: "\u{1F41D}", honeybee: "\u{1F41D}", ladybug: "\u{1F41E}", lady_beetle: "\u{1F41E}", fish: "\u{1F41F}", tropical_fish: "\u{1F420}", blowfish: "\u{1F421}", turtle: "\u{1F422}", hatching_chick: "\u{1F423}", baby_chick: "\u{1F424}", hatched_chick: "\u{1F425}", bird: "\u{1F426}", penguin: "\u{1F427}", koala: "\u{1F428}", poodle: "\u{1F429}", dromedary_camel: "\u{1F42A}", camel: "\u{1F42B}", dolphin: "\u{1F42C}", flipper: "\u{1F42C}", mouse: "\u{1F42D}", cow: "\u{1F42E}", tiger: "\u{1F42F}", rabbit: "\u{1F430}", cat: "\u{1F431}", dragon_face: "\u{1F432}", whale: "\u{1F433}", horse: "\u{1F434}", monkey_face: "\u{1F435}", dog: "\u{1F436}", pig: "\u{1F437}", frog: "\u{1F438}", hamster: "\u{1F439}", wolf: "\u{1F43A}", polar_bear: "\u{1F43B}\u200D\u2744\uFE0F", bear: "\u{1F43B}", panda_face: "\u{1F43C}", pig_nose: "\u{1F43D}", feet: "\u{1F43E}", paw_prints: "\u{1F43E}", chipmunk: "\u{1F43F}\uFE0F", eyes: "\u{1F440}", "eye-in-speech-bubble": "\u{1F441}\uFE0F\u200D\u{1F5E8}\uFE0F", eye: "\u{1F441}\uFE0F", ear: "\u{1F442}", nose: "\u{1F443}", lips: "\u{1F444}", tongue: "\u{1F445}", point_up_2: "\u{1F446}", point_down: "\u{1F447}", point_left: "\u{1F448}", point_right: "\u{1F449}", facepunch: "\u{1F44A}", punch: "\u{1F44A}", wave: "\u{1F44B}", ok_hand: "\u{1F44C}", "+1": "\u{1F44D}", thumbsup: "\u{1F44D}", "-1": "\u{1F44E}", thumbsdown: "\u{1F44E}", clap: "\u{1F44F}", open_hands: "\u{1F450}", crown: "\u{1F451}", womans_hat: "\u{1F452}", eyeglasses: "\u{1F453}", necktie: "\u{1F454}", shirt: "\u{1F455}", tshirt: "\u{1F455}", jeans: "\u{1F456}", dress: "\u{1F457}", kimono: "\u{1F458}", bikini: "\u{1F459}", womans_clothes: "\u{1F45A}", purse: "\u{1F45B}", handbag: "\u{1F45C}", pouch: "\u{1F45D}", mans_shoe: "\u{1F45E}", shoe: "\u{1F45E}", athletic_shoe: "\u{1F45F}", high_heel: "\u{1F460}", sandal: "\u{1F461}", boot: "\u{1F462}", footprints: "\u{1F463}", bust_in_silhouette: "\u{1F464}", busts_in_silhouette: "\u{1F465}", boy: "\u{1F466}", girl: "\u{1F467}", "male-farmer": "\u{1F468}\u200D\u{1F33E}", "male-cook": "\u{1F468}\u200D\u{1F373}", man_feeding_baby: "\u{1F468}\u200D\u{1F37C}", "male-student": "\u{1F468}\u200D\u{1F393}", "male-singer": "\u{1F468}\u200D\u{1F3A4}", "male-artist": "\u{1F468}\u200D\u{1F3A8}", "male-teacher": "\u{1F468}\u200D\u{1F3EB}", "male-factory-worker": "\u{1F468}\u200D\u{1F3ED}", "man-boy-boy": "\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", "man-boy": "\u{1F468}\u200D\u{1F466}", "man-girl-boy": "\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", "man-girl-girl": "\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", "man-girl": "\u{1F468}\u200D\u{1F467}", "man-man-boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}", "man-man-boy-boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F466}\u200D\u{1F466}", "man-man-girl": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}", "man-man-girl-boy": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F466}", "man-man-girl-girl": "\u{1F468}\u200D\u{1F468}\u200D\u{1F467}\u200D\u{1F467}", "man-woman-boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}", family: "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}", "man-woman-boy-boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", "man-woman-girl": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}", "man-woman-girl-boy": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", "man-woman-girl-girl": "\u{1F468}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", "male-technologist": "\u{1F468}\u200D\u{1F4BB}", "male-office-worker": "\u{1F468}\u200D\u{1F4BC}", "male-mechanic": "\u{1F468}\u200D\u{1F527}", "male-scientist": "\u{1F468}\u200D\u{1F52C}", "male-astronaut": "\u{1F468}\u200D\u{1F680}", "male-firefighter": "\u{1F468}\u200D\u{1F692}", man_with_probing_cane: "\u{1F468}\u200D\u{1F9AF}", red_haired_man: "\u{1F468}\u200D\u{1F9B0}", curly_haired_man: "\u{1F468}\u200D\u{1F9B1}", bald_man: "\u{1F468}\u200D\u{1F9B2}", white_haired_man: "\u{1F468}\u200D\u{1F9B3}", man_in_motorized_wheelchair: "\u{1F468}\u200D\u{1F9BC}", man_in_manual_wheelchair: "\u{1F468}\u200D\u{1F9BD}", "male-doctor": "\u{1F468}\u200D\u2695\uFE0F", "male-judge": "\u{1F468}\u200D\u2696\uFE0F", "male-pilot": "\u{1F468}\u200D\u2708\uFE0F", "man-heart-man": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F468}", "man-kiss-man": "\u{1F468}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", man: "\u{1F468}", "female-farmer": "\u{1F469}\u200D\u{1F33E}", "female-cook": "\u{1F469}\u200D\u{1F373}", woman_feeding_baby: "\u{1F469}\u200D\u{1F37C}", "female-student": "\u{1F469}\u200D\u{1F393}", "female-singer": "\u{1F469}\u200D\u{1F3A4}", "female-artist": "\u{1F469}\u200D\u{1F3A8}", "female-teacher": "\u{1F469}\u200D\u{1F3EB}", "female-factory-worker": "\u{1F469}\u200D\u{1F3ED}", "woman-boy-boy": "\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", "woman-boy": "\u{1F469}\u200D\u{1F466}", "woman-girl-boy": "\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", "woman-girl-girl": "\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", "woman-girl": "\u{1F469}\u200D\u{1F467}", "woman-woman-boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}", "woman-woman-boy-boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F466}\u200D\u{1F466}", "woman-woman-girl": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}", "woman-woman-girl-boy": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F466}", "woman-woman-girl-girl": "\u{1F469}\u200D\u{1F469}\u200D\u{1F467}\u200D\u{1F467}", "female-technologist": "\u{1F469}\u200D\u{1F4BB}", "female-office-worker": "\u{1F469}\u200D\u{1F4BC}", "female-mechanic": "\u{1F469}\u200D\u{1F527}", "female-scientist": "\u{1F469}\u200D\u{1F52C}", "female-astronaut": "\u{1F469}\u200D\u{1F680}", "female-firefighter": "\u{1F469}\u200D\u{1F692}", woman_with_probing_cane: "\u{1F469}\u200D\u{1F9AF}", red_haired_woman: "\u{1F469}\u200D\u{1F9B0}", curly_haired_woman: "\u{1F469}\u200D\u{1F9B1}", bald_woman: "\u{1F469}\u200D\u{1F9B2}", white_haired_woman: "\u{1F469}\u200D\u{1F9B3}", woman_in_motorized_wheelchair: "\u{1F469}\u200D\u{1F9BC}", woman_in_manual_wheelchair: "\u{1F469}\u200D\u{1F9BD}", "female-doctor": "\u{1F469}\u200D\u2695\uFE0F", "female-judge": "\u{1F469}\u200D\u2696\uFE0F", "female-pilot": "\u{1F469}\u200D\u2708\uFE0F", "woman-heart-man": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F468}", "woman-heart-woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F469}", "woman-kiss-man": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F468}", "woman-kiss-woman": "\u{1F469}\u200D\u2764\uFE0F\u200D\u{1F48B}\u200D\u{1F469}", woman: "\u{1F469}", man_and_woman_holding_hands: "\u{1F46B}", woman_and_man_holding_hands: "\u{1F46B}", couple: "\u{1F46B}", two_men_holding_hands: "\u{1F46C}", men_holding_hands: "\u{1F46C}", two_women_holding_hands: "\u{1F46D}", women_holding_hands: "\u{1F46D}", "female-police-officer": "\u{1F46E}\u200D\u2640\uFE0F", "male-police-officer": "\u{1F46E}\u200D\u2642\uFE0F", cop: "\u{1F46E}\u200D\u2642\uFE0F", "women-with-bunny-ears-partying": "\u{1F46F}\u200D\u2640\uFE0F", "woman-with-bunny-ears-partying": "\u{1F46F}\u200D\u2640\uFE0F", dancers: "\u{1F46F}\u200D\u2640\uFE0F", "men-with-bunny-ears-partying": "\u{1F46F}\u200D\u2642\uFE0F", "man-with-bunny-ears-partying": "\u{1F46F}\u200D\u2642\uFE0F", woman_with_veil: "\u{1F470}\u200D\u2640\uFE0F", man_with_veil: "\u{1F470}\u200D\u2642\uFE0F", bride_with_veil: "\u{1F470}", "blond-haired-woman": "\u{1F471}\u200D\u2640\uFE0F", "blond-haired-man": "\u{1F471}\u200D\u2642\uFE0F", person_with_blond_hair: "\u{1F471}\u200D\u2642\uFE0F", man_with_gua_pi_mao: "\u{1F472}", "woman-wearing-turban": "\u{1F473}\u200D\u2640\uFE0F", "man-wearing-turban": "\u{1F473}\u200D\u2642\uFE0F", man_with_turban: "\u{1F473}\u200D\u2642\uFE0F", older_man: "\u{1F474}", older_woman: "\u{1F475}", baby: "\u{1F476}", "female-construction-worker": "\u{1F477}\u200D\u2640\uFE0F", "male-construction-worker": "\u{1F477}\u200D\u2642\uFE0F", construction_worker: "\u{1F477}\u200D\u2642\uFE0F", princess: "\u{1F478}", japanese_ogre: "\u{1F479}", japanese_goblin: "\u{1F47A}", ghost: "\u{1F47B}", angel: "\u{1F47C}", alien: "\u{1F47D}", space_invader: "\u{1F47E}", imp: "\u{1F47F}", skull: "\u{1F480}", "woman-tipping-hand": "\u{1F481}\u200D\u2640\uFE0F", information_desk_person: "\u{1F481}\u200D\u2640\uFE0F", "man-tipping-hand": "\u{1F481}\u200D\u2642\uFE0F", "female-guard": "\u{1F482}\u200D\u2640\uFE0F", "male-guard": "\u{1F482}\u200D\u2642\uFE0F", guardsman: "\u{1F482}\u200D\u2642\uFE0F", dancer: "\u{1F483}", lipstick: "\u{1F484}", nail_care: "\u{1F485}", "woman-getting-massage": "\u{1F486}\u200D\u2640\uFE0F", massage: "\u{1F486}\u200D\u2640\uFE0F", "man-getting-massage": "\u{1F486}\u200D\u2642\uFE0F", "woman-getting-haircut": "\u{1F487}\u200D\u2640\uFE0F", haircut: "\u{1F487}\u200D\u2640\uFE0F", "man-getting-haircut": "\u{1F487}\u200D\u2642\uFE0F", barber: "\u{1F488}", syringe: "\u{1F489}", pill: "\u{1F48A}", kiss: "\u{1F48B}", love_letter: "\u{1F48C}", ring: "\u{1F48D}", gem: "\u{1F48E}", couplekiss: "\u{1F48F}", bouquet: "\u{1F490}", couple_with_heart: "\u{1F491}", wedding: "\u{1F492}", heartbeat: "\u{1F493}", broken_heart: "\u{1F494}", two_hearts: "\u{1F495}", sparkling_heart: "\u{1F496}", heartpulse: "\u{1F497}", cupid: "\u{1F498}", blue_heart: "\u{1F499}", green_heart: "\u{1F49A}", yellow_heart: "\u{1F49B}", purple_heart: "\u{1F49C}", gift_heart: "\u{1F49D}", revolving_hearts: "\u{1F49E}", heart_decoration: "\u{1F49F}", diamond_shape_with_a_dot_inside: "\u{1F4A0}", bulb: "\u{1F4A1}", anger: "\u{1F4A2}", bomb: "\u{1F4A3}", zzz: "\u{1F4A4}", boom: "\u{1F4A5}", collision: "\u{1F4A5}", sweat_drops: "\u{1F4A6}", droplet: "\u{1F4A7}", dash: "\u{1F4A8}", hankey: "\u{1F4A9}", poop: "\u{1F4A9}", shit: "\u{1F4A9}", muscle: "\u{1F4AA}", dizzy: "\u{1F4AB}", speech_balloon: "\u{1F4AC}", thought_balloon: "\u{1F4AD}", white_flower: "\u{1F4AE}", moneybag: "\u{1F4B0}", currency_exchange: "\u{1F4B1}", heavy_dollar_sign: "\u{1F4B2}", credit_card: "\u{1F4B3}", yen: "\u{1F4B4}", dollar: "\u{1F4B5}", euro: "\u{1F4B6}", pound: "\u{1F4B7}", money_with_wings: "\u{1F4B8}", chart: "\u{1F4B9}", seat: "\u{1F4BA}", computer: "\u{1F4BB}", briefcase: "\u{1F4BC}", minidisc: "\u{1F4BD}", floppy_disk: "\u{1F4BE}", cd: "\u{1F4BF}", dvd: "\u{1F4C0}", file_folder: "\u{1F4C1}", open_file_folder: "\u{1F4C2}", page_with_curl: "\u{1F4C3}", page_facing_up: "\u{1F4C4}", date: "\u{1F4C5}", calendar: "\u{1F4C6}", card_index: "\u{1F4C7}", chart_with_upwards_trend: "\u{1F4C8}", chart_with_downwards_trend: "\u{1F4C9}", bar_chart: "\u{1F4CA}", clipboard: "\u{1F4CB}", pushpin: "\u{1F4CC}", round_pushpin: "\u{1F4CD}", paperclip: "\u{1F4CE}", straight_ruler: "\u{1F4CF}", triangular_ruler: "\u{1F4D0}", bookmark_tabs: "\u{1F4D1}", ledger: "\u{1F4D2}", notebook: "\u{1F4D3}", notebook_with_decorative_cover: "\u{1F4D4}", closed_book: "\u{1F4D5}", book: "\u{1F4D6}", open_book: "\u{1F4D6}", green_book: "\u{1F4D7}", blue_book: "\u{1F4D8}", orange_book: "\u{1F4D9}", books: "\u{1F4DA}", name_badge: "\u{1F4DB}", scroll: "\u{1F4DC}", memo: "\u{1F4DD}", pencil: "\u{1F4DD}", telephone_receiver: "\u{1F4DE}", pager: "\u{1F4DF}", fax: "\u{1F4E0}", satellite_antenna: "\u{1F4E1}", loudspeaker: "\u{1F4E2}", mega: "\u{1F4E3}", outbox_tray: "\u{1F4E4}", inbox_tray: "\u{1F4E5}", package: "\u{1F4E6}", "e-mail": "\u{1F4E7}", incoming_envelope: "\u{1F4E8}", envelope_with_arrow: "\u{1F4E9}", mailbox_closed: "\u{1F4EA}", mailbox: "\u{1F4EB}", mailbox_with_mail: "\u{1F4EC}", mailbox_with_no_mail: "\u{1F4ED}", postbox: "\u{1F4EE}", postal_horn: "\u{1F4EF}", newspaper: "\u{1F4F0}", iphone: "\u{1F4F1}", calling: "\u{1F4F2}", vibration_mode: "\u{1F4F3}", mobile_phone_off: "\u{1F4F4}", no_mobile_phones: "\u{1F4F5}", signal_strength: "\u{1F4F6}", camera: "\u{1F4F7}", camera_with_flash: "\u{1F4F8}", video_camera: "\u{1F4F9}", tv: "\u{1F4FA}", radio: "\u{1F4FB}", vhs: "\u{1F4FC}", film_projector: "\u{1F4FD}\uFE0F", prayer_beads: "\u{1F4FF}", twisted_rightwards_arrows: "\u{1F500}", repeat: "\u{1F501}", repeat_one: "\u{1F502}", arrows_clockwise: "\u{1F503}", arrows_counterclockwise: "\u{1F504}", low_brightness: "\u{1F505}", high_brightness: "\u{1F506}", mute: "\u{1F507}", speaker: "\u{1F508}", sound: "\u{1F509}", loud_sound: "\u{1F50A}", battery: "\u{1F50B}", electric_plug: "\u{1F50C}", mag: "\u{1F50D}", mag_right: "\u{1F50E}", lock_with_ink_pen: "\u{1F50F}", closed_lock_with_key: "\u{1F510}", key: "\u{1F511}", lock: "\u{1F512}", unlock: "\u{1F513}", bell: "\u{1F514}", no_bell: "\u{1F515}", bookmark: "\u{1F516}", link: "\u{1F517}", radio_button: "\u{1F518}", back: "\u{1F519}", end: "\u{1F51A}", on: "\u{1F51B}", soon: "\u{1F51C}", top: "\u{1F51D}", underage: "\u{1F51E}", keycap_ten: "\u{1F51F}", capital_abcd: "\u{1F520}", abcd: "\u{1F521}", symbols: "\u{1F523}", abc: "\u{1F524}", fire: "\u{1F525}", flashlight: "\u{1F526}", wrench: "\u{1F527}", hammer: "\u{1F528}", nut_and_bolt: "\u{1F529}", hocho: "\u{1F52A}", knife: "\u{1F52A}", gun: "\u{1F52B}", microscope: "\u{1F52C}", telescope: "\u{1F52D}", crystal_ball: "\u{1F52E}", six_pointed_star: "\u{1F52F}", beginner: "\u{1F530}", trident: "\u{1F531}", black_square_button: "\u{1F532}", white_square_button: "\u{1F533}", red_circle: "\u{1F534}", large_blue_circle: "\u{1F535}", large_orange_diamond: "\u{1F536}", large_blue_diamond: "\u{1F537}", small_orange_diamond: "\u{1F538}", small_blue_diamond: "\u{1F539}", small_red_triangle: "\u{1F53A}", small_red_triangle_down: "\u{1F53B}", arrow_up_small: "\u{1F53C}", arrow_down_small: "\u{1F53D}", om_symbol: "\u{1F549}\uFE0F", dove_of_peace: "\u{1F54A}\uFE0F", kaaba: "\u{1F54B}", mosque: "\u{1F54C}", synagogue: "\u{1F54D}", menorah_with_nine_branches: "\u{1F54E}", clock1: "\u{1F550}", clock2: "\u{1F551}", clock3: "\u{1F552}", clock4: "\u{1F553}", clock5: "\u{1F554}", clock6: "\u{1F555}", clock7: "\u{1F556}", clock8: "\u{1F557}", clock9: "\u{1F558}", clock10: "\u{1F559}", clock11: "\u{1F55A}", clock12: "\u{1F55B}", clock130: "\u{1F55C}", clock230: "\u{1F55D}", clock330: "\u{1F55E}", clock430: "\u{1F55F}", clock530: "\u{1F560}", clock630: "\u{1F561}", clock730: "\u{1F562}", clock830: "\u{1F563}", clock930: "\u{1F564}", clock1030: "\u{1F565}", clock1130: "\u{1F566}", clock1230: "\u{1F567}", candle: "\u{1F56F}\uFE0F", mantelpiece_clock: "\u{1F570}\uFE0F", hole: "\u{1F573}\uFE0F", man_in_business_suit_levitating: "\u{1F574}\uFE0F", "female-detective": "\u{1F575}\uFE0F\u200D\u2640\uFE0F", "male-detective": "\u{1F575}\uFE0F\u200D\u2642\uFE0F", sleuth_or_spy: "\u{1F575}\uFE0F\u200D\u2642\uFE0F", dark_sunglasses: "\u{1F576}\uFE0F", spider: "\u{1F577}\uFE0F", spider_web: "\u{1F578}\uFE0F", joystick: "\u{1F579}\uFE0F", man_dancing: "\u{1F57A}", linked_paperclips: "\u{1F587}\uFE0F", lower_left_ballpoint_pen: "\u{1F58A}\uFE0F", lower_left_fountain_pen: "\u{1F58B}\uFE0F", lower_left_paintbrush: "\u{1F58C}\uFE0F", lower_left_crayon: "\u{1F58D}\uFE0F", raised_hand_with_fingers_splayed: "\u{1F590}\uFE0F", middle_finger: "\u{1F595}", reversed_hand_with_middle_finger_extended: "\u{1F595}", "spock-hand": "\u{1F596}", black_heart: "\u{1F5A4}", desktop_computer: "\u{1F5A5}\uFE0F", printer: "\u{1F5A8}\uFE0F", three_button_mouse: "\u{1F5B1}\uFE0F", trackball: "\u{1F5B2}\uFE0F", frame_with_picture: "\u{1F5BC}\uFE0F", card_index_dividers: "\u{1F5C2}\uFE0F", card_file_box: "\u{1F5C3}\uFE0F", file_cabinet: "\u{1F5C4}\uFE0F", wastebasket: "\u{1F5D1}\uFE0F", spiral_note_pad: "\u{1F5D2}\uFE0F", spiral_calendar_pad: "\u{1F5D3}\uFE0F", compression: "\u{1F5DC}\uFE0F", old_key: "\u{1F5DD}\uFE0F", rolled_up_newspaper: "\u{1F5DE}\uFE0F", dagger_knife: "\u{1F5E1}\uFE0F", speaking_head_in_silhouette: "\u{1F5E3}\uFE0F", left_speech_bubble: "\u{1F5E8}\uFE0F", right_anger_bubble: "\u{1F5EF}\uFE0F", ballot_box_with_ballot: "\u{1F5F3}\uFE0F", world_map: "\u{1F5FA}\uFE0F", mount_fuji: "\u{1F5FB}", tokyo_tower: "\u{1F5FC}", statue_of_liberty: "\u{1F5FD}", japan: "\u{1F5FE}", moyai: "\u{1F5FF}", grinning: "\u{1F600}", grin: "\u{1F601}", joy: "\u{1F602}", smiley: "\u{1F603}", smile: "\u{1F604}", sweat_smile: "\u{1F605}", laughing: "\u{1F606}", satisfied: "\u{1F606}", innocent: "\u{1F607}", smiling_imp: "\u{1F608}", wink: "\u{1F609}", blush: "\u{1F60A}", yum: "\u{1F60B}", relieved: "\u{1F60C}", heart_eyes: "\u{1F60D}", sunglasses: "\u{1F60E}", smirk: "\u{1F60F}", neutral_face: "\u{1F610}", expressionless: "\u{1F611}", unamused: "\u{1F612}", sweat: "\u{1F613}", pensive: "\u{1F614}", confused: "\u{1F615}", confounded: "\u{1F616}", kissing: "\u{1F617}", kissing_heart: "\u{1F618}", kissing_smiling_eyes: "\u{1F619}", kissing_closed_eyes: "\u{1F61A}", stuck_out_tongue: "\u{1F61B}", stuck_out_tongue_winking_eye: "\u{1F61C}", stuck_out_tongue_closed_eyes: "\u{1F61D}", disappointed: "\u{1F61E}", worried: "\u{1F61F}", angry: "\u{1F620}", rage: "\u{1F621}", cry: "\u{1F622}", persevere: "\u{1F623}", triumph: "\u{1F624}", disappointed_relieved: "\u{1F625}", frowning: "\u{1F626}", anguished: "\u{1F627}", fearful: "\u{1F628}", weary: "\u{1F629}", sleepy: "\u{1F62A}", tired_face: "\u{1F62B}", grimacing: "\u{1F62C}", sob: "\u{1F62D}", face_exhaling: "\u{1F62E}\u200D\u{1F4A8}", open_mouth: "\u{1F62E}", hushed: "\u{1F62F}", cold_sweat: "\u{1F630}", scream: "\u{1F631}", astonished: "\u{1F632}", flushed: "\u{1F633}", sleeping: "\u{1F634}", face_with_spiral_eyes: "\u{1F635}\u200D\u{1F4AB}", dizzy_face: "\u{1F635}", face_in_clouds: "\u{1F636}\u200D\u{1F32B}\uFE0F", no_mouth: "\u{1F636}", mask: "\u{1F637}", smile_cat: "\u{1F638}", joy_cat: "\u{1F639}", smiley_cat: "\u{1F63A}", heart_eyes_cat: "\u{1F63B}", smirk_cat: "\u{1F63C}", kissing_cat: "\u{1F63D}", pouting_cat: "\u{1F63E}", crying_cat_face: "\u{1F63F}", scream_cat: "\u{1F640}", slightly_frowning_face: "\u{1F641}", slightly_smiling_face: "\u{1F642}", upside_down_face: "\u{1F643}", face_with_rolling_eyes: "\u{1F644}", "woman-gesturing-no": "\u{1F645}\u200D\u2640\uFE0F", no_good: "\u{1F645}\u200D\u2640\uFE0F", "man-gesturing-no": "\u{1F645}\u200D\u2642\uFE0F", "woman-gesturing-ok": "\u{1F646}\u200D\u2640\uFE0F", ok_woman: "\u{1F646}\u200D\u2640\uFE0F", "man-gesturing-ok": "\u{1F646}\u200D\u2642\uFE0F", "woman-bowing": "\u{1F647}\u200D\u2640\uFE0F", "man-bowing": "\u{1F647}\u200D\u2642\uFE0F", bow: "\u{1F647}\u200D\u2642\uFE0F", see_no_evil: "\u{1F648}", hear_no_evil: "\u{1F649}", speak_no_evil: "\u{1F64A}", "woman-raising-hand": "\u{1F64B}\u200D\u2640\uFE0F", raising_hand: "\u{1F64B}\u200D\u2640\uFE0F", "man-raising-hand": "\u{1F64B}\u200D\u2642\uFE0F", raised_hands: "\u{1F64C}", "woman-frowning": "\u{1F64D}\u200D\u2640\uFE0F", person_frowning: "\u{1F64D}\u200D\u2640\uFE0F", "man-frowning": "\u{1F64D}\u200D\u2642\uFE0F", "woman-pouting": "\u{1F64E}\u200D\u2640\uFE0F", person_with_pouting_face: "\u{1F64E}\u200D\u2640\uFE0F", "man-pouting": "\u{1F64E}\u200D\u2642\uFE0F", pray: "\u{1F64F}", rocket: "\u{1F680}", helicopter: "\u{1F681}", steam_locomotive: "\u{1F682}", railway_car: "\u{1F683}", bullettrain_side: "\u{1F684}", bullettrain_front: "\u{1F685}", train2: "\u{1F686}", metro: "\u{1F687}", light_rail: "\u{1F688}", station: "\u{1F689}", tram: "\u{1F68A}", train: "\u{1F68B}", bus: "\u{1F68C}", oncoming_bus: "\u{1F68D}", trolleybus: "\u{1F68E}", busstop: "\u{1F68F}", minibus: "\u{1F690}", ambulance: "\u{1F691}", fire_engine: "\u{1F692}", police_car: "\u{1F693}", oncoming_police_car: "\u{1F694}", taxi: "\u{1F695}", oncoming_taxi: "\u{1F696}", car: "\u{1F697}", red_car: "\u{1F697}", oncoming_automobile: "\u{1F698}", blue_car: "\u{1F699}", truck: "\u{1F69A}", articulated_lorry: "\u{1F69B}", tractor: "\u{1F69C}", monorail: "\u{1F69D}", mountain_railway: "\u{1F69E}", suspension_railway: "\u{1F69F}", mountain_cableway: "\u{1F6A0}", aerial_tramway: "\u{1F6A1}", ship: "\u{1F6A2}", "woman-rowing-boat": "\u{1F6A3}\u200D\u2640\uFE0F", "man-rowing-boat": "\u{1F6A3}\u200D\u2642\uFE0F", rowboat: "\u{1F6A3}\u200D\u2642\uFE0F", speedboat: "\u{1F6A4}", traffic_light: "\u{1F6A5}", vertical_traffic_light: "\u{1F6A6}", construction: "\u{1F6A7}", rotating_light: "\u{1F6A8}", triangular_flag_on_post: "\u{1F6A9}", door: "\u{1F6AA}", no_entry_sign: "\u{1F6AB}", smoking: "\u{1F6AC}", no_smoking: "\u{1F6AD}", put_litter_in_its_place: "\u{1F6AE}", do_not_litter: "\u{1F6AF}", potable_water: "\u{1F6B0}", "non-potable_water": "\u{1F6B1}", bike: "\u{1F6B2}", no_bicycles: "\u{1F6B3}", "woman-biking": "\u{1F6B4}\u200D\u2640\uFE0F", "man-biking": "\u{1F6B4}\u200D\u2642\uFE0F", bicyclist: "\u{1F6B4}\u200D\u2642\uFE0F", "woman-mountain-biking": "\u{1F6B5}\u200D\u2640\uFE0F", "man-mountain-biking": "\u{1F6B5}\u200D\u2642\uFE0F", mountain_bicyclist: "\u{1F6B5}\u200D\u2642\uFE0F", "woman-walking": "\u{1F6B6}\u200D\u2640\uFE0F", "man-walking": "\u{1F6B6}\u200D\u2642\uFE0F", walking: "\u{1F6B6}\u200D\u2642\uFE0F", no_pedestrians: "\u{1F6B7}", children_crossing: "\u{1F6B8}", mens: "\u{1F6B9}", womens: "\u{1F6BA}", restroom: "\u{1F6BB}", baby_symbol: "\u{1F6BC}", toilet: "\u{1F6BD}", wc: "\u{1F6BE}", shower: "\u{1F6BF}", bath: "\u{1F6C0}", bathtub: "\u{1F6C1}", passport_control: "\u{1F6C2}", customs: "\u{1F6C3}", baggage_claim: "\u{1F6C4}", left_luggage: "\u{1F6C5}", couch_and_lamp: "\u{1F6CB}\uFE0F", sleeping_accommodation: "\u{1F6CC}", shopping_bags: "\u{1F6CD}\uFE0F", bellhop_bell: "\u{1F6CE}\uFE0F", bed: "\u{1F6CF}\uFE0F", place_of_worship: "\u{1F6D0}", octagonal_sign: "\u{1F6D1}", shopping_trolley: "\u{1F6D2}", hindu_temple: "\u{1F6D5}", hut: "\u{1F6D6}", elevator: "\u{1F6D7}", hammer_and_wrench: "\u{1F6E0}\uFE0F", shield: "\u{1F6E1}\uFE0F", oil_drum: "\u{1F6E2}\uFE0F", motorway: "\u{1F6E3}\uFE0F", railway_track: "\u{1F6E4}\uFE0F", motor_boat: "\u{1F6E5}\uFE0F", small_airplane: "\u{1F6E9}\uFE0F", airplane_departure: "\u{1F6EB}", airplane_arriving: "\u{1F6EC}", satellite: "\u{1F6F0}\uFE0F", passenger_ship: "\u{1F6F3}\uFE0F", scooter: "\u{1F6F4}", motor_scooter: "\u{1F6F5}", canoe: "\u{1F6F6}", sled: "\u{1F6F7}", flying_saucer: "\u{1F6F8}", skateboard: "\u{1F6F9}", auto_rickshaw: "\u{1F6FA}", pickup_truck: "\u{1F6FB}", roller_skate: "\u{1F6FC}", large_orange_circle: "\u{1F7E0}", large_yellow_circle: "\u{1F7E1}", large_green_circle: "\u{1F7E2}", large_purple_circle: "\u{1F7E3}", large_brown_circle: "\u{1F7E4}", large_red_square: "\u{1F7E5}", large_blue_square: "\u{1F7E6}", large_orange_square: "\u{1F7E7}", large_yellow_square: "\u{1F7E8}", large_green_square: "\u{1F7E9}", large_purple_square: "\u{1F7EA}", large_brown_square: "\u{1F7EB}", pinched_fingers: "\u{1F90C}", white_heart: "\u{1F90D}", brown_heart: "\u{1F90E}", pinching_hand: "\u{1F90F}", zipper_mouth_face: "\u{1F910}", money_mouth_face: "\u{1F911}", face_with_thermometer: "\u{1F912}", nerd_face: "\u{1F913}", thinking_face: "\u{1F914}", face_with_head_bandage: "\u{1F915}", robot_face: "\u{1F916}", hugging_face: "\u{1F917}", the_horns: "\u{1F918}", sign_of_the_horns: "\u{1F918}", call_me_hand: "\u{1F919}", raised_back_of_hand: "\u{1F91A}", "left-facing_fist": "\u{1F91B}", "right-facing_fist": "\u{1F91C}", handshake: "\u{1F91D}", crossed_fingers: "\u{1F91E}", hand_with_index_and_middle_fingers_crossed: "\u{1F91E}", i_love_you_hand_sign: "\u{1F91F}", face_with_cowboy_hat: "\u{1F920}", clown_face: "\u{1F921}", nauseated_face: "\u{1F922}", rolling_on_the_floor_laughing: "\u{1F923}", drooling_face: "\u{1F924}", lying_face: "\u{1F925}", "woman-facepalming": "\u{1F926}\u200D\u2640\uFE0F", "man-facepalming": "\u{1F926}\u200D\u2642\uFE0F", face_palm: "\u{1F926}", sneezing_face: "\u{1F927}", face_with_raised_eyebrow: "\u{1F928}", face_with_one_eyebrow_raised: "\u{1F928}", "star-struck": "\u{1F929}", grinning_face_with_star_eyes: "\u{1F929}", zany_face: "\u{1F92A}", grinning_face_with_one_large_and_one_small_eye: "\u{1F92A}", shushing_face: "\u{1F92B}", face_with_finger_covering_closed_lips: "\u{1F92B}", face_with_symbols_on_mouth: "\u{1F92C}", serious_face_with_symbols_covering_mouth: "\u{1F92C}", face_with_hand_over_mouth: "\u{1F92D}", smiling_face_with_smiling_eyes_and_hand_covering_mouth: "\u{1F92D}", face_vomiting: "\u{1F92E}", face_with_open_mouth_vomiting: "\u{1F92E}", exploding_head: "\u{1F92F}", shocked_face_with_exploding_head: "\u{1F92F}", pregnant_woman: "\u{1F930}", "breast-feeding": "\u{1F931}", palms_up_together: "\u{1F932}", selfie: "\u{1F933}", prince: "\u{1F934}", woman_in_tuxedo: "\u{1F935}\u200D\u2640\uFE0F", man_in_tuxedo: "\u{1F935}\u200D\u2642\uFE0F", person_in_tuxedo: "\u{1F935}", mrs_claus: "\u{1F936}", mother_christmas: "\u{1F936}", "woman-shrugging": "\u{1F937}\u200D\u2640\uFE0F", "man-shrugging": "\u{1F937}\u200D\u2642\uFE0F", shrug: "\u{1F937}", "woman-cartwheeling": "\u{1F938}\u200D\u2640\uFE0F", "man-cartwheeling": "\u{1F938}\u200D\u2642\uFE0F", person_doing_cartwheel: "\u{1F938}", "woman-juggling": "\u{1F939}\u200D\u2640\uFE0F", "man-juggling": "\u{1F939}\u200D\u2642\uFE0F", juggling: "\u{1F939}", fencer: "\u{1F93A}", "woman-wrestling": "\u{1F93C}\u200D\u2640\uFE0F", "man-wrestling": "\u{1F93C}\u200D\u2642\uFE0F", wrestlers: "\u{1F93C}", "woman-playing-water-polo": "\u{1F93D}\u200D\u2640\uFE0F", "man-playing-water-polo": "\u{1F93D}\u200D\u2642\uFE0F", water_polo: "\u{1F93D}", "woman-playing-handball": "\u{1F93E}\u200D\u2640\uFE0F", "man-playing-handball": "\u{1F93E}\u200D\u2642\uFE0F", handball: "\u{1F93E}", diving_mask: "\u{1F93F}", wilted_flower: "\u{1F940}", drum_with_drumsticks: "\u{1F941}", clinking_glasses: "\u{1F942}", tumbler_glass: "\u{1F943}", spoon: "\u{1F944}", goal_net: "\u{1F945}", first_place_medal: "\u{1F947}", second_place_medal: "\u{1F948}", third_place_medal: "\u{1F949}", boxing_glove: "\u{1F94A}", martial_arts_uniform: "\u{1F94B}", curling_stone: "\u{1F94C}", lacrosse: "\u{1F94D}", softball: "\u{1F94E}", flying_disc: "\u{1F94F}", croissant: "\u{1F950}", avocado: "\u{1F951}", cucumber: "\u{1F952}", bacon: "\u{1F953}", potato: "\u{1F954}", carrot: "\u{1F955}", baguette_bread: "\u{1F956}", green_salad: "\u{1F957}", shallow_pan_of_food: "\u{1F958}", stuffed_flatbread: "\u{1F959}", egg: "\u{1F95A}", glass_of_milk: "\u{1F95B}", peanuts: "\u{1F95C}", kiwifruit: "\u{1F95D}", pancakes: "\u{1F95E}", dumpling: "\u{1F95F}", fortune_cookie: "\u{1F960}", takeout_box: "\u{1F961}", chopsticks: "\u{1F962}", bowl_with_spoon: "\u{1F963}", cup_with_straw: "\u{1F964}", coconut: "\u{1F965}", broccoli: "\u{1F966}", pie: "\u{1F967}", pretzel: "\u{1F968}", cut_of_meat: "\u{1F969}", sandwich: "\u{1F96A}", canned_food: "\u{1F96B}", leafy_green: "\u{1F96C}", mango: "\u{1F96D}", moon_cake: "\u{1F96E}", bagel: "\u{1F96F}", smiling_face_with_3_hearts: "\u{1F970}", yawning_face: "\u{1F971}", smiling_face_with_tear: "\u{1F972}", partying_face: "\u{1F973}", woozy_face: "\u{1F974}", hot_face: "\u{1F975}", cold_face: "\u{1F976}", ninja: "\u{1F977}", disguised_face: "\u{1F978}", pleading_face: "\u{1F97A}", sari: "\u{1F97B}", lab_coat: "\u{1F97C}", goggles: "\u{1F97D}", hiking_boot: "\u{1F97E}", womans_flat_shoe: "\u{1F97F}", crab: "\u{1F980}", lion_face: "\u{1F981}", scorpion: "\u{1F982}", turkey: "\u{1F983}", unicorn_face: "\u{1F984}", eagle: "\u{1F985}", duck: "\u{1F986}", bat: "\u{1F987}", shark: "\u{1F988}", owl: "\u{1F989}", fox_face: "\u{1F98A}", butterfly: "\u{1F98B}", deer: "\u{1F98C}", gorilla: "\u{1F98D}", lizard: "\u{1F98E}", rhinoceros: "\u{1F98F}", shrimp: "\u{1F990}", squid: "\u{1F991}", giraffe_face: "\u{1F992}", zebra_face: "\u{1F993}", hedgehog: "\u{1F994}", sauropod: "\u{1F995}", "t-rex": "\u{1F996}", cricket: "\u{1F997}", kangaroo: "\u{1F998}", llama: "\u{1F999}", peacock: "\u{1F99A}", hippopotamus: "\u{1F99B}", parrot: "\u{1F99C}", raccoon: "\u{1F99D}", lobster: "\u{1F99E}", mosquito: "\u{1F99F}", microbe: "\u{1F9A0}", badger: "\u{1F9A1}", swan: "\u{1F9A2}", mammoth: "\u{1F9A3}", dodo: "\u{1F9A4}", sloth: "\u{1F9A5}", otter: "\u{1F9A6}", orangutan: "\u{1F9A7}", skunk: "\u{1F9A8}", flamingo: "\u{1F9A9}", oyster: "\u{1F9AA}", beaver: "\u{1F9AB}", bison: "\u{1F9AC}", seal: "\u{1F9AD}", guide_dog: "\u{1F9AE}", probing_cane: "\u{1F9AF}", bone: "\u{1F9B4}", leg: "\u{1F9B5}", foot: "\u{1F9B6}", tooth: "\u{1F9B7}", female_superhero: "\u{1F9B8}\u200D\u2640\uFE0F", male_superhero: "\u{1F9B8}\u200D\u2642\uFE0F", superhero: "\u{1F9B8}", female_supervillain: "\u{1F9B9}\u200D\u2640\uFE0F", male_supervillain: "\u{1F9B9}\u200D\u2642\uFE0F", supervillain: "\u{1F9B9}", safety_vest: "\u{1F9BA}", ear_with_hearing_aid: "\u{1F9BB}", motorized_wheelchair: "\u{1F9BC}", manual_wheelchair: "\u{1F9BD}", mechanical_arm: "\u{1F9BE}", mechanical_leg: "\u{1F9BF}", cheese_wedge: "\u{1F9C0}", cupcake: "\u{1F9C1}", salt: "\u{1F9C2}", beverage_box: "\u{1F9C3}", garlic: "\u{1F9C4}", onion: "\u{1F9C5}", falafel: "\u{1F9C6}", waffle: "\u{1F9C7}", butter: "\u{1F9C8}", mate_drink: "\u{1F9C9}", ice_cube: "\u{1F9CA}", bubble_tea: "\u{1F9CB}", woman_standing: "\u{1F9CD}\u200D\u2640\uFE0F", man_standing: "\u{1F9CD}\u200D\u2642\uFE0F", standing_person: "\u{1F9CD}", woman_kneeling: "\u{1F9CE}\u200D\u2640\uFE0F", man_kneeling: "\u{1F9CE}\u200D\u2642\uFE0F", kneeling_person: "\u{1F9CE}", deaf_woman: "\u{1F9CF}\u200D\u2640\uFE0F", deaf_man: "\u{1F9CF}\u200D\u2642\uFE0F", deaf_person: "\u{1F9CF}", face_with_monocle: "\u{1F9D0}", farmer: "\u{1F9D1}\u200D\u{1F33E}", cook: "\u{1F9D1}\u200D\u{1F373}", person_feeding_baby: "\u{1F9D1}\u200D\u{1F37C}", mx_claus: "\u{1F9D1}\u200D\u{1F384}", student: "\u{1F9D1}\u200D\u{1F393}", singer: "\u{1F9D1}\u200D\u{1F3A4}", artist: "\u{1F9D1}\u200D\u{1F3A8}", teacher: "\u{1F9D1}\u200D\u{1F3EB}", factory_worker: "\u{1F9D1}\u200D\u{1F3ED}", technologist: "\u{1F9D1}\u200D\u{1F4BB}", office_worker: "\u{1F9D1}\u200D\u{1F4BC}", mechanic: "\u{1F9D1}\u200D\u{1F527}", scientist: "\u{1F9D1}\u200D\u{1F52C}", astronaut: "\u{1F9D1}\u200D\u{1F680}", firefighter: "\u{1F9D1}\u200D\u{1F692}", people_holding_hands: "\u{1F9D1}\u200D\u{1F91D}\u200D\u{1F9D1}", person_with_probing_cane: "\u{1F9D1}\u200D\u{1F9AF}", red_haired_person: "\u{1F9D1}\u200D\u{1F9B0}", curly_haired_person: "\u{1F9D1}\u200D\u{1F9B1}", bald_person: "\u{1F9D1}\u200D\u{1F9B2}", white_haired_person: "\u{1F9D1}\u200D\u{1F9B3}", person_in_motorized_wheelchair: "\u{1F9D1}\u200D\u{1F9BC}", person_in_manual_wheelchair: "\u{1F9D1}\u200D\u{1F9BD}", health_worker: "\u{1F9D1}\u200D\u2695\uFE0F", judge: "\u{1F9D1}\u200D\u2696\uFE0F", pilot: "\u{1F9D1}\u200D\u2708\uFE0F", adult: "\u{1F9D1}", child: "\u{1F9D2}", older_adult: "\u{1F9D3}", woman_with_beard: "\u{1F9D4}\u200D\u2640\uFE0F", man_with_beard: "\u{1F9D4}\u200D\u2642\uFE0F", bearded_person: "\u{1F9D4}", person_with_headscarf: "\u{1F9D5}", woman_in_steamy_room: "\u{1F9D6}\u200D\u2640\uFE0F", man_in_steamy_room: "\u{1F9D6}\u200D\u2642\uFE0F", person_in_steamy_room: "\u{1F9D6}\u200D\u2642\uFE0F", woman_climbing: "\u{1F9D7}\u200D\u2640\uFE0F", person_climbing: "\u{1F9D7}\u200D\u2640\uFE0F", man_climbing: "\u{1F9D7}\u200D\u2642\uFE0F", woman_in_lotus_position: "\u{1F9D8}\u200D\u2640\uFE0F", person_in_lotus_position: "\u{1F9D8}\u200D\u2640\uFE0F", man_in_lotus_position: "\u{1F9D8}\u200D\u2642\uFE0F", female_mage: "\u{1F9D9}\u200D\u2640\uFE0F", mage: "\u{1F9D9}\u200D\u2640\uFE0F", male_mage: "\u{1F9D9}\u200D\u2642\uFE0F", female_fairy: "\u{1F9DA}\u200D\u2640\uFE0F", fairy: "\u{1F9DA}\u200D\u2640\uFE0F", male_fairy: "\u{1F9DA}\u200D\u2642\uFE0F", female_vampire: "\u{1F9DB}\u200D\u2640\uFE0F", vampire: "\u{1F9DB}\u200D\u2640\uFE0F", male_vampire: "\u{1F9DB}\u200D\u2642\uFE0F", mermaid: "\u{1F9DC}\u200D\u2640\uFE0F", merman: "\u{1F9DC}\u200D\u2642\uFE0F", merperson: "\u{1F9DC}\u200D\u2642\uFE0F", female_elf: "\u{1F9DD}\u200D\u2640\uFE0F", male_elf: "\u{1F9DD}\u200D\u2642\uFE0F", elf: "\u{1F9DD}\u200D\u2642\uFE0F", female_genie: "\u{1F9DE}\u200D\u2640\uFE0F", male_genie: "\u{1F9DE}\u200D\u2642\uFE0F", genie: "\u{1F9DE}\u200D\u2642\uFE0F", female_zombie: "\u{1F9DF}\u200D\u2640\uFE0F", male_zombie: "\u{1F9DF}\u200D\u2642\uFE0F", zombie: "\u{1F9DF}\u200D\u2642\uFE0F", brain: "\u{1F9E0}", orange_heart: "\u{1F9E1}", billed_cap: "\u{1F9E2}", scarf: "\u{1F9E3}", gloves: "\u{1F9E4}", coat: "\u{1F9E5}", socks: "\u{1F9E6}", red_envelope: "\u{1F9E7}", firecracker: "\u{1F9E8}", jigsaw: "\u{1F9E9}", test_tube: "\u{1F9EA}", petri_dish: "\u{1F9EB}", dna: "\u{1F9EC}", compass: "\u{1F9ED}", abacus: "\u{1F9EE}", fire_extinguisher: "\u{1F9EF}", toolbox: "\u{1F9F0}", bricks: "\u{1F9F1}", magnet: "\u{1F9F2}", luggage: "\u{1F9F3}", lotion_bottle: "\u{1F9F4}", thread: "\u{1F9F5}", yarn: "\u{1F9F6}", safety_pin: "\u{1F9F7}", teddy_bear: "\u{1F9F8}", broom: "\u{1F9F9}", basket: "\u{1F9FA}", roll_of_paper: "\u{1F9FB}", soap: "\u{1F9FC}", sponge: "\u{1F9FD}", receipt: "\u{1F9FE}", nazar_amulet: "\u{1F9FF}", ballet_shoes: "\u{1FA70}", "one-piece_swimsuit": "\u{1FA71}", briefs: "\u{1FA72}", shorts: "\u{1FA73}", thong_sandal: "\u{1FA74}", drop_of_blood: "\u{1FA78}", adhesive_bandage: "\u{1FA79}", stethoscope: "\u{1FA7A}", "yo-yo": "\u{1FA80}", kite: "\u{1FA81}", parachute: "\u{1FA82}", boomerang: "\u{1FA83}", magic_wand: "\u{1FA84}", pinata: "\u{1FA85}", nesting_dolls: "\u{1FA86}", ringed_planet: "\u{1FA90}", chair: "\u{1FA91}", razor: "\u{1FA92}", axe: "\u{1FA93}", diya_lamp: "\u{1FA94}", banjo: "\u{1FA95}", military_helmet: "\u{1FA96}", accordion: "\u{1FA97}", long_drum: "\u{1FA98}", coin: "\u{1FA99}", carpentry_saw: "\u{1FA9A}", screwdriver: "\u{1FA9B}", ladder: "\u{1FA9C}", hook: "\u{1FA9D}", mirror: "\u{1FA9E}", window: "\u{1FA9F}", plunger: "\u{1FAA0}", sewing_needle: "\u{1FAA1}", knot: "\u{1FAA2}", bucket: "\u{1FAA3}", mouse_trap: "\u{1FAA4}", toothbrush: "\u{1FAA5}", headstone: "\u{1FAA6}", placard: "\u{1FAA7}", rock: "\u{1FAA8}", fly: "\u{1FAB0}", worm: "\u{1FAB1}", beetle: "\u{1FAB2}", cockroach: "\u{1FAB3}", potted_plant: "\u{1FAB4}", wood: "\u{1FAB5}", feather: "\u{1FAB6}", anatomical_heart: "\u{1FAC0}", lungs: "\u{1FAC1}", people_hugging: "\u{1FAC2}", blueberries: "\u{1FAD0}", bell_pepper: "\u{1FAD1}", olive: "\u{1FAD2}", flatbread: "\u{1FAD3}", tamale: "\u{1FAD4}", fondue: "\u{1FAD5}", teapot: "\u{1FAD6}", bangbang: "\u203C\uFE0F", interrobang: "\u2049\uFE0F", tm: "\u2122\uFE0F", information_source: "\u2139\uFE0F", left_right_arrow: "\u2194\uFE0F", arrow_up_down: "\u2195\uFE0F", arrow_upper_left: "\u2196\uFE0F", arrow_upper_right: "\u2197\uFE0F", arrow_lower_right: "\u2198\uFE0F", arrow_lower_left: "\u2199\uFE0F", leftwards_arrow_with_hook: "\u21A9\uFE0F", arrow_right_hook: "\u21AA\uFE0F", watch: "\u231A", hourglass: "\u231B", keyboard: "\u2328\uFE0F", eject: "\u23CF\uFE0F", fast_forward: "\u23E9", rewind: "\u23EA", arrow_double_up: "\u23EB", arrow_double_down: "\u23EC", black_right_pointing_double_triangle_with_vertical_bar: "\u23ED\uFE0F", black_left_pointing_double_triangle_with_vertical_bar: "\u23EE\uFE0F", black_right_pointing_triangle_with_double_vertical_bar: "\u23EF\uFE0F", alarm_clock: "\u23F0", stopwatch: "\u23F1\uFE0F", timer_clock: "\u23F2\uFE0F", hourglass_flowing_sand: "\u23F3", double_vertical_bar: "\u23F8\uFE0F", black_square_for_stop: "\u23F9\uFE0F", black_circle_for_record: "\u23FA\uFE0F", m: "\u24C2\uFE0F", black_small_square: "\u25AA\uFE0F", white_small_square: "\u25AB\uFE0F", arrow_forward: "\u25B6\uFE0F", arrow_backward: "\u25C0\uFE0F", white_medium_square: "\u25FB\uFE0F", black_medium_square: "\u25FC\uFE0F", white_medium_small_square: "\u25FD", black_medium_small_square: "\u25FE", sunny: "\u2600\uFE0F", cloud: "\u2601\uFE0F", umbrella: "\u2602\uFE0F", snowman: "\u2603\uFE0F", comet: "\u2604\uFE0F", phone: "\u260E\uFE0F", telephone: "\u260E\uFE0F", ballot_box_with_check: "\u2611\uFE0F", shamrock: "\u2618\uFE0F", point_up: "\u261D\uFE0F", skull_and_crossbones: "\u2620\uFE0F", radioactive_sign: "\u2622\uFE0F", biohazard_sign: "\u2623\uFE0F", orthodox_cross: "\u2626\uFE0F", star_and_crescent: "\u262A\uFE0F", peace_symbol: "\u262E\uFE0F", yin_yang: "\u262F\uFE0F", wheel_of_dharma: "\u2638\uFE0F", white_frowning_face: "\u2639\uFE0F", relaxed: "\u263A\uFE0F", female_sign: "\u2640\uFE0F", male_sign: "\u2642\uFE0F", gemini: "\u264A", cancer: "\u264B", leo: "\u264C", virgo: "\u264D", libra: "\u264E", scorpius: "\u264F", chess_pawn: "\u265F\uFE0F", spades: "\u2660\uFE0F", clubs: "\u2663\uFE0F", hearts: "\u2665\uFE0F", diamonds: "\u2666\uFE0F", hotsprings: "\u2668\uFE0F", recycle: "\u267B\uFE0F", infinity: "\u267E\uFE0F", wheelchair: "\u267F", hammer_and_pick: "\u2692\uFE0F", crossed_swords: "\u2694\uFE0F", medical_symbol: "\u2695\uFE0F", staff_of_aesculapius: "\u2695\uFE0F", scales: "\u2696\uFE0F", alembic: "\u2697\uFE0F", gear: "\u2699\uFE0F", atom_symbol: "\u269B\uFE0F", fleur_de_lis: "\u269C\uFE0F", warning: "\u26A0\uFE0F", zap: "\u26A1", transgender_symbol: "\u26A7\uFE0F", white_circle: "\u26AA", black_circle: "\u26AB", coffin: "\u26B0\uFE0F", funeral_urn: "\u26B1\uFE0F", soccer: "\u26BD", baseball: "\u26BE", snowman_without_snow: "\u26C4", partly_sunny: "\u26C5", thunder_cloud_and_rain: "\u26C8\uFE0F", ophiuchus: "\u26CE", pick: "\u26CF\uFE0F", helmet_with_white_cross: "\u26D1\uFE0F", chains: "\u26D3\uFE0F", no_entry: "\u26D4", shinto_shrine: "\u26E9\uFE0F", church: "\u26EA", mountain: "\u26F0\uFE0F", umbrella_on_ground: "\u26F1\uFE0F", fountain: "\u26F2", golf: "\u26F3", ferry: "\u26F4\uFE0F", boat: "\u26F5", sailboat: "\u26F5", skier: "\u26F7\uFE0F", ice_skate: "\u26F8\uFE0F", "woman-bouncing-ball": "\u26F9\uFE0F\u200D\u2640\uFE0F", "man-bouncing-ball": "\u26F9\uFE0F\u200D\u2642\uFE0F", person_with_ball: "\u26F9\uFE0F\u200D\u2642\uFE0F", tent: "\u26FA", fuelpump: "\u26FD", scissors: "\u2702\uFE0F", airplane: "\u2708\uFE0F", email: "\u2709\uFE0F", envelope: "\u2709\uFE0F", fist: "\u270A", hand: "\u270B", raised_hand: "\u270B", v: "\u270C\uFE0F", writing_hand: "\u270D\uFE0F", pencil2: "\u270F\uFE0F", black_nib: "\u2712\uFE0F", heavy_check_mark: "\u2714\uFE0F", heavy_multiplication_x: "\u2716\uFE0F", latin_cross: "\u271D\uFE0F", star_of_david: "\u2721\uFE0F", eight_spoked_asterisk: "\u2733\uFE0F", eight_pointed_black_star: "\u2734\uFE0F", snowflake: "\u2744\uFE0F", sparkle: "\u2747\uFE0F", x: "\u274C", negative_squared_cross_mark: "\u274E", heavy_heart_exclamation_mark_ornament: "\u2763\uFE0F", heart_on_fire: "\u2764\uFE0F\u200D\u{1F525}", mending_heart: "\u2764\uFE0F\u200D\u{1FA79}", heart: "\u2764\uFE0F", arrow_right: "\u27A1\uFE0F", curly_loop: "\u27B0", loop: "\u27BF", arrow_heading_up: "\u2934\uFE0F", arrow_heading_down: "\u2935\uFE0F", arrow_left: "\u2B05\uFE0F", arrow_up: "\u2B06\uFE0F", arrow_down: "\u2B07\uFE0F", black_large_square: "\u2B1B", white_large_square: "\u2B1C", star: "\u2B50", o: "\u2B55", wavy_dash: "\u3030\uFE0F", part_alternation_mark: "\u303D\uFE0F", congratulations: "\u3297\uFE0F", secret: "\u3299\uFE0F" };
  }
});

// ../node_modules/node-emoji/lib/emoji.js
var require_emoji2 = __commonJS({
  "../node_modules/node-emoji/lib/emoji.js"(exports2, module2) {
    var toArray = require_toArray();
    var emojiByName = require_emoji();
    var emojiNameRegex = /:([a-zA-Z0-9_\-\+]+):/g;
    var trimSpaceRegex = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    function stripColons(str) {
      var colonIndex = str.indexOf(":");
      if (colonIndex > -1) {
        if (colonIndex === str.length - 1) {
          str = str.substring(0, colonIndex);
          return stripColons(str);
        } else {
          str = str.substr(colonIndex + 1);
          return stripColons(str);
        }
      }
      return str;
    }
    function wrapColons(str) {
      return typeof str === "string" && str.length > 0 ? ":" + str + ":" : str;
    }
    function ensureColons(str) {
      return typeof str === "string" && str[0] !== ":" ? wrapColons(str) : str;
    }
    var NON_SPACING_MARK = String.fromCharCode(65039);
    var nonSpacingRegex = new RegExp(NON_SPACING_MARK, "g");
    function stripNSB(code) {
      return code.replace(nonSpacingRegex, "");
    }
    var emojiByCode = Object.keys(emojiByName).reduce(function(h, k) {
      h[stripNSB(emojiByName[k])] = k;
      return h;
    }, {});
    var Emoji = {
      emoji: emojiByName
    };
    Emoji._get = function _get(emoji) {
      if (emojiByCode[stripNSB(emoji)]) {
        return emoji;
      } else if (emojiByName.hasOwnProperty(emoji)) {
        return emojiByName[emoji];
      }
      return ensureColons(emoji);
    };
    Emoji.get = function get(emoji) {
      emoji = stripColons(emoji);
      return Emoji._get(emoji);
    };
    Emoji.find = function find(nameOrCode) {
      return Emoji.findByName(nameOrCode) || Emoji.findByCode(nameOrCode);
    };
    Emoji.findByName = function findByName(name) {
      var stripped = stripColons(name);
      var emoji = emojiByName[stripped];
      return emoji ? { emoji, key: stripped } : void 0;
    };
    Emoji.findByCode = function findByCode(code) {
      var stripped = stripNSB(code);
      var name = emojiByCode[stripped];
      return name ? { emoji: emojiByName[name], key: name } : void 0;
    };
    Emoji.hasEmoji = function hasEmoji(nameOrCode) {
      return Emoji.hasEmojiByName(nameOrCode) || Emoji.hasEmojiByCode(nameOrCode);
    };
    Emoji.hasEmojiByName = function hasEmojiByName(name) {
      var result = Emoji.findByName(name);
      return !!result && result.key === stripColons(name);
    };
    Emoji.hasEmojiByCode = function hasEmojiByCode(code) {
      var result = Emoji.findByCode(code);
      return !!result && stripNSB(result.emoji) === stripNSB(code);
    };
    Emoji.which = function which(emoji_code, includeColons) {
      var code = stripNSB(emoji_code);
      var word = emojiByCode[code];
      return includeColons ? wrapColons(word) : word;
    };
    Emoji.emojify = function emojify(str, on_missing, format) {
      if (!str)
        return "";
      return str.split(emojiNameRegex).map(function parseEmoji(s, i) {
        if (i % 2 === 0)
          return s;
        var emoji = Emoji._get(s);
        var isMissing = emoji.indexOf(":") > -1;
        if (isMissing && typeof on_missing === "function") {
          return on_missing(s);
        }
        if (!isMissing && typeof format === "function") {
          return format(emoji, s);
        }
        return emoji;
      }).join("");
    };
    Emoji.random = function random() {
      var emojiKeys = Object.keys(emojiByName);
      var randomIndex = Math.floor(Math.random() * emojiKeys.length);
      var key = emojiKeys[randomIndex];
      var emoji = Emoji._get(key);
      return { key, emoji };
    };
    Emoji.search = function search(str) {
      var emojiKeys = Object.keys(emojiByName);
      var matcher = stripColons(str);
      var matchingKeys = emojiKeys.filter(function(key) {
        return key.toString().indexOf(matcher) === 0;
      });
      return matchingKeys.map(function(key) {
        return {
          key,
          emoji: Emoji._get(key)
        };
      });
    };
    Emoji.unemojify = function unemojify(str) {
      if (!str)
        return "";
      var words = toArray(str);
      return words.map(function(word) {
        return Emoji.which(word, true) || word;
      }).join("");
    };
    Emoji.replace = function replace(str, replacement, cleanSpaces) {
      if (!str)
        return "";
      var replace2 = typeof replacement === "function" ? replacement : function() {
        return replacement;
      };
      var words = toArray(str);
      var replaced = words.map(function(word, idx) {
        var emoji = Emoji.findByCode(word);
        if (emoji && cleanSpaces && words[idx + 1] === " ") {
          words[idx + 1] = "";
        }
        return emoji ? replace2(emoji) : word;
      }).join("");
      return cleanSpaces ? replaced.replace(trimSpaceRegex, "") : replaced;
    };
    Emoji.strip = function strip(str) {
      return Emoji.replace(str, "", true);
    };
    module2.exports = Emoji;
  }
});

// ../node_modules/node-emoji/index.js
var require_node_emoji = __commonJS({
  "../node_modules/node-emoji/index.js"(exports2, module2) {
    module2.exports = require_emoji2();
  }
});

// ../node_modules/es5-ext/function/noop.js
var require_noop = __commonJS({
  "../node_modules/es5-ext/function/noop.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
    };
  }
});

// ../node_modules/es5-ext/object/is-value.js
var require_is_value = __commonJS({
  "../node_modules/es5-ext/object/is-value.js"(exports2, module2) {
    "use strict";
    var _undefined = require_noop()();
    module2.exports = function(val) {
      return val !== _undefined && val !== null;
    };
  }
});

// ../node_modules/es5-ext/object/valid-value.js
var require_valid_value = __commonJS({
  "../node_modules/es5-ext/object/valid-value.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    module2.exports = function(value) {
      if (!isValue(value))
        throw new TypeError("Cannot use null or undefined");
      return value;
    };
  }
});

// ../node_modules/es5-ext/object/is-callable.js
var require_is_callable = __commonJS({
  "../node_modules/es5-ext/object/is-callable.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      return typeof obj === "function";
    };
  }
});

// ../node_modules/es5-ext/object/validate-stringifiable.js
var require_validate_stringifiable = __commonJS({
  "../node_modules/es5-ext/object/validate-stringifiable.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(stringifiable) {
      try {
        if (stringifiable && isCallable(stringifiable.toString))
          return stringifiable.toString();
        return String(stringifiable);
      } catch (e) {
        throw new TypeError("Passed argument cannot be stringifed");
      }
    };
  }
});

// ../node_modules/es5-ext/object/validate-stringifiable-value.js
var require_validate_stringifiable_value = __commonJS({
  "../node_modules/es5-ext/object/validate-stringifiable-value.js"(exports2, module2) {
    "use strict";
    var ensureValue = require_valid_value();
    var stringifiable = require_validate_stringifiable();
    module2.exports = function(value) {
      return stringifiable(ensureValue(value));
    };
  }
});

// ../node_modules/es5-ext/object/is-object.js
var require_is_object = __commonJS({
  "../node_modules/es5-ext/object/is-object.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    var map = { function: true, object: true };
    module2.exports = function(value) {
      return isValue(value) && map[typeof value] || false;
    };
  }
});

// ../node_modules/es5-ext/object/valid-object.js
var require_valid_object = __commonJS({
  "../node_modules/es5-ext/object/valid-object.js"(exports2, module2) {
    "use strict";
    var isObject = require_is_object();
    module2.exports = function(value) {
      if (!isObject(value))
        throw new TypeError(value + " is not an Object");
      return value;
    };
  }
});

// ../node_modules/es5-ext/object/mixin.js
var require_mixin = __commonJS({
  "../node_modules/es5-ext/object/mixin.js"(exports2, module2) {
    "use strict";
    var value = require_valid_value();
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    module2.exports = function(target, source) {
      var error, sourceObject = Object(value(source));
      target = Object(value(target));
      getOwnPropertyNames(sourceObject).forEach(function(name) {
        try {
          defineProperty(target, name, getOwnPropertyDescriptor(source, name));
        } catch (e) {
          error = e;
        }
      });
      if (typeof getOwnPropertySymbols === "function") {
        getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
          try {
            defineProperty(target, symbol, getOwnPropertyDescriptor(source, symbol));
          } catch (e) {
            error = e;
          }
        });
      }
      if (error !== void 0)
        throw error;
      return target;
    };
  }
});

// ../node_modules/type/value/is.js
var require_is = __commonJS({
  "../node_modules/type/value/is.js"(exports2, module2) {
    "use strict";
    var _undefined = void 0;
    module2.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  }
});

// ../node_modules/type/object/is.js
var require_is2 = __commonJS({
  "../node_modules/type/object/is.js"(exports2, module2) {
    "use strict";
    var isValue = require_is();
    var possibleTypes = { "object": true, "function": true, "undefined": true };
    module2.exports = function(value) {
      if (!isValue(value))
        return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  }
});

// ../node_modules/type/string/coerce.js
var require_coerce = __commonJS({
  "../node_modules/type/string/coerce.js"(exports2, module2) {
    "use strict";
    var isValue = require_is();
    var isObject = require_is2();
    var objectToString = Object.prototype.toString;
    module2.exports = function(value) {
      if (!isValue(value))
        return null;
      if (isObject(value)) {
        var valueToString = value.toString;
        if (typeof valueToString !== "function")
          return null;
        if (valueToString === objectToString)
          return null;
      }
      try {
        return "" + value;
      } catch (error) {
        return null;
      }
    };
  }
});

// ../node_modules/type/lib/safe-to-string.js
var require_safe_to_string = __commonJS({
  "../node_modules/type/lib/safe-to-string.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      try {
        return value.toString();
      } catch (error) {
        try {
          return String(value);
        } catch (error2) {
          return null;
        }
      }
    };
  }
});

// ../node_modules/type/lib/to-short-string.js
var require_to_short_string = __commonJS({
  "../node_modules/type/lib/to-short-string.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string === null)
        return "<Non-coercible to string value>";
      if (string.length > 100)
        string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        switch (char) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("Unexpected character");
        }
      });
      return string;
    };
  }
});

// ../node_modules/type/lib/resolve-error-message.js
var require_resolve_error_message = __commonJS({
  "../node_modules/type/lib/resolve-error-message.js"(exports2, module2) {
    "use strict";
    var stringCoerce = require_coerce();
    var toShortString = require_to_short_string();
    module2.exports = function(errorMessage, value, inputOptions) {
      if (inputOptions && inputOptions.errorMessage) {
        errorMessage = stringCoerce(inputOptions.errorMessage);
      }
      var valueInsertIndex = errorMessage.indexOf("%v");
      var valueToken = valueInsertIndex > -1 ? toShortString(value) : null;
      if (inputOptions && inputOptions.name) {
        var nameInsertIndex = errorMessage.indexOf("%n");
        if (nameInsertIndex > -1) {
          if (valueInsertIndex > -1) {
            var firstToken, secondToken, firstInsertIndex, secondInsertIndex;
            if (nameInsertIndex > valueInsertIndex) {
              firstToken = valueToken;
              firstInsertIndex = valueInsertIndex;
              secondToken = inputOptions.name;
              secondInsertIndex = nameInsertIndex;
            } else {
              firstToken = inputOptions.name;
              firstInsertIndex = nameInsertIndex;
              secondToken = valueToken;
              secondInsertIndex = valueInsertIndex;
            }
            return errorMessage.slice(0, firstInsertIndex) + firstToken + errorMessage.slice(firstInsertIndex + 2, secondInsertIndex) + secondToken + errorMessage.slice(secondInsertIndex + 2);
          }
          return errorMessage.slice(0, nameInsertIndex) + inputOptions.name + errorMessage.slice(nameInsertIndex + 2);
        }
      }
      if (valueInsertIndex > -1) {
        return errorMessage.slice(0, valueInsertIndex) + valueToken + errorMessage.slice(valueInsertIndex + 2);
      }
      return errorMessage;
    };
  }
});

// ../node_modules/type/lib/resolve-exception.js
var require_resolve_exception = __commonJS({
  "../node_modules/type/lib/resolve-exception.js"(exports2, module2) {
    "use strict";
    var isValue = require_is();
    var resolveErrorMessage = require_resolve_error_message();
    module2.exports = function(value, defaultMessage, inputOptions) {
      if (inputOptions && !isValue(value)) {
        if ("default" in inputOptions)
          return inputOptions["default"];
        if (inputOptions.isOptional)
          return null;
      }
      var ErrorConstructor = inputOptions && inputOptions.Error || TypeError;
      var error = new ErrorConstructor(resolveErrorMessage(defaultMessage, value, inputOptions));
      if (inputOptions && inputOptions.errorCode)
        error.code = inputOptions.errorCode;
      throw error;
    };
  }
});

// ../node_modules/type/string/ensure.js
var require_ensure = __commonJS({
  "../node_modules/type/string/ensure.js"(exports2, module2) {
    "use strict";
    var resolveException = require_resolve_exception();
    var coerce = require_coerce();
    module2.exports = function(value) {
      var coerced = coerce(value);
      if (coerced !== null)
        return coerced;
      var options = arguments[1];
      var errorMessage = options && options.name ? "Expected a string for %n, received %v" : "%v is not a string";
      return resolveException(value, errorMessage, options);
    };
  }
});

// ../node_modules/es5-ext/array/from/is-implemented.js
var require_is_implemented = __commonJS({
  "../node_modules/es5-ext/array/from/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var from = Array.from, arr, result;
      if (typeof from !== "function")
        return false;
      arr = ["raz", "dwa"];
      result = from(arr);
      return Boolean(result && result !== arr && result[1] === "dwa");
    };
  }
});

// ../node_modules/ext/global-this/is-implemented.js
var require_is_implemented2 = __commonJS({
  "../node_modules/ext/global-this/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      if (typeof globalThis !== "object")
        return false;
      if (!globalThis)
        return false;
      return globalThis.Array === Array;
    };
  }
});

// ../node_modules/ext/global-this/implementation.js
var require_implementation = __commonJS({
  "../node_modules/ext/global-this/implementation.js"(exports2, module2) {
    var naiveFallback = function() {
      if (typeof self === "object" && self)
        return self;
      if (typeof window === "object" && window)
        return window;
      throw new Error("Unable to resolve global `this`");
    };
    module2.exports = function() {
      if (this)
        return this;
      try {
        Object.defineProperty(Object.prototype, "__global__", {
          get: function() {
            return this;
          },
          configurable: true
        });
      } catch (error) {
        return naiveFallback();
      }
      try {
        if (!__global__)
          return naiveFallback();
        return __global__;
      } finally {
        delete Object.prototype.__global__;
      }
    }();
  }
});

// ../node_modules/ext/global-this/index.js
var require_global_this = __commonJS({
  "../node_modules/ext/global-this/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented2()() ? globalThis : require_implementation();
  }
});

// ../node_modules/es6-symbol/is-implemented.js
var require_is_implemented3 = __commonJS({
  "../node_modules/es6-symbol/is-implemented.js"(exports2, module2) {
    "use strict";
    var global2 = require_global_this();
    var validTypes = { object: true, symbol: true };
    module2.exports = function() {
      var Symbol2 = global2.Symbol;
      var symbol;
      if (typeof Symbol2 !== "function")
        return false;
      symbol = Symbol2("test symbol");
      try {
        String(symbol);
      } catch (e) {
        return false;
      }
      if (!validTypes[typeof Symbol2.iterator])
        return false;
      if (!validTypes[typeof Symbol2.toPrimitive])
        return false;
      if (!validTypes[typeof Symbol2.toStringTag])
        return false;
      return true;
    };
  }
});

// ../node_modules/d/node_modules/type/value/is.js
var require_is3 = __commonJS({
  "../node_modules/d/node_modules/type/value/is.js"(exports2, module2) {
    "use strict";
    var _undefined = void 0;
    module2.exports = function(value) {
      return value !== _undefined && value !== null;
    };
  }
});

// ../node_modules/d/node_modules/type/object/is.js
var require_is4 = __commonJS({
  "../node_modules/d/node_modules/type/object/is.js"(exports2, module2) {
    "use strict";
    var isValue = require_is3();
    var possibleTypes = { "object": true, "function": true, "undefined": true };
    module2.exports = function(value) {
      if (!isValue(value))
        return false;
      return hasOwnProperty.call(possibleTypes, typeof value);
    };
  }
});

// ../node_modules/d/node_modules/type/prototype/is.js
var require_is5 = __commonJS({
  "../node_modules/d/node_modules/type/prototype/is.js"(exports2, module2) {
    "use strict";
    var isObject = require_is4();
    module2.exports = function(value) {
      if (!isObject(value))
        return false;
      try {
        if (!value.constructor)
          return false;
        return value.constructor.prototype === value;
      } catch (error) {
        return false;
      }
    };
  }
});

// ../node_modules/d/node_modules/type/function/is.js
var require_is6 = __commonJS({
  "../node_modules/d/node_modules/type/function/is.js"(exports2, module2) {
    "use strict";
    var isPrototype = require_is5();
    module2.exports = function(value) {
      if (typeof value !== "function")
        return false;
      if (!hasOwnProperty.call(value, "length"))
        return false;
      try {
        if (typeof value.length !== "number")
          return false;
        if (typeof value.call !== "function")
          return false;
        if (typeof value.apply !== "function")
          return false;
      } catch (error) {
        return false;
      }
      return !isPrototype(value);
    };
  }
});

// ../node_modules/d/node_modules/type/plain-function/is.js
var require_is7 = __commonJS({
  "../node_modules/d/node_modules/type/plain-function/is.js"(exports2, module2) {
    "use strict";
    var isFunction = require_is6();
    var classRe = /^\s*class[\s{/}]/;
    var functionToString = Function.prototype.toString;
    module2.exports = function(value) {
      if (!isFunction(value))
        return false;
      if (classRe.test(functionToString.call(value)))
        return false;
      return true;
    };
  }
});

// ../node_modules/es5-ext/object/assign/is-implemented.js
var require_is_implemented4 = __commonJS({
  "../node_modules/es5-ext/object/assign/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var assign = Object.assign, obj;
      if (typeof assign !== "function")
        return false;
      obj = { foo: "raz" };
      assign(obj, { bar: "dwa" }, { trzy: "trzy" });
      return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
    };
  }
});

// ../node_modules/es5-ext/object/keys/is-implemented.js
var require_is_implemented5 = __commonJS({
  "../node_modules/es5-ext/object/keys/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      try {
        Object.keys("primitive");
        return true;
      } catch (e) {
        return false;
      }
    };
  }
});

// ../node_modules/es5-ext/object/keys/shim.js
var require_shim = __commonJS({
  "../node_modules/es5-ext/object/keys/shim.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    var keys = Object.keys;
    module2.exports = function(object) {
      return keys(isValue(object) ? Object(object) : object);
    };
  }
});

// ../node_modules/es5-ext/object/keys/index.js
var require_keys2 = __commonJS({
  "../node_modules/es5-ext/object/keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented5()() ? Object.keys : require_shim();
  }
});

// ../node_modules/es5-ext/object/assign/shim.js
var require_shim2 = __commonJS({
  "../node_modules/es5-ext/object/assign/shim.js"(exports2, module2) {
    "use strict";
    var keys = require_keys2();
    var value = require_valid_value();
    var max = Math.max;
    module2.exports = function(dest, src) {
      var error, i, length = max(arguments.length, 2), assign;
      dest = Object(value(dest));
      assign = function(key) {
        try {
          dest[key] = src[key];
        } catch (e) {
          if (!error)
            error = e;
        }
      };
      for (i = 1; i < length; ++i) {
        src = arguments[i];
        keys(src).forEach(assign);
      }
      if (error !== void 0)
        throw error;
      return dest;
    };
  }
});

// ../node_modules/es5-ext/object/assign/index.js
var require_assign = __commonJS({
  "../node_modules/es5-ext/object/assign/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented4()() ? Object.assign : require_shim2();
  }
});

// ../node_modules/es5-ext/object/normalize-options.js
var require_normalize_options = __commonJS({
  "../node_modules/es5-ext/object/normalize-options.js"(exports2, module2) {
    "use strict";
    var isValue = require_is_value();
    var forEach = Array.prototype.forEach;
    var create = Object.create;
    var process2 = function(src, obj) {
      var key;
      for (key in src)
        obj[key] = src[key];
    };
    module2.exports = function(opts1) {
      var result = create(null);
      forEach.call(arguments, function(options) {
        if (!isValue(options))
          return;
        process2(Object(options), result);
      });
      return result;
    };
  }
});

// ../node_modules/es5-ext/string/#/contains/is-implemented.js
var require_is_implemented6 = __commonJS({
  "../node_modules/es5-ext/string/#/contains/is-implemented.js"(exports2, module2) {
    "use strict";
    var str = "razdwatrzy";
    module2.exports = function() {
      if (typeof str.contains !== "function")
        return false;
      return str.contains("dwa") === true && str.contains("foo") === false;
    };
  }
});

// ../node_modules/es5-ext/string/#/contains/shim.js
var require_shim3 = __commonJS({
  "../node_modules/es5-ext/string/#/contains/shim.js"(exports2, module2) {
    "use strict";
    var indexOf = String.prototype.indexOf;
    module2.exports = function(searchString) {
      return indexOf.call(this, searchString, arguments[1]) > -1;
    };
  }
});

// ../node_modules/es5-ext/string/#/contains/index.js
var require_contains = __commonJS({
  "../node_modules/es5-ext/string/#/contains/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented6()() ? String.prototype.contains : require_shim3();
  }
});

// ../node_modules/d/index.js
var require_d = __commonJS({
  "../node_modules/d/index.js"(exports2, module2) {
    "use strict";
    var isValue = require_is3();
    var isPlainFunction = require_is7();
    var assign = require_assign();
    var normalizeOpts = require_normalize_options();
    var contains = require_contains();
    var d = module2.exports = function(dscr, value) {
      var c, e, w, options, desc;
      if (arguments.length < 2 || typeof dscr !== "string") {
        options = value;
        value = dscr;
        dscr = null;
      } else {
        options = arguments[2];
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
        w = contains.call(dscr, "w");
      } else {
        c = w = true;
        e = false;
      }
      desc = { value, configurable: c, enumerable: e, writable: w };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
    d.gs = function(dscr, get, set) {
      var c, e, options, desc;
      if (typeof dscr !== "string") {
        options = set;
        set = get;
        get = dscr;
        dscr = null;
      } else {
        options = arguments[3];
      }
      if (!isValue(get)) {
        get = void 0;
      } else if (!isPlainFunction(get)) {
        options = get;
        get = set = void 0;
      } else if (!isValue(set)) {
        set = void 0;
      } else if (!isPlainFunction(set)) {
        options = set;
        set = void 0;
      }
      if (isValue(dscr)) {
        c = contains.call(dscr, "c");
        e = contains.call(dscr, "e");
      } else {
        c = true;
        e = false;
      }
      desc = { get, set, configurable: c, enumerable: e };
      return !options ? desc : assign(normalizeOpts(options), desc);
    };
  }
});

// ../node_modules/es6-symbol/is-symbol.js
var require_is_symbol = __commonJS({
  "../node_modules/es6-symbol/is-symbol.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      if (!value)
        return false;
      if (typeof value === "symbol")
        return true;
      if (!value.constructor)
        return false;
      if (value.constructor.name !== "Symbol")
        return false;
      return value[value.constructor.toStringTag] === "Symbol";
    };
  }
});

// ../node_modules/es6-symbol/validate-symbol.js
var require_validate_symbol = __commonJS({
  "../node_modules/es6-symbol/validate-symbol.js"(exports2, module2) {
    "use strict";
    var isSymbol = require_is_symbol();
    module2.exports = function(value) {
      if (!isSymbol(value))
        throw new TypeError(value + " is not a symbol");
      return value;
    };
  }
});

// ../node_modules/es6-symbol/lib/private/generate-name.js
var require_generate_name = __commonJS({
  "../node_modules/es6-symbol/lib/private/generate-name.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var objPrototype = Object.prototype;
    var created = create(null);
    module2.exports = function(desc) {
      var postfix = 0, name, ie11BugWorkaround;
      while (created[desc + (postfix || "")])
        ++postfix;
      desc += postfix || "";
      created[desc] = true;
      name = "@@" + desc;
      defineProperty(objPrototype, name, d.gs(null, function(value) {
        if (ie11BugWorkaround)
          return;
        ie11BugWorkaround = true;
        defineProperty(this, name, d(value));
        ie11BugWorkaround = false;
      }));
      return name;
    };
  }
});

// ../node_modules/es6-symbol/lib/private/setup/standard-symbols.js
var require_standard_symbols = __commonJS({
  "../node_modules/es6-symbol/lib/private/setup/standard-symbols.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var NativeSymbol = require_global_this().Symbol;
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        hasInstance: d("", NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")),
        isConcatSpreadable: d("", NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")),
        iterator: d("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
        match: d("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
        replace: d("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
        search: d("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
        species: d("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
        split: d("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
        toPrimitive: d("", NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")),
        toStringTag: d("", NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")),
        unscopables: d("", NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables"))
      });
    };
  }
});

// ../node_modules/es6-symbol/lib/private/setup/symbol-registry.js
var require_symbol_registry = __commonJS({
  "../node_modules/es6-symbol/lib/private/setup/symbol-registry.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var registry = Object.create(null);
    module2.exports = function(SymbolPolyfill) {
      return Object.defineProperties(SymbolPolyfill, {
        for: d(function(key) {
          if (registry[key])
            return registry[key];
          return registry[key] = SymbolPolyfill(String(key));
        }),
        keyFor: d(function(symbol) {
          var key;
          validateSymbol(symbol);
          for (key in registry) {
            if (registry[key] === symbol)
              return key;
          }
          return void 0;
        })
      });
    };
  }
});

// ../node_modules/es6-symbol/polyfill.js
var require_polyfill = __commonJS({
  "../node_modules/es6-symbol/polyfill.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var validateSymbol = require_validate_symbol();
    var NativeSymbol = require_global_this().Symbol;
    var generateName = require_generate_name();
    var setupStandardSymbols = require_standard_symbols();
    var setupSymbolRegistry = require_symbol_registry();
    var create = Object.create;
    var defineProperties = Object.defineProperties;
    var defineProperty = Object.defineProperty;
    var SymbolPolyfill;
    var HiddenSymbol;
    var isNativeSafe;
    if (typeof NativeSymbol === "function") {
      try {
        String(NativeSymbol());
        isNativeSafe = true;
      } catch (ignore) {
      }
    } else {
      NativeSymbol = null;
    }
    HiddenSymbol = function Symbol2(description) {
      if (this instanceof HiddenSymbol)
        throw new TypeError("Symbol is not a constructor");
      return SymbolPolyfill(description);
    };
    module2.exports = SymbolPolyfill = function Symbol2(description) {
      var symbol;
      if (this instanceof Symbol2)
        throw new TypeError("Symbol is not a constructor");
      if (isNativeSafe)
        return NativeSymbol(description);
      symbol = create(HiddenSymbol.prototype);
      description = description === void 0 ? "" : String(description);
      return defineProperties(symbol, {
        __description__: d("", description),
        __name__: d("", generateName(description))
      });
    };
    setupStandardSymbols(SymbolPolyfill);
    setupSymbolRegistry(SymbolPolyfill);
    defineProperties(HiddenSymbol.prototype, {
      constructor: d(SymbolPolyfill),
      toString: d("", function() {
        return this.__name__;
      })
    });
    defineProperties(SymbolPolyfill.prototype, {
      toString: d(function() {
        return "Symbol (" + validateSymbol(this).__description__ + ")";
      }),
      valueOf: d(function() {
        return validateSymbol(this);
      })
    });
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d("", function() {
      var symbol = validateSymbol(this);
      if (typeof symbol === "symbol")
        return symbol;
      return symbol.toString();
    }));
    defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d("c", "Symbol"));
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));
    defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive, d("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));
  }
});

// ../node_modules/es6-symbol/index.js
var require_es6_symbol = __commonJS({
  "../node_modules/es6-symbol/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented3()() ? require_global_this().Symbol : require_polyfill();
  }
});

// ../node_modules/es5-ext/function/is-arguments.js
var require_is_arguments = __commonJS({
  "../node_modules/es5-ext/function/is-arguments.js"(exports2, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call(function() {
      return arguments;
    }());
    module2.exports = function(value) {
      return objToString.call(value) === id;
    };
  }
});

// ../node_modules/es5-ext/function/is-function.js
var require_is_function = __commonJS({
  "../node_modules/es5-ext/function/is-function.js"(exports2, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
    module2.exports = function(value) {
      return typeof value === "function" && isFunctionStringTag(objToString.call(value));
    };
  }
});

// ../node_modules/es5-ext/math/sign/is-implemented.js
var require_is_implemented7 = __commonJS({
  "../node_modules/es5-ext/math/sign/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var sign = Math.sign;
      if (typeof sign !== "function")
        return false;
      return sign(10) === 1 && sign(-20) === -1;
    };
  }
});

// ../node_modules/es5-ext/math/sign/shim.js
var require_shim4 = __commonJS({
  "../node_modules/es5-ext/math/sign/shim.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      value = Number(value);
      if (isNaN(value) || value === 0)
        return value;
      return value > 0 ? 1 : -1;
    };
  }
});

// ../node_modules/es5-ext/math/sign/index.js
var require_sign = __commonJS({
  "../node_modules/es5-ext/math/sign/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented7()() ? Math.sign : require_shim4();
  }
});

// ../node_modules/es5-ext/number/to-integer.js
var require_to_integer = __commonJS({
  "../node_modules/es5-ext/number/to-integer.js"(exports2, module2) {
    "use strict";
    var sign = require_sign();
    var abs = Math.abs;
    var floor = Math.floor;
    module2.exports = function(value) {
      if (isNaN(value))
        return 0;
      value = Number(value);
      if (value === 0 || !isFinite(value))
        return value;
      return sign(value) * floor(abs(value));
    };
  }
});

// ../node_modules/es5-ext/number/to-pos-integer.js
var require_to_pos_integer = __commonJS({
  "../node_modules/es5-ext/number/to-pos-integer.js"(exports2, module2) {
    "use strict";
    var toInteger = require_to_integer();
    var max = Math.max;
    module2.exports = function(value) {
      return max(0, toInteger(value));
    };
  }
});

// ../node_modules/es5-ext/object/valid-callable.js
var require_valid_callable = __commonJS({
  "../node_modules/es5-ext/object/valid-callable.js"(exports2, module2) {
    "use strict";
    module2.exports = function(fn) {
      if (typeof fn !== "function")
        throw new TypeError(fn + " is not a function");
      return fn;
    };
  }
});

// ../node_modules/es5-ext/string/is-string.js
var require_is_string = __commonJS({
  "../node_modules/es5-ext/string/is-string.js"(exports2, module2) {
    "use strict";
    var objToString = Object.prototype.toString;
    var id = objToString.call("");
    module2.exports = function(value) {
      return typeof value === "string" || value && typeof value === "object" && (value instanceof String || objToString.call(value) === id) || false;
    };
  }
});

// ../node_modules/es5-ext/array/from/shim.js
var require_shim5 = __commonJS({
  "../node_modules/es5-ext/array/from/shim.js"(exports2, module2) {
    "use strict";
    var iteratorSymbol = require_es6_symbol().iterator;
    var isArguments = require_is_arguments();
    var isFunction = require_is_function();
    var toPosInt = require_to_pos_integer();
    var callable = require_valid_callable();
    var validValue = require_valid_value();
    var isValue = require_is_value();
    var isString = require_is_string();
    var isArray = Array.isArray;
    var call = Function.prototype.call;
    var desc = { configurable: true, enumerable: true, writable: true, value: null };
    var defineProperty = Object.defineProperty;
    module2.exports = function(arrayLike) {
      var mapFn = arguments[1], thisArg = arguments[2], Context, i, j, arr, length, code, iterator, result, getIterator, value;
      arrayLike = Object(validValue(arrayLike));
      if (isValue(mapFn))
        callable(mapFn);
      if (!this || this === Array || !isFunction(this)) {
        if (!mapFn) {
          if (isArguments(arrayLike)) {
            length = arrayLike.length;
            if (length !== 1)
              return Array.apply(null, arrayLike);
            arr = new Array(1);
            arr[0] = arrayLike[0];
            return arr;
          }
          if (isArray(arrayLike)) {
            arr = new Array(length = arrayLike.length);
            for (i = 0; i < length; ++i)
              arr[i] = arrayLike[i];
            return arr;
          }
        }
        arr = [];
      } else {
        Context = this;
      }
      if (!isArray(arrayLike)) {
        if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
          iterator = callable(getIterator).call(arrayLike);
          if (Context)
            arr = new Context();
          result = iterator.next();
          i = 0;
          while (!result.done) {
            value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, i, desc);
            } else {
              arr[i] = value;
            }
            result = iterator.next();
            ++i;
          }
          length = i;
        } else if (isString(arrayLike)) {
          length = arrayLike.length;
          if (Context)
            arr = new Context();
          for (i = 0, j = 0; i < length; ++i) {
            value = arrayLike[i];
            if (i + 1 < length) {
              code = value.charCodeAt(0);
              if (code >= 55296 && code <= 56319)
                value += arrayLike[++i];
            }
            value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
            if (Context) {
              desc.value = value;
              defineProperty(arr, j, desc);
            } else {
              arr[j] = value;
            }
            ++j;
          }
          length = j;
        }
      }
      if (length === void 0) {
        length = toPosInt(arrayLike.length);
        if (Context)
          arr = new Context(length);
        for (i = 0; i < length; ++i) {
          value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
          if (Context) {
            desc.value = value;
            defineProperty(arr, i, desc);
          } else {
            arr[i] = value;
          }
        }
      }
      if (Context) {
        desc.value = null;
        arr.length = length;
      }
      return arr;
    };
  }
});

// ../node_modules/es5-ext/array/from/index.js
var require_from = __commonJS({
  "../node_modules/es5-ext/array/from/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented()() ? Array.from : require_shim5();
  }
});

// ../node_modules/es5-ext/object/set-prototype-of/is-implemented.js
var require_is_implemented8 = __commonJS({
  "../node_modules/es5-ext/object/set-prototype-of/is-implemented.js"(exports2, module2) {
    "use strict";
    var create = Object.create;
    var getPrototypeOf = Object.getPrototypeOf;
    var plainObject = {};
    module2.exports = function() {
      var setPrototypeOf = Object.setPrototypeOf, customCreate = arguments[0] || create;
      if (typeof setPrototypeOf !== "function")
        return false;
      return getPrototypeOf(setPrototypeOf(customCreate(null), plainObject)) === plainObject;
    };
  }
});

// ../node_modules/es5-ext/object/create.js
var require_create = __commonJS({
  "../node_modules/es5-ext/object/create.js"(exports2, module2) {
    "use strict";
    var create = Object.create;
    var shim;
    if (!require_is_implemented8()()) {
      shim = require_shim6();
    }
    module2.exports = function() {
      var nullObject, polyProps, desc;
      if (!shim)
        return create;
      if (shim.level !== 1)
        return create;
      nullObject = {};
      polyProps = {};
      desc = { configurable: false, enumerable: false, writable: true, value: void 0 };
      Object.getOwnPropertyNames(Object.prototype).forEach(function(name) {
        if (name === "__proto__") {
          polyProps[name] = {
            configurable: true,
            enumerable: false,
            writable: true,
            value: void 0
          };
          return;
        }
        polyProps[name] = desc;
      });
      Object.defineProperties(nullObject, polyProps);
      Object.defineProperty(shim, "nullPolyfill", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: nullObject
      });
      return function(prototype, props) {
        return create(prototype === null ? nullObject : prototype, props);
      };
    }();
  }
});

// ../node_modules/es5-ext/object/set-prototype-of/shim.js
var require_shim6 = __commonJS({
  "../node_modules/es5-ext/object/set-prototype-of/shim.js"(exports2, module2) {
    "use strict";
    var isObject = require_is_object();
    var value = require_valid_value();
    var objIsPrototypeOf = Object.prototype.isPrototypeOf;
    var defineProperty = Object.defineProperty;
    var nullDesc = { configurable: true, enumerable: false, writable: true, value: void 0 };
    var validate;
    validate = function(obj, prototype) {
      value(obj);
      if (prototype === null || isObject(prototype))
        return obj;
      throw new TypeError("Prototype must be null or an object");
    };
    module2.exports = function(status) {
      var fn, set;
      if (!status)
        return null;
      if (status.level === 2) {
        if (status.set) {
          set = status.set;
          fn = function(obj, prototype) {
            set.call(validate(obj, prototype), prototype);
            return obj;
          };
        } else {
          fn = function(obj, prototype) {
            validate(obj, prototype).__proto__ = prototype;
            return obj;
          };
        }
      } else {
        fn = function self2(obj, prototype) {
          var isNullBase;
          validate(obj, prototype);
          isNullBase = objIsPrototypeOf.call(self2.nullPolyfill, obj);
          if (isNullBase)
            delete self2.nullPolyfill.__proto__;
          if (prototype === null)
            prototype = self2.nullPolyfill;
          obj.__proto__ = prototype;
          if (isNullBase)
            defineProperty(self2.nullPolyfill, "__proto__", nullDesc);
          return obj;
        };
      }
      return Object.defineProperty(fn, "level", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: status.level
      });
    }(function() {
      var tmpObj1 = Object.create(null), tmpObj2 = {}, set, desc = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
      if (desc) {
        try {
          set = desc.set;
          set.call(tmpObj1, tmpObj2);
        } catch (ignore) {
        }
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
          return { set, level: 2 };
      }
      tmpObj1.__proto__ = tmpObj2;
      if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
        return { level: 2 };
      tmpObj1 = {};
      tmpObj1.__proto__ = tmpObj2;
      if (Object.getPrototypeOf(tmpObj1) === tmpObj2)
        return { level: 1 };
      return false;
    }());
    require_create();
  }
});

// ../node_modules/es5-ext/object/set-prototype-of/index.js
var require_set_prototype_of = __commonJS({
  "../node_modules/es5-ext/object/set-prototype-of/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented8()() ? Object.setPrototypeOf : require_shim6();
  }
});

// ../node_modules/d/node_modules/type/string/coerce.js
var require_coerce2 = __commonJS({
  "../node_modules/d/node_modules/type/string/coerce.js"(exports2, module2) {
    "use strict";
    var isValue = require_is3();
    var isObject = require_is4();
    var objectToString = Object.prototype.toString;
    module2.exports = function(value) {
      if (!isValue(value))
        return null;
      if (isObject(value)) {
        var valueToString = value.toString;
        if (typeof valueToString !== "function")
          return null;
        if (valueToString === objectToString)
          return null;
      }
      try {
        return "" + value;
      } catch (error) {
        return null;
      }
    };
  }
});

// ../node_modules/d/node_modules/type/lib/safe-to-string.js
var require_safe_to_string2 = __commonJS({
  "../node_modules/d/node_modules/type/lib/safe-to-string.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      try {
        return value.toString();
      } catch (error) {
        try {
          return String(value);
        } catch (error2) {
          return null;
        }
      }
    };
  }
});

// ../node_modules/d/node_modules/type/lib/to-short-string.js
var require_to_short_string2 = __commonJS({
  "../node_modules/d/node_modules/type/lib/to-short-string.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string2();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string === null)
        return "<Non-coercible to string value>";
      if (string.length > 100)
        string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        switch (char) {
          case "\n":
            return "\\n";
          case "\r":
            return "\\r";
          case "\u2028":
            return "\\u2028";
          case "\u2029":
            return "\\u2029";
          default:
            throw new Error("Unexpected character");
        }
      });
      return string;
    };
  }
});

// ../node_modules/d/node_modules/type/lib/resolve-exception.js
var require_resolve_exception2 = __commonJS({
  "../node_modules/d/node_modules/type/lib/resolve-exception.js"(exports2, module2) {
    "use strict";
    var isValue = require_is3();
    var isObject = require_is4();
    var stringCoerce = require_coerce2();
    var toShortString = require_to_short_string2();
    var resolveMessage = function(message, value) {
      return message.replace("%v", toShortString(value));
    };
    module2.exports = function(value, defaultMessage, inputOptions) {
      if (!isObject(inputOptions))
        throw new TypeError(resolveMessage(defaultMessage, value));
      if (!isValue(value)) {
        if ("default" in inputOptions)
          return inputOptions["default"];
        if (inputOptions.isOptional)
          return null;
      }
      var errorMessage = stringCoerce(inputOptions.errorMessage);
      if (!isValue(errorMessage))
        errorMessage = defaultMessage;
      throw new TypeError(resolveMessage(errorMessage, value));
    };
  }
});

// ../node_modules/d/node_modules/type/value/ensure.js
var require_ensure2 = __commonJS({
  "../node_modules/d/node_modules/type/value/ensure.js"(exports2, module2) {
    "use strict";
    var resolveException = require_resolve_exception2();
    var is = require_is3();
    module2.exports = function(value) {
      if (is(value))
        return value;
      return resolveException(value, "Cannot use %v", arguments[1]);
    };
  }
});

// ../node_modules/es5-ext/object/_iterate.js
var require_iterate = __commonJS({
  "../node_modules/es5-ext/object/_iterate.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    var value = require_valid_value();
    var bind = Function.prototype.bind;
    var call = Function.prototype.call;
    var keys = Object.keys;
    var objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
    module2.exports = function(method, defVal) {
      return function(obj, cb) {
        var list, thisArg = arguments[2], compareFn = arguments[3];
        obj = Object(value(obj));
        callable(cb);
        list = keys(obj);
        if (compareFn) {
          list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
        }
        if (typeof method !== "function")
          method = list[method];
        return call.call(method, list, function(key, index) {
          if (!objPropertyIsEnumerable.call(obj, key))
            return defVal;
          return call.call(cb, thisArg, obj[key], key, obj, index);
        });
      };
    };
  }
});

// ../node_modules/es5-ext/object/for-each.js
var require_for_each = __commonJS({
  "../node_modules/es5-ext/object/for-each.js"(exports2, module2) {
    "use strict";
    module2.exports = require_iterate()("forEach");
  }
});

// ../node_modules/es5-ext/object/map.js
var require_map = __commonJS({
  "../node_modules/es5-ext/object/map.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    var forEach = require_for_each();
    var call = Function.prototype.call;
    module2.exports = function(obj, cb) {
      var result = {}, thisArg = arguments[2];
      callable(cb);
      forEach(obj, function(value, key, targetObj, index) {
        result[key] = call.call(cb, thisArg, value, key, targetObj, index);
      });
      return result;
    };
  }
});

// ../node_modules/d/lazy.js
var require_lazy = __commonJS({
  "../node_modules/d/lazy.js"(exports2, module2) {
    "use strict";
    var isPlainFunction = require_is7();
    var ensureValue = require_ensure2();
    var isValue = require_is3();
    var map = require_map();
    var contains = require_contains();
    var call = Function.prototype.call;
    var defineProperty = Object.defineProperty;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var cacheDesc = { configurable: false, enumerable: false, writable: false, value: null };
    var define2;
    define2 = function(name, options) {
      var value, dgs, cacheName, desc, writable = false, resolvable, flat;
      options = Object(ensureValue(options));
      cacheName = options.cacheName;
      flat = options.flat;
      if (!isValue(cacheName))
        cacheName = name;
      delete options.cacheName;
      value = options.value;
      resolvable = isPlainFunction(value);
      delete options.value;
      dgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };
      if (name !== cacheName) {
        dgs.get = function() {
          if (hasOwnProperty2.call(this, cacheName))
            return this[cacheName];
          cacheDesc.value = resolvable ? call.call(value, this, options) : value;
          cacheDesc.writable = writable;
          defineProperty(this, cacheName, cacheDesc);
          cacheDesc.value = null;
          if (desc)
            defineProperty(this, name, desc);
          return this[cacheName];
        };
      } else if (!flat) {
        dgs.get = function self2() {
          var ownDesc;
          if (hasOwnProperty2.call(this, name)) {
            ownDesc = getOwnPropertyDescriptor(this, name);
            if (ownDesc) {
              if (ownDesc.hasOwnProperty("value"))
                return ownDesc.value;
              if (typeof ownDesc.get === "function" && ownDesc.get !== self2) {
                return ownDesc.get.call(this);
              }
              return value;
            }
          }
          desc.value = resolvable ? call.call(value, this, options) : value;
          defineProperty(this, name, desc);
          desc.value = null;
          return this[name];
        };
      } else {
        dgs.get = function self2() {
          var base = this, ownDesc;
          if (hasOwnProperty2.call(this, name)) {
            ownDesc = getOwnPropertyDescriptor(this, name);
            if (ownDesc.hasOwnProperty("value"))
              return ownDesc.value;
            if (typeof ownDesc.get === "function" && ownDesc.get !== self2) {
              return ownDesc.get.call(this);
            }
          }
          while (!hasOwnProperty2.call(base, name))
            base = getPrototypeOf(base);
          desc.value = resolvable ? call.call(value, base, options) : value;
          defineProperty(base, name, desc);
          desc.value = null;
          return base[name];
        };
      }
      dgs.set = function(value2) {
        if (hasOwnProperty2.call(this, name)) {
          throw new TypeError("Cannot assign to lazy defined '" + name + "' property of " + this);
        }
        dgs.get.call(this);
        this[cacheName] = value2;
      };
      if (options.desc) {
        desc = {
          configurable: contains.call(options.desc, "c"),
          enumerable: contains.call(options.desc, "e")
        };
        if (cacheName === name) {
          desc.writable = contains.call(options.desc, "w");
          desc.value = null;
        } else {
          writable = contains.call(options.desc, "w");
          desc.get = dgs.get;
          desc.set = dgs.set;
        }
        delete options.desc;
      } else if (cacheName === name) {
        desc = {
          configurable: Boolean(options.configurable),
          enumerable: Boolean(options.enumerable),
          writable: Boolean(options.writable),
          value: null
        };
      }
      delete options.configurable;
      delete options.enumerable;
      delete options.writable;
      return dgs;
    };
    module2.exports = function(props) {
      return map(props, function(desc, name) {
        return define2(name, desc);
      });
    };
  }
});

// ../node_modules/log/levels.json
var require_levels = __commonJS({
  "../node_modules/log/levels.json"(exports2, module2) {
    module2.exports = ["error", "warning", "notice", "info", "debug"];
  }
});

// ../node_modules/uni-global/lib/es-env-type.js
var require_es_env_type = __commonJS({
  "../node_modules/uni-global/lib/es-env-type.js"(exports2, module2) {
    "use strict";
    if (!Object.defineProperty || !Object.create)
      module2.exports = "3";
    else if (typeof Symbol === "function" && Symbol["for"])
      module2.exports = "2015+";
    else
      module2.exports = "5";
  }
});

// ../node_modules/uni-global/lib/uni-global.js
var require_uni_global = __commonJS({
  "../node_modules/uni-global/lib/uni-global.js"(exports2, module2) {
    "use strict";
    var esEnvType = require_es_env_type();
    switch (esEnvType) {
      case "3":
        if (EvalError.$ug202109) {
          module2.exports = EvalError.$ug202109;
          return;
        }
        module2.exports = EvalError.$ug202109 = {};
        return;
      case "5":
        if (EvalError.$uniGlobal202109) {
          module2.exports = EvalError.$uniGlobal202109;
          return;
        }
        Object.defineProperty(EvalError, "$uniGlobal202109", {
          value: module2.exports = Object.create(null)
        });
        return;
      case "2015+":
        uniGlobalSymbol = Symbol["for"]("$uniGlobal202109");
        if (EvalError[uniGlobalSymbol]) {
          module2.exports = EvalError[uniGlobalSymbol];
          return;
        }
        Object.defineProperty(EvalError, uniGlobalSymbol, {
          value: module2.exports = Object.create(null)
        });
        return;
      default:
        throw new Error("Unrecognized environment type: " + esEnvType);
    }
    var uniGlobalSymbol;
  }
});

// ../node_modules/uni-global/index.js
var require_uni_global2 = __commonJS({
  "../node_modules/uni-global/index.js"(exports2, module2) {
    "use strict";
    var ensureString = require_ensure();
    var uniGlobal = require_uni_global();
    var objHasOwnProperty = Object.prototype.hasOwnProperty;
    module2.exports = function(key) {
      key = ensureString(key, { name: "key" });
      if (objHasOwnProperty.call(uniGlobal, key))
        return uniGlobal[key];
      var value = Object.create ? Object.create(null) : {};
      uniGlobal[key] = value;
      return value;
    };
  }
});

// ../node_modules/event-emitter/index.js
var require_event_emitter = __commonJS({
  "../node_modules/event-emitter/index.js"(exports2, module2) {
    "use strict";
    var d = require_d();
    var callable = require_valid_callable();
    var apply = Function.prototype.apply;
    var call = Function.prototype.call;
    var create = Object.create;
    var defineProperty = Object.defineProperty;
    var defineProperties = Object.defineProperties;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var descriptor = { configurable: true, enumerable: false, writable: true };
    var on;
    var once;
    var off;
    var emit;
    var methods;
    var descriptors;
    var base;
    on = function(type, listener) {
      var data;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__")) {
        data = descriptor.value = create(null);
        defineProperty(this, "__ee__", descriptor);
        descriptor.value = null;
      } else {
        data = this.__ee__;
      }
      if (!data[type])
        data[type] = listener;
      else if (typeof data[type] === "object")
        data[type].push(listener);
      else
        data[type] = [data[type], listener];
      return this;
    };
    once = function(type, listener) {
      var once2, self2;
      callable(listener);
      self2 = this;
      on.call(this, type, once2 = function() {
        off.call(self2, type, once2);
        apply.call(listener, this, arguments);
      });
      once2.__eeOnceListener__ = listener;
      return this;
    };
    off = function(type, listener) {
      var data, listeners, candidate, i;
      callable(listener);
      if (!hasOwnProperty2.call(this, "__ee__"))
        return this;
      data = this.__ee__;
      if (!data[type])
        return this;
      listeners = data[type];
      if (typeof listeners === "object") {
        for (i = 0; candidate = listeners[i]; ++i) {
          if (candidate === listener || candidate.__eeOnceListener__ === listener) {
            if (listeners.length === 2)
              data[type] = listeners[i ? 0 : 1];
            else
              listeners.splice(i, 1);
          }
        }
      } else {
        if (listeners === listener || listeners.__eeOnceListener__ === listener) {
          delete data[type];
        }
      }
      return this;
    };
    emit = function(type) {
      var i, l, listener, listeners, args;
      if (!hasOwnProperty2.call(this, "__ee__"))
        return;
      listeners = this.__ee__[type];
      if (!listeners)
        return;
      if (typeof listeners === "object") {
        l = arguments.length;
        args = new Array(l - 1);
        for (i = 1; i < l; ++i)
          args[i - 1] = arguments[i];
        listeners = listeners.slice();
        for (i = 0; listener = listeners[i]; ++i) {
          apply.call(listener, this, args);
        }
      } else {
        switch (arguments.length) {
          case 1:
            call.call(listeners, this);
            break;
          case 2:
            call.call(listeners, this, arguments[1]);
            break;
          case 3:
            call.call(listeners, this, arguments[1], arguments[2]);
            break;
          default:
            l = arguments.length;
            args = new Array(l - 1);
            for (i = 1; i < l; ++i) {
              args[i - 1] = arguments[i];
            }
            apply.call(listeners, this, args);
        }
      }
    };
    methods = {
      on,
      once,
      off,
      emit
    };
    descriptors = {
      on: d(on),
      once: d(once),
      off: d(off),
      emit: d(emit)
    };
    base = defineProperties({}, descriptors);
    module2.exports = exports2 = function(o) {
      return o == null ? create(base) : defineProperties(Object(o), descriptors);
    };
    exports2.methods = methods;
  }
});

// ../node_modules/log/lib/emitter.js
var require_emitter = __commonJS({
  "../node_modules/log/lib/emitter.js"(exports2, module2) {
    "use strict";
    var uniGlobal = require_uni_global2()("medikoo/log/202110");
    if (uniGlobal.emitter) {
      module2.exports = uniGlobal.emitter;
      return;
    }
    var ee = require_event_emitter();
    module2.exports = uniGlobal.emitter = ee();
  }
});

// ../node_modules/log/lib/private/logger-prototype/enable-disable-props.js
var require_enable_disable_props = __commonJS({
  "../node_modules/log/lib/private/logger-prototype/enable-disable-props.js"(exports2, module2) {
    "use strict";
    var noop = require_noop();
    var objForEach = require_for_each();
    var d = require_d();
    module2.exports = {
      isEnabled: d("ew", true),
      enable: d(function() {
        return this._setEnabledState(true);
      }),
      disable: d(function() {
        return this._setEnabledState(false);
      }),
      _setEnabledState: d(function(state) {
        var cache = [];
        this._setEnabledStateRecursively(state, cache);
        var result = {
          restore: function() {
            cache.forEach(function(data) {
              if (data.hasDirectSetting)
                data.logger.isEnabled = !state;
              else
                delete data.logger.isEnabled;
            });
            result.restore = noop;
          }
        };
        return result;
      }),
      _setEnabledStateRecursively: d(function(newState, cache) {
        if (this.isEnabled !== newState) {
          cache.push({ logger: this, hasDirectSetting: hasOwnProperty.call(this, "isEnabled") });
          this.isEnabled = newState;
        }
        objForEach(this._childNamespaceLoggers, function(namespacedLogger) {
          namespacedLogger._setEnabledStateRecursively(newState, cache);
        });
      })
    };
  }
});

// ../node_modules/es5-ext/function/identity.js
var require_identity = __commonJS({
  "../node_modules/es5-ext/function/identity.js"(exports2, module2) {
    "use strict";
    module2.exports = function(value) {
      return value;
    };
  }
});

// ../node_modules/es5-ext/object/to-array.js
var require_to_array = __commonJS({
  "../node_modules/es5-ext/object/to-array.js"(exports2, module2) {
    "use strict";
    var callable = require_valid_callable();
    var isValue = require_is_value();
    var forEach = require_for_each();
    var call = Function.prototype.call;
    var defaultCb = function(value, key) {
      return [key, value];
    };
    module2.exports = function(obj) {
      var a = [], cb = arguments[1], thisArg = arguments[2];
      cb = isValue(cb) ? callable(cb) : defaultCb;
      forEach(obj, function(value, key, targetObj, index) {
        a.push(call.call(cb, thisArg, value, key, this, index));
      }, obj, arguments[3]);
      return a;
    };
  }
});

// ../node_modules/log/lib/private/is-namespace-token.js
var require_is_namespace_token = __commonJS({
  "../node_modules/log/lib/private/is-namespace-token.js"(exports2, module2) {
    "use strict";
    module2.exports = RegExp.prototype.test.bind(/^[a-z0-9-]+$/);
  }
});

// ../node_modules/log/lib/private/logger-prototype/namespace-props.js
var require_namespace_props = __commonJS({
  "../node_modules/log/lib/private/logger-prototype/namespace-props.js"(exports2, module2) {
    "use strict";
    var ensureString = require_ensure();
    var toShortString = require_to_short_string();
    var identity = require_identity();
    var assign = require_assign();
    var objToArray = require_to_array();
    var d = require_d();
    var lazy = require_lazy();
    var emitter = require_emitter();
    var isNamespaceToken = require_is_namespace_token();
    module2.exports = assign({
      get: d(function(namespace) {
        namespace = ensureString(namespace);
        var namespaceTokens = namespace.split(":");
        namespaceTokens.forEach(function(namespaceToken) {
          if (!isNamespaceToken(namespaceToken)) {
            throw new TypeError(toShortString(namespace) + " is not a valid namespace string (only 'a-z0-9-' chars are allowed and ':' as delimiter)");
          }
        });
        return namespaceTokens.reduce(function(currentLogger, token) {
          return currentLogger._createNamespace(token);
        }, this);
      }),
      isNamespaceInitialized: d("e", function(namespace) {
        var namespaceTokens = ensureString(namespace).split(":");
        var currentLogger = this;
        return namespaceTokens.every(function(nsToken) {
          return currentLogger = currentLogger._childNamespaceLoggers[nsToken];
        });
      }),
      getAllInitializedNamespaces: d("e", function() {
        return objToArray(this._childNamespaceLoggers, identity);
      }),
      _createNamespace: d(function(namespaceToken) {
        if (this._childNamespaceLoggers[namespaceToken]) {
          return this._childNamespaceLoggers[namespaceToken];
        }
        var logger = Object.defineProperties(this._createLogger(), {
          _namespaceToken: d("", namespaceToken)
        });
        this._childNamespaceLoggers[namespaceToken] = logger;
        emitter.emit("init", { logger });
        return logger;
      }),
      _namespaceToken: d("", null)
    }, lazy({
      namespace: d("e", function() {
        return this.namespaceTokens.join(":") || null;
      }, {
        cacheName: "_namespace"
      }),
      namespaceTokens: d("e", function() {
        return this._namespaceToken ? Object.getPrototypeOf(this).namespaceTokens.concat(this._namespaceToken) : [];
      }, { cacheName: "_namespaceTokens" }),
      _childNamespaceLoggers: d("", function() {
        return Object.create(null);
      }, {
        cacheName: "__childNamespaceLoggers"
      })
    }));
  }
});

// ../node_modules/log/lib/private/logger-prototype/index.js
var require_logger_prototype = __commonJS({
  "../node_modules/log/lib/private/logger-prototype/index.js"(exports2, module2) {
    "use strict";
    var ensureString = require_ensure();
    var aFrom = require_from();
    var assign = require_assign();
    var setPrototypeOf = require_set_prototype_of();
    var d = require_d();
    var lazy = require_lazy();
    var levelNames = require_levels();
    var emitter = require_emitter();
    var enableDisableProps = require_enable_disable_props();
    var namespaceProps = require_namespace_props();
    var levelLoggers = Object.create(null);
    var loggerPrototype = Object.create(Function.prototype, assign({
      isLevelInitialized: d("e", function(level) {
        level = ensureString(level);
        if (this.level === level)
          return true;
        var logger = levelLoggers[level];
        if (!logger)
          return false;
        if (!this.namespace)
          return true;
        return logger.isNamespaceInitialized(this.namespace);
      }),
      getAllInitializedLevels: d("e", function() {
        return Object.keys(levelLoggers).filter(function(level) {
          return this.isLevelInitialized(level);
        }, this).map(function(level) {
          return this._getLevelLogger(level);
        }, this);
      }),
      _createLogger: d(function() {
        return setPrototypeOf(function self2(msgItemIgnored) {
          emitter.emit("log", { logger: self2, messageTokens: aFrom(arguments) });
        }, this);
      }),
      _createLevel: d(function(levelName) {
        if (levelLoggers[levelName])
          return levelLoggers[levelName];
        var logger = loggerPrototype._createLogger();
        Object.defineProperties(logger, {
          level: d("e", levelName),
          levelIndex: d("e", levelNames.indexOf(levelName)),
          levelRoot: d("e", logger)
        });
        levelLoggers[levelName] = logger;
        emitter.emit("init", { logger });
        return logger;
      }),
      _getLevelLogger: d(function(newLevel) {
        if (this.level === newLevel)
          return this;
        var levelLogger = this._createLevel(newLevel);
        return this.namespaceTokens.reduce(function(currentLogger, token) {
          return currentLogger._createNamespace(token);
        }, levelLogger);
      })
    }, lazy(assign(levelNames.reduce(function(descriptors, level) {
      descriptors[level] = d("e", function() {
        return this._getLevelLogger(level);
      }, { cacheName: "_" + level });
      return descriptors;
    }, {}), {
      warn: d(function() {
        return this._getLevelLogger("warning");
      }, {
        cacheName: "_warning"
      })
    })), namespaceProps, enableDisableProps));
    module2.exports = loggerPrototype;
  }
});

// ../node_modules/log/index.js
var require_log = __commonJS({
  "../node_modules/log/index.js"(exports2, module2) {
    "use strict";
    var loggerPrototype = require_logger_prototype();
    module2.exports = loggerPrototype._createLevel("info");
  }
});

// ../node_modules/nice-try/src/index.js
var require_src = __commonJS({
  "../node_modules/nice-try/src/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(fn) {
      try {
        return fn();
      } catch (e) {
      }
    };
  }
});

// ../node_modules/isexe/windows.js
var require_windows = __commonJS({
  "../node_modules/isexe/windows.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function checkPathExt(path, options) {
      var pathext = options.pathExt !== void 0 ? options.pathExt : process.env.PATHEXT;
      if (!pathext) {
        return true;
      }
      pathext = pathext.split(";");
      if (pathext.indexOf("") !== -1) {
        return true;
      }
      for (var i = 0; i < pathext.length; i++) {
        var p = pathext[i].toLowerCase();
        if (p && path.substr(-p.length).toLowerCase() === p) {
          return true;
        }
      }
      return false;
    }
    function checkStat(stat, path, options) {
      if (!stat.isSymbolicLink() && !stat.isFile()) {
        return false;
      }
      return checkPathExt(path, options);
    }
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, path, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), path, options);
    }
  }
});

// ../node_modules/isexe/mode.js
var require_mode = __commonJS({
  "../node_modules/isexe/mode.js"(exports2, module2) {
    module2.exports = isexe;
    isexe.sync = sync;
    var fs = require("fs");
    function isexe(path, options, cb) {
      fs.stat(path, function(er, stat) {
        cb(er, er ? false : checkStat(stat, options));
      });
    }
    function sync(path, options) {
      return checkStat(fs.statSync(path), options);
    }
    function checkStat(stat, options) {
      return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
      var mod = stat.mode;
      var uid = stat.uid;
      var gid = stat.gid;
      var myUid = options.uid !== void 0 ? options.uid : process.getuid && process.getuid();
      var myGid = options.gid !== void 0 ? options.gid : process.getgid && process.getgid();
      var u = parseInt("100", 8);
      var g = parseInt("010", 8);
      var o = parseInt("001", 8);
      var ug = u | g;
      var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
      return ret;
    }
  }
});

// ../node_modules/isexe/index.js
var require_isexe = __commonJS({
  "../node_modules/isexe/index.js"(exports2, module2) {
    var fs = require("fs");
    var core;
    if (process.platform === "win32" || global.TESTING_WINDOWS) {
      core = require_windows();
    } else {
      core = require_mode();
    }
    module2.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      if (!cb) {
        if (typeof Promise !== "function") {
          throw new TypeError("callback not provided");
        }
        return new Promise(function(resolve2, reject2) {
          isexe(path, options || {}, function(er, is) {
            if (er) {
              reject2(er);
            } else {
              resolve2(is);
            }
          });
        });
      }
      core(path, options || {}, function(er, is) {
        if (er) {
          if (er.code === "EACCES" || options && options.ignoreErrors) {
            er = null;
            is = false;
          }
        }
        cb(er, is);
      });
    }
    function sync(path, options) {
      try {
        return core.sync(path, options || {});
      } catch (er) {
        if (options && options.ignoreErrors || er.code === "EACCES") {
          return false;
        } else {
          throw er;
        }
      }
    }
  }
});

// ../node_modules/which/which.js
var require_which = __commonJS({
  "../node_modules/which/which.js"(exports2, module2) {
    module2.exports = which;
    which.sync = whichSync;
    var isWindows = process.platform === "win32" || process.env.OSTYPE === "cygwin" || process.env.OSTYPE === "msys";
    var path = require("path");
    var COLON = isWindows ? ";" : ":";
    var isexe = require_isexe();
    function getNotFoundError(cmd) {
      var er = new Error("not found: " + cmd);
      er.code = "ENOENT";
      return er;
    }
    function getPathInfo(cmd, opt) {
      var colon = opt.colon || COLON;
      var pathEnv = opt.path || process.env.PATH || "";
      var pathExt = [""];
      pathEnv = pathEnv.split(colon);
      var pathExtExe = "";
      if (isWindows) {
        pathEnv.unshift(process.cwd());
        pathExtExe = opt.pathExt || process.env.PATHEXT || ".EXE;.CMD;.BAT;.COM";
        pathExt = pathExtExe.split(colon);
        if (cmd.indexOf(".") !== -1 && pathExt[0] !== "")
          pathExt.unshift("");
      }
      if (cmd.match(/\//) || isWindows && cmd.match(/\\/))
        pathEnv = [""];
      return {
        env: pathEnv,
        ext: pathExt,
        extExe: pathExtExe
      };
    }
    function which(cmd, opt, cb) {
      if (typeof opt === "function") {
        cb = opt;
        opt = {};
      }
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      (function F(i, l) {
        if (i === l) {
          if (opt.all && found.length)
            return cb(null, found);
          else
            return cb(getNotFoundError(cmd));
        }
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        ;
        (function E(ii, ll) {
          if (ii === ll)
            return F(i + 1, l);
          var ext = pathExt[ii];
          isexe(p + ext, { pathExt: pathExtExe }, function(er, is) {
            if (!er && is) {
              if (opt.all)
                found.push(p + ext);
              else
                return cb(null, p + ext);
            }
            return E(ii + 1, ll);
          });
        })(0, pathExt.length);
      })(0, pathEnv.length);
    }
    function whichSync(cmd, opt) {
      opt = opt || {};
      var info = getPathInfo(cmd, opt);
      var pathEnv = info.env;
      var pathExt = info.ext;
      var pathExtExe = info.extExe;
      var found = [];
      for (var i = 0, l = pathEnv.length; i < l; i++) {
        var pathPart = pathEnv[i];
        if (pathPart.charAt(0) === '"' && pathPart.slice(-1) === '"')
          pathPart = pathPart.slice(1, -1);
        var p = path.join(pathPart, cmd);
        if (!pathPart && /^\.[\\\/]/.test(cmd)) {
          p = cmd.slice(0, 2) + p;
        }
        for (var j = 0, ll = pathExt.length; j < ll; j++) {
          var cur = p + pathExt[j];
          var is;
          try {
            is = isexe.sync(cur, { pathExt: pathExtExe });
            if (is) {
              if (opt.all)
                found.push(cur);
              else
                return cur;
            }
          } catch (ex) {
          }
        }
      }
      if (opt.all && found.length)
        return found;
      if (opt.nothrow)
        return null;
      throw getNotFoundError(cmd);
    }
  }
});

// ../node_modules/path-key/index.js
var require_path_key = __commonJS({
  "../node_modules/path-key/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (opts) => {
      opts = opts || {};
      const env = opts.env || process.env;
      const platform = opts.platform || process.platform;
      if (platform !== "win32") {
        return "PATH";
      }
      return Object.keys(env).find((x) => x.toUpperCase() === "PATH") || "Path";
    };
  }
});

// ../node_modules/cross-spawn/lib/util/resolveCommand.js
var require_resolveCommand = __commonJS({
  "../node_modules/cross-spawn/lib/util/resolveCommand.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var which = require_which();
    var pathKey = require_path_key()();
    function resolveCommandAttempt(parsed, withoutPathExt) {
      const cwd = process.cwd();
      const hasCustomCwd = parsed.options.cwd != null;
      if (hasCustomCwd) {
        try {
          process.chdir(parsed.options.cwd);
        } catch (err) {
        }
      }
      let resolved;
      try {
        resolved = which.sync(parsed.command, {
          path: (parsed.options.env || process.env)[pathKey],
          pathExt: withoutPathExt ? path.delimiter : void 0
        });
      } catch (e) {
      } finally {
        process.chdir(cwd);
      }
      if (resolved) {
        resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : "", resolved);
      }
      return resolved;
    }
    function resolveCommand(parsed) {
      return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module2.exports = resolveCommand;
  }
});

// ../node_modules/cross-spawn/lib/util/escape.js
var require_escape = __commonJS({
  "../node_modules/cross-spawn/lib/util/escape.js"(exports2, module2) {
    "use strict";
    var metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
      arg = arg.replace(metaCharsRegExp, "^$1");
      return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
      arg = `${arg}`;
      arg = arg.replace(/(\\*)"/g, '$1$1\\"');
      arg = arg.replace(/(\\*)$/, "$1$1");
      arg = `"${arg}"`;
      arg = arg.replace(metaCharsRegExp, "^$1");
      if (doubleEscapeMetaChars) {
        arg = arg.replace(metaCharsRegExp, "^$1");
      }
      return arg;
    }
    module2.exports.command = escapeCommand;
    module2.exports.argument = escapeArgument;
  }
});

// ../node_modules/shebang-regex/index.js
var require_shebang_regex = __commonJS({
  "../node_modules/shebang-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /^#!.*/;
  }
});

// ../node_modules/shebang-command/index.js
var require_shebang_command = __commonJS({
  "../node_modules/shebang-command/index.js"(exports2, module2) {
    "use strict";
    var shebangRegex = require_shebang_regex();
    module2.exports = function(str) {
      var match = str.match(shebangRegex);
      if (!match) {
        return null;
      }
      var arr = match[0].replace(/#! ?/, "").split(" ");
      var bin = arr[0].split("/").pop();
      var arg = arr[1];
      return bin === "env" ? arg : bin + (arg ? " " + arg : "");
    };
  }
});

// ../node_modules/cross-spawn/lib/util/readShebang.js
var require_readShebang = __commonJS({
  "../node_modules/cross-spawn/lib/util/readShebang.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var shebangCommand = require_shebang_command();
    function readShebang(command) {
      const size = 150;
      let buffer;
      if (Buffer.alloc) {
        buffer = Buffer.alloc(size);
      } else {
        buffer = new Buffer(size);
        buffer.fill(0);
      }
      let fd;
      try {
        fd = fs.openSync(command, "r");
        fs.readSync(fd, buffer, 0, size, 0);
        fs.closeSync(fd);
      } catch (e) {
      }
      return shebangCommand(buffer.toString());
    }
    module2.exports = readShebang;
  }
});

// ../node_modules/semver/semver.js
var require_semver = __commonJS({
  "../node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var R = 0;
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[LOOSE] : re[FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[COMPARATORTRIM]);
      range = range.replace(re[TILDETRIM], tildeTrimReplace);
      range = range.replace(re[CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[TILDELOOSE] : re[TILDE];
      return comp.replace(r, function(_2, M, m, p, pr) {
        debug("tilde", comp, _2, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[CARETLOOSE] : re[CARET];
      return comp.replace(r, function(_2, M, m, p, pr) {
        debug("caret", comp, _2, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        version = new SemVer(version, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      var match = version.match(re[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../node_modules/cross-spawn/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/cross-spawn/lib/parse.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var niceTry = require_src();
    var resolveCommand = require_resolveCommand();
    var escape = require_escape();
    var readShebang = require_readShebang();
    var semver = require_semver();
    var isWin = process.platform === "win32";
    var isExecutableRegExp = /\.(?:com|exe)$/i;
    var isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    var supportsShellOption = niceTry(() => semver.satisfies(process.version, "^4.8.0 || ^5.7.0 || >= 6.0.0", true)) || false;
    function detectShebang(parsed) {
      parsed.file = resolveCommand(parsed);
      const shebang = parsed.file && readShebang(parsed.file);
      if (shebang) {
        parsed.args.unshift(parsed.file);
        parsed.command = shebang;
        return resolveCommand(parsed);
      }
      return parsed.file;
    }
    function parseNonShell(parsed) {
      if (!isWin) {
        return parsed;
      }
      const commandFile = detectShebang(parsed);
      const needsShell = !isExecutableRegExp.test(commandFile);
      if (parsed.options.forceShell || needsShell) {
        const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
        parsed.command = path.normalize(parsed.command);
        parsed.command = escape.command(parsed.command);
        parsed.args = parsed.args.map((arg) => escape.argument(arg, needsDoubleEscapeMetaChars));
        const shellCommand = [parsed.command].concat(parsed.args).join(" ");
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.command = process.env.comspec || "cmd.exe";
        parsed.options.windowsVerbatimArguments = true;
      }
      return parsed;
    }
    function parseShell(parsed) {
      if (supportsShellOption) {
        return parsed;
      }
      const shellCommand = [parsed.command].concat(parsed.args).join(" ");
      if (isWin) {
        parsed.command = typeof parsed.options.shell === "string" ? parsed.options.shell : process.env.comspec || "cmd.exe";
        parsed.args = ["/d", "/s", "/c", `"${shellCommand}"`];
        parsed.options.windowsVerbatimArguments = true;
      } else {
        if (typeof parsed.options.shell === "string") {
          parsed.command = parsed.options.shell;
        } else if (process.platform === "android") {
          parsed.command = "/system/bin/sh";
        } else {
          parsed.command = "/bin/sh";
        }
        parsed.args = ["-c", shellCommand];
      }
      return parsed;
    }
    function parse(command, args, options) {
      if (args && !Array.isArray(args)) {
        options = args;
        args = null;
      }
      args = args ? args.slice(0) : [];
      options = Object.assign({}, options);
      const parsed = {
        command,
        args,
        options,
        file: void 0,
        original: {
          command,
          args
        }
      };
      return options.shell ? parseShell(parsed) : parseNonShell(parsed);
    }
    module2.exports = parse;
  }
});

// ../node_modules/cross-spawn/lib/enoent.js
var require_enoent = __commonJS({
  "../node_modules/cross-spawn/lib/enoent.js"(exports2, module2) {
    "use strict";
    var isWin = process.platform === "win32";
    function notFoundError(original, syscall) {
      return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
        code: "ENOENT",
        errno: "ENOENT",
        syscall: `${syscall} ${original.command}`,
        path: original.command,
        spawnargs: original.args
      });
    }
    function hookChildProcess(cp, parsed) {
      if (!isWin) {
        return;
      }
      const originalEmit = cp.emit;
      cp.emit = function(name, arg1) {
        if (name === "exit") {
          const err = verifyENOENT(arg1, parsed, "spawn");
          if (err) {
            return originalEmit.call(cp, "error", err);
          }
        }
        return originalEmit.apply(cp, arguments);
      };
    }
    function verifyENOENT(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawn");
      }
      return null;
    }
    function verifyENOENTSync(status, parsed) {
      if (isWin && status === 1 && !parsed.file) {
        return notFoundError(parsed.original, "spawnSync");
      }
      return null;
    }
    module2.exports = {
      hookChildProcess,
      verifyENOENT,
      verifyENOENTSync,
      notFoundError
    };
  }
});

// ../node_modules/cross-spawn/index.js
var require_cross_spawn = __commonJS({
  "../node_modules/cross-spawn/index.js"(exports2, module2) {
    "use strict";
    var cp = require("child_process");
    var parse = require_parse();
    var enoent = require_enoent();
    function spawn(command, args, options) {
      const parsed = parse(command, args, options);
      const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
      enoent.hookChildProcess(spawned, parsed);
      return spawned;
    }
    function spawnSync(command, args, options) {
      const parsed = parse(command, args, options);
      const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
      result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
      return result;
    }
    module2.exports = spawn;
    module2.exports.spawn = spawn;
    module2.exports.sync = spawnSync;
    module2.exports._parse = parse;
    module2.exports._enoent = enoent;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf = p.data;
            var nb = n > buf.length ? buf.length : n;
            buf.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_2, options) {
          return inspect(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList;
    }();
  }
});

// ../node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream2, err) {
      var rState = stream2._readableState;
      var wState = stream2._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream2.destroy(err);
      else
        stream2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// ../node_modules/readable-stream/errors.js
var require_errors = __commonJS({
  "../node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      class NodeError extends Base {
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      }
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
      return 'The value "' + value + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// ../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "../node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// ../node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream2, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream2, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream2, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream2, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        errorOrDestroy(stream2, er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        errorOrDestroy(stream2, er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream2.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream2, err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
          if (state.autoDestroy) {
            var rState = stream2._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream2.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// ../node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable2 = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// ../node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop() {
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function eos(stream2, opts, callback) {
      if (typeof opts === "function")
        return eos(stream2, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream2.readable;
      var writable = opts.writable || opts.writable !== false && stream2.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream2.writable)
          onfinish();
      };
      var writableEnded = stream2._writableState && stream2._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream2);
      };
      var readableEnded = stream2._readableState && stream2._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream2);
      };
      var onerror = function onerror2(err) {
        callback.call(stream2, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream2._readableState || !stream2._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
        if (writable && !writableEnded) {
          if (!stream2._writableState || !stream2._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream2, err);
        }
      };
      var onrequest = function onrequest2() {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req)
          onrequest();
        else
          stream2.on("request", onrequest);
      } else if (writable && !stream2._writableState) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      stream2.on("end", onend);
      stream2.on("finish", onfinish);
      if (opts.error !== false)
        stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req)
          stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("end", onend);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve2 = iter[kLastResolve];
      if (resolve2 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve2(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve2, reject2) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve2(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve2, reject2);
        }, reject2);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve2, reject2) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject2(_this[kError]);
              } else {
                resolve2(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve2, reject2) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject2(err);
            return;
          }
          resolve2(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream2) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream2,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream2._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve2, reject2) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve2(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve2;
            iterator[kLastReject] = reject2;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream2, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject2 = iterator[kLastReject];
          if (reject2 !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject2(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve2 = iterator[kLastResolve];
        if (resolve2 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve2(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream2.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// ../node_modules/readable-stream/lib/internal/streams/from.js
var require_from2 = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject2(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject2) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var ERR_INVALID_ARG_TYPE = require_errors().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable2, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator])
        iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator])
        iterator = iterable[Symbol.iterator]();
      else
        throw new ERR_INVALID_ARG_TYPE("iterable", ["Iterable"], iterable);
      var readable = new Readable2(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _ref = yield iterator.next(), value = _ref.value, done = _ref.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      return readable;
    }
    module2.exports = from;
  }
});

// ../node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable2;
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require("util");
    var debug;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function debug2() {
      };
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable2, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream2, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      enumerable: false,
      get: function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      debug("readableAddChunk", chunk);
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream2, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream2, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream2, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream2, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream2.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      debug("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream2);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream2);
        }
      }
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      debug("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream2);
      }
    }
    function emitReadable_(stream2) {
      var state = stream2._readableState;
      debug("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream2.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        var ret = dest.write(chunk);
        debug("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    Readable2.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable2.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      debug("resume", state.reading);
      if (!state.reading) {
        stream2.read(0);
      }
      state.resumeScheduled = false;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) {
        ;
      }
    }
    Readable2.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable2.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableBuffer", {
      enumerable: false,
      get: function get() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable2.prototype, "readableFlowing", {
      enumerable: false,
      get: function get() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable2._fromList = fromList;
    Object.defineProperty(Readable2.prototype, "readableLength", {
      enumerable: false,
      get: function get() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      debug("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      debug("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
        if (state.autoDestroy) {
          var wState = stream2._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream2.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable2.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from2();
        }
        return from(Readable2, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var _require$codes = require_errors().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream2._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream2.push(null);
    }
  }
});

// ../node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform();
    require_inherits()(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "../node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err)
        throw err;
    }
    function isRequest(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    }
    function destroyer(stream2, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream2.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream2, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream2))
          return stream2.abort();
        if (typeof stream2.destroy === "function")
          return stream2.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe(from, to) {
      return from.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop;
      if (typeof streams[streams.length - 1] !== "function")
        return noop;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream2, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    module2.exports = pipeline;
  }
});

// ../node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// ../node_modules/split2/index.js
var require_split2 = __commonJS({
  "../node_modules/split2/index.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2 } = require_readable();
    var { StringDecoder } = require("string_decoder");
    var kLast = Symbol("last");
    var kDecoder = Symbol("decoder");
    function transform(chunk, enc, cb) {
      var list;
      if (this.overflow) {
        var buf = this[kDecoder].write(chunk);
        list = buf.split(this.matcher);
        if (list.length === 1)
          return cb();
        list.shift();
        this.overflow = false;
      } else {
        this[kLast] += this[kDecoder].write(chunk);
        list = this[kLast].split(this.matcher);
      }
      this[kLast] = list.pop();
      for (var i = 0; i < list.length; i++) {
        try {
          push(this, this.mapper(list[i]));
        } catch (error) {
          return cb(error);
        }
      }
      this.overflow = this[kLast].length > this.maxLength;
      if (this.overflow && !this.skipOverflow)
        return cb(new Error("maximum buffer reached"));
      cb();
    }
    function flush(cb) {
      this[kLast] += this[kDecoder].end();
      if (this[kLast]) {
        try {
          push(this, this.mapper(this[kLast]));
        } catch (error) {
          return cb(error);
        }
      }
      cb();
    }
    function push(self2, val) {
      if (val !== void 0) {
        self2.push(val);
      }
    }
    function noop(incoming) {
      return incoming;
    }
    function split(matcher, mapper, options) {
      matcher = matcher || /\r?\n/;
      mapper = mapper || noop;
      options = options || {};
      switch (arguments.length) {
        case 1:
          if (typeof matcher === "function") {
            mapper = matcher;
            matcher = /\r?\n/;
          } else if (typeof matcher === "object" && !(matcher instanceof RegExp)) {
            options = matcher;
            matcher = /\r?\n/;
          }
          break;
        case 2:
          if (typeof matcher === "function") {
            options = mapper;
            mapper = matcher;
            matcher = /\r?\n/;
          } else if (typeof mapper === "object") {
            options = mapper;
            mapper = noop;
          }
      }
      options = Object.assign({}, options);
      options.transform = transform;
      options.flush = flush;
      options.readableObjectMode = true;
      const stream2 = new Transform2(options);
      stream2[kLast] = "";
      stream2[kDecoder] = new StringDecoder("utf8");
      stream2.matcher = matcher;
      stream2.mapper = mapper;
      stream2.maxLength = options.maxLength;
      stream2.skipOverflow = options.skipOverflow;
      stream2.overflow = false;
      return stream2;
    }
    module2.exports = split;
  }
});

// ../node_modules/es5-ext/object/is-thenable.js
var require_is_thenable = __commonJS({
  "../node_modules/es5-ext/object/is-thenable.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    var isObject = require_is_object();
    module2.exports = function(value) {
      return isObject(value) && isCallable(value.then);
    };
  }
});

// ../node_modules/es5-ext/safe-to-string.js
var require_safe_to_string3 = __commonJS({
  "../node_modules/es5-ext/safe-to-string.js"(exports2, module2) {
    "use strict";
    var isCallable = require_is_callable();
    module2.exports = function(value) {
      try {
        if (value && isCallable(value.toString))
          return value.toString();
        return String(value);
      } catch (e) {
        return "<Non-coercible to string value>";
      }
    };
  }
});

// ../node_modules/es5-ext/object/is-promise.js
var require_is_promise = __commonJS({
  "../node_modules/es5-ext/object/is-promise.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_thenable();
  }
});

// ../node_modules/es5-ext/object/ensure-promise.js
var require_ensure_promise = __commonJS({
  "../node_modules/es5-ext/object/ensure-promise.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string3();
    var isPromise = require_is_promise();
    module2.exports = function(value) {
      if (!isPromise(value))
        throw new TypeError(safeToString(value) + " is not a promise");
      return value;
    };
  }
});

// ../node_modules/es5-ext/promise/#/finally/is-implemented.js
var require_is_implemented9 = __commonJS({
  "../node_modules/es5-ext/promise/#/finally/is-implemented.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      if (typeof Promise !== "function")
        return false;
      if (typeof Promise.prototype.finally !== "function")
        return false;
      return true;
    };
  }
});

// ../node_modules/es5-ext/object/is-plain-function.js
var require_is_plain_function = __commonJS({
  "../node_modules/es5-ext/object/is-plain-function.js"(exports2, module2) {
    "use strict";
    var isClassStr = RegExp.prototype.test.bind(/^\s*class[\s{/}]/);
    var fnToString = Function.prototype.toString;
    module2.exports = function(fn) {
      if (typeof fn !== "function")
        return false;
      if (typeof fn.call !== "function")
        return false;
      if (typeof fn.apply !== "function")
        return false;
      return !isClassStr(fnToString.call(fn));
    };
  }
});

// ../node_modules/es5-ext/object/ensure-plain-function.js
var require_ensure_plain_function = __commonJS({
  "../node_modules/es5-ext/object/ensure-plain-function.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string3();
    var isPlainFunction = require_is_plain_function();
    module2.exports = function(value) {
      if (!isPlainFunction(value)) {
        throw new TypeError(safeToString(value) + " is not a plain function");
      }
      return value;
    };
  }
});

// ../node_modules/es5-ext/object/ensure-thenable.js
var require_ensure_thenable = __commonJS({
  "../node_modules/es5-ext/object/ensure-thenable.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string3();
    var isThenable = require_is_thenable();
    module2.exports = function(value) {
      if (!isThenable(value))
        throw new TypeError(safeToString(value) + " is not a thenable");
      return value;
    };
  }
});

// ../node_modules/es5-ext/promise/#/finally/shim.js
var require_shim7 = __commonJS({
  "../node_modules/es5-ext/promise/#/finally/shim.js"(exports2, module2) {
    "use strict";
    var ensurePlainFunction = require_ensure_plain_function();
    var isThenable = require_is_thenable();
    var ensureThenable = require_ensure_thenable();
    var resolveCallback = function(callback, next) {
      var callbackResult = callback();
      if (!isThenable(callbackResult))
        return next();
      return callbackResult.then(next);
    };
    module2.exports = function(callback) {
      ensureThenable(this);
      ensurePlainFunction(callback);
      return this.then(function(result) {
        return resolveCallback(callback, function() {
          return result;
        });
      }, function(error) {
        return resolveCallback(callback, function() {
          throw error;
        });
      });
    };
  }
});

// ../node_modules/es5-ext/promise/#/finally/index.js
var require_finally = __commonJS({
  "../node_modules/es5-ext/promise/#/finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_is_implemented9()() ? Promise.prototype.finally : require_shim7();
  }
});

// ../node_modules/es5-ext/to-short-string-representation.js
var require_to_short_string_representation = __commonJS({
  "../node_modules/es5-ext/to-short-string-representation.js"(exports2, module2) {
    "use strict";
    var safeToString = require_safe_to_string3();
    var reNewLine = /[\n\r\u2028\u2029]/g;
    module2.exports = function(value) {
      var string = safeToString(value);
      if (string.length > 100)
        string = string.slice(0, 99) + "\u2026";
      string = string.replace(reNewLine, function(char) {
        return JSON.stringify(char).slice(1, -1);
      });
      return string;
    };
  }
});

// ../node_modules/2-thenable/index.js
var require_thenable = __commonJS({
  "../node_modules/2-thenable/index.js"(exports2, module2) {
    "use strict";
    var ensureObject = require_valid_object();
    var isThenable = require_is_thenable();
    var ensurePromise = require_ensure_promise();
    var finallyMethod = require_finally();
    var toShortString = require_to_short_string_representation();
    var d = require_d();
    module2.exports = (target, promise) => {
      if (isThenable(ensureObject(target))) {
        throw new TypeError(`${toShortString(target)} is already a thenable`);
      }
      if ("then" in target) {
        throw new TypeError(`${toShortString(target)} already has 'then' property`);
      }
      if ("catch" in target) {
        throw new TypeError(`${toShortString(target)} already has 'catch' property`);
      }
      if ("finally" in target) {
        throw new TypeError(`${toShortString(target)} already has 'finally' property`);
      }
      ensurePromise(promise);
      return Object.defineProperties(target, {
        then: d(promise.then.bind(promise)),
        catch: d(promise.catch.bind(promise)),
        finally: d(finallyMethod.bind(promise))
      });
    };
  }
});

// ../node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "../node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = module2.exports = function(stream2) {
      return stream2 !== null && typeof stream2 === "object" && typeof stream2.pipe === "function";
    };
    isStream.writable = function(stream2) {
      return isStream(stream2) && stream2.writable !== false && typeof stream2._write === "function" && typeof stream2._writableState === "object";
    };
    isStream.readable = function(stream2) {
      return isStream(stream2) && stream2.readable !== false && typeof stream2._read === "function" && typeof stream2._readableState === "object";
    };
    isStream.duplex = function(stream2) {
      return isStream.writable(stream2) && isStream.readable(stream2);
    };
    isStream.transform = function(stream2) {
      return isStream.duplex(stream2) && typeof stream2._transform === "function" && typeof stream2._transformState === "object";
    };
  }
});

// ../node_modules/stream-promise/to-promise.js
var require_to_promise = __commonJS({
  "../node_modules/stream-promise/to-promise.js"(exports2, module2) {
    "use strict";
    var isObject = require_is_object();
    var toShortString = require_to_short_string_representation();
    var isStream = require_is_stream();
    module2.exports = (stream2, options = {}) => {
      if (!isObject(options))
        options = {};
      if (!isStream(stream2))
        throw new TypeError(`${toShortString(stream2)} is not a stream`);
      if (!isStream.readable(stream2) && !isStream.writable(stream2)) {
        throw new TypeError(`${toShortString(stream2)} stream is recognized neither as readable nor writeable`);
      }
      let result = null;
      const promise = new Promise((resolve2, reject2) => {
        stream2.on("error", reject2);
        if (isStream.readable(stream2)) {
          if (options.noCollect) {
            result = void 0;
          } else if (stream2._readableState.objectMode) {
            result = [];
            stream2.on("data", (data) => result.push(data));
          } else {
            stream2.on("data", (data) => {
              if (typeof data === "string") {
                if (!result) {
                  promise.emittedData = result = data;
                } else if (Buffer.isBuffer(data)) {
                  promise.emittedData = result = Buffer.concat([data, Buffer.from(data)]);
                } else {
                  promise.emittedData = result += data;
                }
              } else if (!result) {
                promise.emittedData = result = data;
              } else if (Buffer.isBuffer(result)) {
                promise.emittedData = result = Buffer.concat([result, data]);
              } else {
                promise.emittedData = result = Buffer.concat([Buffer.from(result), data]);
              }
            });
          }
          stream2.on("end", () => resolve2(result));
        } else {
          stream2.on("finish", () => resolve2());
        }
      });
      if (isStream.readable && !options.noCollect)
        promise.emittedData = result;
      return promise;
    };
  }
});

// ../node_modules/stream-promise/index.js
var require_stream_promise = __commonJS({
  "../node_modules/stream-promise/index.js"(exports2, module2) {
    "use strict";
    var toThenable = require_thenable();
    var toPromise = require_to_promise();
    module2.exports = (stream2) => {
      const promise = toPromise(stream2);
      return Object.defineProperty(toThenable(stream2, promise), "emittedData", {
        configurable: true,
        enumerable: true,
        get: () => promise.emittedData
      });
    };
  }
});

// ../node_modules/child-process-ext/lib/private/spawn/setup-std.js
var require_setup_std = __commonJS({
  "../node_modules/child-process-ext/lib/private/spawn/setup-std.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    var split = require_split2();
    var streamPromise = require_stream_promise();
    var log = require_log().get("child-process-ext:spawn");
    var stdOutLog = log.get("std:out");
    var stdErrLog = log.get("std:err");
    module2.exports = ({ processIndex, resolveListeners, child, initResult, result, options }) => {
      if (child.stdout) {
        initResult.stdout = child.stdout;
        if (options.split)
          initResult.stdout = initResult.stdout.pipe(split());
        result.stdoutBuffer = Buffer.alloc(0);
        initResult.std = child.stdout.pipe(new PassThrough());
        result.stdBuffer = Buffer.alloc(0);
        child.stdout.on("data", (data) => {
          stdOutLog.debug("[%d] %s", processIndex, data);
          result.stdoutBuffer = Buffer.concat([result.stdoutBuffer, data]);
          result.stdBuffer = Buffer.concat([result.stdBuffer, data]);
        });
        streamPromise(initResult.stdout, new Promise((stdoutResolve) => resolveListeners.push(() => stdoutResolve(result.stdoutBuffer))));
        streamPromise(initResult.std, new Promise((stdResolve) => resolveListeners.push(() => stdResolve(result.stdBuffer))));
      } else if (stdOutLog.debug.isEnabled) {
        stdOutLog.warn("[%d] cannot expose %s output, as it's not exposed on a spawned process", processIndex, "stdout");
      }
      if (child.stderr) {
        initResult.stderr = child.stderr;
        if (options.split)
          initResult.stderr = initResult.stderr.pipe(split());
        result.stderrBuffer = Buffer.alloc(0);
        child.stderr.pipe(initResult.std);
        child.stderr.on("data", (data) => {
          stdErrLog.debug("[%d] %s", processIndex, data);
          result.stderrBuffer = Buffer.concat([result.stderrBuffer, data]);
          result.stdBuffer = Buffer.concat([result.stdBuffer, data]);
        });
        streamPromise(initResult.stderr, new Promise((stderrResolve) => resolveListeners.push(() => stderrResolve(result.stderrBuffer))));
      } else if (stdErrLog.debug.isEnabled) {
        stdErrLog.warn("[%d] cannot expose %s output, as it's not exposed on a spawned process", processIndex, "stderr");
      }
    };
  }
});

// ../node_modules/child-process-ext/spawn.js
var require_spawn = __commonJS({
  "../node_modules/child-process-ext/spawn.js"(exports2, module2) {
    "use strict";
    var ensureString = require_validate_stringifiable_value();
    var isValue = require_is_value();
    var isObject = require_is_object();
    var ensureObject = require_valid_object();
    var mixin = require_mixin();
    var log = require_log().get("child-process-ext:spawn");
    var spawn = require_cross_spawn();
    var setupStd = require_setup_std();
    var stdinLog = log.get("std:in");
    var processCounter = 0;
    module2.exports = (command, args = [], options = {}) => {
      let child;
      const initResult = {}, result = {}, resolveListeners = [], processIndex = ++processCounter;
      const promise = new Promise((resolve2, reject2) => {
        command = ensureString(command);
        if (isValue(args))
          args = Array.from(ensureObject(args), ensureString);
        if (!isObject(options))
          options = {};
        log.debug("[%d] run %s with %o", processIndex, command, args);
        child = spawn(command, args, options).on("close", (code, signal) => {
          result.code = code;
          result.signal = signal;
          for (const listener of resolveListeners)
            listener();
          if (code) {
            log.debug("[%d] failed with %d", processIndex, code);
            reject2(Object.assign(new Error(`\`${command} ${args.join(" ")}\` Exited with code ${code}`), result));
          } else {
            log.debug("[%d] succeeded", processIndex);
            resolve2(result);
          }
        }).on("error", (error) => {
          for (const listener of resolveListeners)
            listener();
          log.debug("[%d] errored with %o", processIndex, error);
          reject2(Object.assign(error, result));
        });
        setupStd({ processIndex, resolveListeners, child, initResult, result, options });
        if (options.shouldCloseStdin) {
          if (child.stdin)
            child.stdin.end();
          else
            stdinLog.notice("[%d] cannot close stdin, as it's not exposed on a child process");
        }
      });
      return mixin(Object.assign(promise, { child }, initResult), {
        get stdoutBuffer() {
          return result.stdoutBuffer;
        },
        get stderrBuffer() {
          return result.stderrBuffer;
        },
        get stdBuffer() {
          return result.stdBuffer;
        }
      });
    };
  }
});

// ../node_modules/package-json/node_modules/got/package.json
var require_package = __commonJS({
  "../node_modules/package-json/node_modules/got/package.json"(exports2, module2) {
    module2.exports = {
      name: "got",
      version: "9.6.0",
      description: "Simplified HTTP requests",
      license: "MIT",
      repository: "sindresorhus/got",
      main: "source",
      engines: {
        node: ">=8.6"
      },
      scripts: {
        test: "xo && nyc ava",
        release: "np"
      },
      files: [
        "source"
      ],
      keywords: [
        "http",
        "https",
        "get",
        "got",
        "url",
        "uri",
        "request",
        "util",
        "utility",
        "simple",
        "curl",
        "wget",
        "fetch",
        "net",
        "network",
        "electron"
      ],
      dependencies: {
        "@sindresorhus/is": "^0.14.0",
        "@szmarczak/http-timer": "^1.1.2",
        "cacheable-request": "^6.0.0",
        "decompress-response": "^3.3.0",
        duplexer3: "^0.1.4",
        "get-stream": "^4.1.0",
        "lowercase-keys": "^1.0.1",
        "mimic-response": "^1.0.1",
        "p-cancelable": "^1.0.0",
        "to-readable-stream": "^1.0.0",
        "url-parse-lax": "^3.0.0"
      },
      devDependencies: {
        ava: "^1.1.0",
        coveralls: "^3.0.0",
        delay: "^4.1.0",
        "form-data": "^2.3.3",
        "get-port": "^4.0.0",
        np: "^3.1.0",
        nyc: "^13.1.0",
        "p-event": "^2.1.0",
        pem: "^1.13.2",
        proxyquire: "^2.0.1",
        sinon: "^7.2.2",
        "slow-stream": "0.0.4",
        tempfile: "^2.0.0",
        tempy: "^0.2.1",
        "tough-cookie": "^3.0.0",
        xo: "^0.24.0"
      },
      ava: {
        concurrency: 4
      },
      browser: {
        "decompress-response": false,
        electron: false
      }
    };
  }
});

// ../node_modules/package-json/node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS({
  "../node_modules/package-json/node_modules/p-cancelable/index.js"(exports2, module2) {
    "use strict";
    var CancelError = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class {
      static fn(userFn) {
        return (...args) => {
          return new PCancelable((resolve2, reject2, onCancel) => {
            args.push(onCancel);
            userFn(...args).then(resolve2, reject2);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve2, reject2) => {
          this._reject = reject2;
          const onResolve = (value) => {
            this._isPending = false;
            resolve2(value);
          };
          const onReject = (error) => {
            this._isPending = false;
            reject2(error);
          };
          const onCancel = (handler) => {
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (bool) => {
                this._rejectOnCancel = bool;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error) {
            this._reject(error);
          }
        }
        this._isCanceled = true;
        if (this._rejectOnCancel) {
          this._reject(new CancelError(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.default = PCancelable;
    module2.exports.CancelError = CancelError;
  }
});

// ../node_modules/package-json/node_modules/@sindresorhus/is/dist/index.js
var require_dist = __commonJS({
  "../node_modules/package-json/node_modules/@sindresorhus/is/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var URLGlobal = typeof URL === "undefined" ? require("url").URL : URL;
    var toString = Object.prototype.toString;
    var isOfType = (type) => (value) => typeof value === type;
    var isBuffer = (input) => !is.nullOrUndefined(input) && !is.nullOrUndefined(input.constructor) && is.function_(input.constructor.isBuffer) && input.constructor.isBuffer(input);
    var getObjectType = (value) => {
      const objectName = toString.call(value).slice(8, -1);
      if (objectName) {
        return objectName;
      }
      return null;
    };
    var isObjectOfType = (type) => (value) => getObjectType(value) === type;
    function is(value) {
      switch (value) {
        case null:
          return "null";
        case true:
        case false:
          return "boolean";
        default:
      }
      switch (typeof value) {
        case "undefined":
          return "undefined";
        case "string":
          return "string";
        case "number":
          return "number";
        case "symbol":
          return "symbol";
        default:
      }
      if (is.function_(value)) {
        return "Function";
      }
      if (is.observable(value)) {
        return "Observable";
      }
      if (Array.isArray(value)) {
        return "Array";
      }
      if (isBuffer(value)) {
        return "Buffer";
      }
      const tagType = getObjectType(value);
      if (tagType) {
        return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    (function(is2) {
      const isObject = (value) => typeof value === "object";
      is2.undefined = isOfType("undefined");
      is2.string = isOfType("string");
      is2.number = isOfType("number");
      is2.function_ = isOfType("function");
      is2.null_ = (value) => value === null;
      is2.class_ = (value) => is2.function_(value) && value.toString().startsWith("class ");
      is2.boolean = (value) => value === true || value === false;
      is2.symbol = isOfType("symbol");
      is2.numericString = (value) => is2.string(value) && value.length > 0 && !Number.isNaN(Number(value));
      is2.array = Array.isArray;
      is2.buffer = isBuffer;
      is2.nullOrUndefined = (value) => is2.null_(value) || is2.undefined(value);
      is2.object = (value) => !is2.nullOrUndefined(value) && (is2.function_(value) || isObject(value));
      is2.iterable = (value) => !is2.nullOrUndefined(value) && is2.function_(value[Symbol.iterator]);
      is2.asyncIterable = (value) => !is2.nullOrUndefined(value) && is2.function_(value[Symbol.asyncIterator]);
      is2.generator = (value) => is2.iterable(value) && is2.function_(value.next) && is2.function_(value.throw);
      is2.nativePromise = (value) => isObjectOfType("Promise")(value);
      const hasPromiseAPI = (value) => !is2.null_(value) && isObject(value) && is2.function_(value.then) && is2.function_(value.catch);
      is2.promise = (value) => is2.nativePromise(value) || hasPromiseAPI(value);
      is2.generatorFunction = isObjectOfType("GeneratorFunction");
      is2.asyncFunction = isObjectOfType("AsyncFunction");
      is2.boundFunction = (value) => is2.function_(value) && !value.hasOwnProperty("prototype");
      is2.regExp = isObjectOfType("RegExp");
      is2.date = isObjectOfType("Date");
      is2.error = isObjectOfType("Error");
      is2.map = (value) => isObjectOfType("Map")(value);
      is2.set = (value) => isObjectOfType("Set")(value);
      is2.weakMap = (value) => isObjectOfType("WeakMap")(value);
      is2.weakSet = (value) => isObjectOfType("WeakSet")(value);
      is2.int8Array = isObjectOfType("Int8Array");
      is2.uint8Array = isObjectOfType("Uint8Array");
      is2.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
      is2.int16Array = isObjectOfType("Int16Array");
      is2.uint16Array = isObjectOfType("Uint16Array");
      is2.int32Array = isObjectOfType("Int32Array");
      is2.uint32Array = isObjectOfType("Uint32Array");
      is2.float32Array = isObjectOfType("Float32Array");
      is2.float64Array = isObjectOfType("Float64Array");
      is2.arrayBuffer = isObjectOfType("ArrayBuffer");
      is2.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
      is2.dataView = isObjectOfType("DataView");
      is2.directInstanceOf = (instance, klass) => Object.getPrototypeOf(instance) === klass.prototype;
      is2.urlInstance = (value) => isObjectOfType("URL")(value);
      is2.urlString = (value) => {
        if (!is2.string(value)) {
          return false;
        }
        try {
          new URLGlobal(value);
          return true;
        } catch (_a) {
          return false;
        }
      };
      is2.truthy = (value) => Boolean(value);
      is2.falsy = (value) => !value;
      is2.nan = (value) => Number.isNaN(value);
      const primitiveTypes = new Set([
        "undefined",
        "string",
        "number",
        "boolean",
        "symbol"
      ]);
      is2.primitive = (value) => is2.null_(value) || primitiveTypes.has(typeof value);
      is2.integer = (value) => Number.isInteger(value);
      is2.safeInteger = (value) => Number.isSafeInteger(value);
      is2.plainObject = (value) => {
        let prototype;
        return getObjectType(value) === "Object" && (prototype = Object.getPrototypeOf(value), prototype === null || prototype === Object.getPrototypeOf({}));
      };
      const typedArrayTypes = new Set([
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array"
      ]);
      is2.typedArray = (value) => {
        const objectType = getObjectType(value);
        if (objectType === null) {
          return false;
        }
        return typedArrayTypes.has(objectType);
      };
      const isValidLength = (value) => is2.safeInteger(value) && value > -1;
      is2.arrayLike = (value) => !is2.nullOrUndefined(value) && !is2.function_(value) && isValidLength(value.length);
      is2.inRange = (value, range) => {
        if (is2.number(range)) {
          return value >= Math.min(0, range) && value <= Math.max(range, 0);
        }
        if (is2.array(range) && range.length === 2) {
          return value >= Math.min(...range) && value <= Math.max(...range);
        }
        throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);
      };
      const NODE_TYPE_ELEMENT = 1;
      const DOM_PROPERTIES_TO_CHECK = [
        "innerHTML",
        "ownerDocument",
        "style",
        "attributes",
        "nodeValue"
      ];
      is2.domElement = (value) => is2.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is2.string(value.nodeName) && !is2.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
      is2.observable = (value) => {
        if (!value) {
          return false;
        }
        if (value[Symbol.observable] && value === value[Symbol.observable]()) {
          return true;
        }
        if (value["@@observable"] && value === value["@@observable"]()) {
          return true;
        }
        return false;
      };
      is2.nodeStream = (value) => !is2.nullOrUndefined(value) && isObject(value) && is2.function_(value.pipe) && !is2.observable(value);
      is2.infinite = (value) => value === Infinity || value === -Infinity;
      const isAbsoluteMod2 = (rem) => (value) => is2.integer(value) && Math.abs(value % 2) === rem;
      is2.even = isAbsoluteMod2(0);
      is2.odd = isAbsoluteMod2(1);
      const isWhiteSpaceString = (value) => is2.string(value) && /\S/.test(value) === false;
      is2.emptyArray = (value) => is2.array(value) && value.length === 0;
      is2.nonEmptyArray = (value) => is2.array(value) && value.length > 0;
      is2.emptyString = (value) => is2.string(value) && value.length === 0;
      is2.nonEmptyString = (value) => is2.string(value) && value.length > 0;
      is2.emptyStringOrWhitespace = (value) => is2.emptyString(value) || isWhiteSpaceString(value);
      is2.emptyObject = (value) => is2.object(value) && !is2.map(value) && !is2.set(value) && Object.keys(value).length === 0;
      is2.nonEmptyObject = (value) => is2.object(value) && !is2.map(value) && !is2.set(value) && Object.keys(value).length > 0;
      is2.emptySet = (value) => is2.set(value) && value.size === 0;
      is2.nonEmptySet = (value) => is2.set(value) && value.size > 0;
      is2.emptyMap = (value) => is2.map(value) && value.size === 0;
      is2.nonEmptyMap = (value) => is2.map(value) && value.size > 0;
      const predicateOnArray = (method, predicate, values) => {
        if (is2.function_(predicate) === false) {
          throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);
        }
        if (values.length === 0) {
          throw new TypeError("Invalid number of values");
        }
        return method.call(values, predicate);
      };
      is2.any = (predicate, ...values) => predicateOnArray(Array.prototype.some, predicate, values);
      is2.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);
    })(is || (is = {}));
    Object.defineProperties(is, {
      class: {
        value: is.class_
      },
      function: {
        value: is.function_
      },
      null: {
        value: is.null_
      }
    });
    exports2.default = is;
    module2.exports = is;
    module2.exports.default = is;
  }
});

// ../node_modules/package-json/node_modules/got/source/errors.js
var require_errors2 = __commonJS({
  "../node_modules/package-json/node_modules/got/source/errors.js"(exports2, module2) {
    "use strict";
    var urlLib = require("url");
    var http = require("http");
    var PCancelable = require_p_cancelable();
    var is = require_dist();
    var GotError = class extends Error {
      constructor(message, error, options) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "GotError";
        if (!is.undefined(error.code)) {
          this.code = error.code;
        }
        Object.assign(this, {
          host: options.host,
          hostname: options.hostname,
          method: options.method,
          path: options.path,
          socketPath: options.socketPath,
          protocol: options.protocol,
          url: options.href,
          gotOptions: options
        });
      }
    };
    module2.exports.GotError = GotError;
    module2.exports.CacheError = class extends GotError {
      constructor(error, options) {
        super(error.message, error, options);
        this.name = "CacheError";
      }
    };
    module2.exports.RequestError = class extends GotError {
      constructor(error, options) {
        super(error.message, error, options);
        this.name = "RequestError";
      }
    };
    module2.exports.ReadError = class extends GotError {
      constructor(error, options) {
        super(error.message, error, options);
        this.name = "ReadError";
      }
    };
    module2.exports.ParseError = class extends GotError {
      constructor(error, statusCode, options, data) {
        super(`${error.message} in "${urlLib.format(options)}": 
${data.slice(0, 77)}...`, error, options);
        this.name = "ParseError";
        this.statusCode = statusCode;
        this.statusMessage = http.STATUS_CODES[this.statusCode];
      }
    };
    module2.exports.HTTPError = class extends GotError {
      constructor(response, options) {
        const { statusCode } = response;
        let { statusMessage } = response;
        if (statusMessage) {
          statusMessage = statusMessage.replace(/\r?\n/g, " ").trim();
        } else {
          statusMessage = http.STATUS_CODES[statusCode];
        }
        super(`Response code ${statusCode} (${statusMessage})`, {}, options);
        this.name = "HTTPError";
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
        this.headers = response.headers;
        this.body = response.body;
      }
    };
    module2.exports.MaxRedirectsError = class extends GotError {
      constructor(statusCode, redirectUrls, options) {
        super("Redirected 10 times. Aborting.", {}, options);
        this.name = "MaxRedirectsError";
        this.statusCode = statusCode;
        this.statusMessage = http.STATUS_CODES[this.statusCode];
        this.redirectUrls = redirectUrls;
      }
    };
    module2.exports.UnsupportedProtocolError = class extends GotError {
      constructor(options) {
        super(`Unsupported protocol "${options.protocol}"`, {}, options);
        this.name = "UnsupportedProtocolError";
      }
    };
    module2.exports.TimeoutError = class extends GotError {
      constructor(error, options) {
        super(error.message, { code: "ETIMEDOUT" }, options);
        this.name = "TimeoutError";
        this.event = error.event;
      }
    };
    module2.exports.CancelError = PCancelable.CancelError;
  }
});

// ../node_modules/duplexer3/index.js
var require_duplexer3 = __commonJS({
  "../node_modules/duplexer3/index.js"(exports2, module2) {
    "use strict";
    var stream2 = require("stream");
    function DuplexWrapper(options, writable, readable) {
      if (typeof readable === "undefined") {
        readable = writable;
        writable = options;
        options = null;
      }
      stream2.Duplex.call(this, options);
      if (typeof readable.read !== "function") {
        readable = new stream2.Readable(options).wrap(readable);
      }
      this._writable = writable;
      this._readable = readable;
      this._waiting = false;
      var self2 = this;
      writable.once("finish", function() {
        self2.end();
      });
      this.once("finish", function() {
        writable.end();
      });
      readable.on("readable", function() {
        if (self2._waiting) {
          self2._waiting = false;
          self2._read();
        }
      });
      readable.once("end", function() {
        self2.push(null);
      });
      if (!options || typeof options.bubbleErrors === "undefined" || options.bubbleErrors) {
        writable.on("error", function(err) {
          self2.emit("error", err);
        });
        readable.on("error", function(err) {
          self2.emit("error", err);
        });
      }
    }
    DuplexWrapper.prototype = Object.create(stream2.Duplex.prototype, { constructor: { value: DuplexWrapper } });
    DuplexWrapper.prototype._write = function _write(input, encoding, done) {
      this._writable.write(input, encoding, done);
    };
    DuplexWrapper.prototype._read = function _read() {
      var buf;
      var reads = 0;
      while ((buf = this._readable.read()) !== null) {
        this.push(buf);
        reads++;
      }
      if (reads === 0) {
        this._waiting = true;
      }
    };
    module2.exports = function duplex2(options, writable, readable) {
      return new DuplexWrapper(options, writable, readable);
    };
    module2.exports.DuplexWrapper = DuplexWrapper;
  }
});

// ../node_modules/package-json/node_modules/normalize-url/index.js
var require_normalize_url = __commonJS({
  "../node_modules/package-json/node_modules/normalize-url/index.js"(exports2, module2) {
    "use strict";
    var URLParser = typeof URL === "undefined" ? require("url").URL : URL;
    var DATA_URL_DEFAULT_MIME_TYPE = "text/plain";
    var DATA_URL_DEFAULT_CHARSET = "us-ascii";
    var testParameter = (name, filters) => {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    };
    var normalizeDataURL = (urlString, { stripHash }) => {
      const parts = urlString.match(/^data:([^,]*?),([^#]*?)(?:#(.*))?$/);
      if (!parts) {
        throw new Error(`Invalid URL: ${urlString}`);
      }
      const mediaType = parts[1].split(";");
      const body = parts[2];
      const hash = stripHash ? "" : parts[3];
      let base64 = false;
      if (mediaType[mediaType.length - 1] === "base64") {
        mediaType.pop();
        base64 = true;
      }
      const mimeType = (mediaType.shift() || "").toLowerCase();
      const attributes = mediaType.map((attribute) => {
        let [key, value = ""] = attribute.split("=").map((string) => string.trim());
        if (key === "charset") {
          value = value.toLowerCase();
          if (value === DATA_URL_DEFAULT_CHARSET) {
            return "";
          }
        }
        return `${key}${value ? `=${value}` : ""}`;
      }).filter(Boolean);
      const normalizedMediaType = [
        ...attributes
      ];
      if (base64) {
        normalizedMediaType.push("base64");
      }
      if (normalizedMediaType.length !== 0 || mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE) {
        normalizedMediaType.unshift(mimeType);
      }
      return `data:${normalizedMediaType.join(";")},${base64 ? body.trim() : body}${hash ? `#${hash}` : ""}`;
    };
    var normalizeUrl = (urlString, options) => {
      options = __spreadValues({
        defaultProtocol: "http:",
        normalizeProtocol: true,
        forceHttp: false,
        forceHttps: false,
        stripAuthentication: true,
        stripHash: false,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true
      }, options);
      if (Reflect.has(options, "normalizeHttps")) {
        throw new Error("options.normalizeHttps is renamed to options.forceHttp");
      }
      if (Reflect.has(options, "normalizeHttp")) {
        throw new Error("options.normalizeHttp is renamed to options.forceHttps");
      }
      if (Reflect.has(options, "stripFragment")) {
        throw new Error("options.stripFragment is renamed to options.stripHash");
      }
      urlString = urlString.trim();
      if (/^data:/i.test(urlString)) {
        return normalizeDataURL(urlString, options);
      }
      const hasRelativeProtocol = urlString.startsWith("//");
      const isRelativeUrl = !hasRelativeProtocol && /^\.*\//.test(urlString);
      if (!isRelativeUrl) {
        urlString = urlString.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, options.defaultProtocol);
      }
      const urlObj = new URLParser(urlString);
      if (options.forceHttp && options.forceHttps) {
        throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");
      }
      if (options.forceHttp && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (options.forceHttps && urlObj.protocol === "http:") {
        urlObj.protocol = "https:";
      }
      if (options.stripAuthentication) {
        urlObj.username = "";
        urlObj.password = "";
      }
      if (options.stripHash) {
        urlObj.hash = "";
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/((?!:).|^)\/{2,}/g, (_2, p1) => {
          if (/^(?!\/)/g.test(p1)) {
            return `${p1}/`;
          }
          return "/";
        });
      }
      if (urlObj.pathname) {
        urlObj.pathname = decodeURI(urlObj.pathname);
      }
      if (options.removeDirectoryIndex === true) {
        options.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, options.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (urlObj.hostname) {
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (options.stripWWW && /^www\.([a-z\-\d]{2,63})\.([a-z.]{2,5})$/.test(urlObj.hostname)) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (Array.isArray(options.removeQueryParameters)) {
        for (const key of [...urlObj.searchParams.keys()]) {
          if (testParameter(key, options.removeQueryParameters)) {
            urlObj.searchParams.delete(key);
          }
        }
      }
      if (options.sortQueryParameters) {
        urlObj.searchParams.sort();
      }
      if (options.removeTrailingSlash) {
        urlObj.pathname = urlObj.pathname.replace(/\/$/, "");
      }
      urlString = urlObj.toString();
      if ((options.removeTrailingSlash || urlObj.pathname === "/") && urlObj.hash === "") {
        urlString = urlString.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !options.normalizeProtocol) {
        urlString = urlString.replace(/^http:\/\//, "//");
      }
      if (options.stripProtocol) {
        urlString = urlString.replace(/^(?:https?:)?\/\//, "");
      }
      return urlString;
    };
    module2.exports = normalizeUrl;
    module2.exports.default = normalizeUrl;
  }
});

// ../node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "../node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// ../node_modules/once/once.js
var require_once = __commonJS({
  "../node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// ../node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS({
  "../node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream2) {
      return stream2.setHeader && typeof stream2.abort === "function";
    };
    var isChildProcess = function(stream2) {
      return stream2.stdio && Array.isArray(stream2.stdio) && stream2.stdio.length === 3;
    };
    var eos = function(stream2, opts, callback) {
      if (typeof opts === "function")
        return eos(stream2, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream2._writableState;
      var rs = stream2._readableState;
      var readable = opts.readable || opts.readable !== false && stream2.readable;
      var writable = opts.writable || opts.writable !== false && stream2.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream2.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream2);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream2);
      };
      var onexit = function(exitCode) {
        callback.call(stream2, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream2, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream2, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream2, new Error("premature close"));
      };
      var onrequest = function() {
        stream2.req.on("finish", onfinish);
      };
      if (isRequest(stream2)) {
        stream2.on("complete", onfinish);
        stream2.on("abort", onclose);
        if (stream2.req)
          onrequest();
        else
          stream2.on("request", onrequest);
      } else if (writable && !ws) {
        stream2.on("end", onlegacyfinish);
        stream2.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream2))
        stream2.on("exit", onexit);
      stream2.on("end", onend);
      stream2.on("finish", onfinish);
      if (opts.error !== false)
        stream2.on("error", onerror);
      stream2.on("close", onclose);
      return function() {
        cancelled = true;
        stream2.removeListener("complete", onfinish);
        stream2.removeListener("abort", onclose);
        stream2.removeListener("request", onrequest);
        if (stream2.req)
          stream2.req.removeListener("finish", onfinish);
        stream2.removeListener("end", onlegacyfinish);
        stream2.removeListener("close", onlegacyfinish);
        stream2.removeListener("finish", onfinish);
        stream2.removeListener("exit", onexit);
        stream2.removeListener("end", onend);
        stream2.removeListener("error", onerror);
        stream2.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// ../node_modules/pump/index.js
var require_pump = __commonJS({
  "../node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream2();
    var fs = require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream2) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream2 instanceof (fs.ReadStream || noop) || stream2 instanceof (fs.WriteStream || noop)) && isFn(stream2.close);
    };
    var isRequest = function(stream2) {
      return stream2.setHeader && isFn(stream2.abort);
    };
    var destroyer = function(stream2, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream2.on("close", function() {
        closed = true;
      });
      eos(stream2, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream2))
          return stream2.close(noop);
        if (isRequest(stream2))
          return stream2.abort();
        if (isFn(stream2.destroy))
          return stream2.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream2, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream2, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// ../node_modules/package-json/node_modules/cacheable-request/node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "../node_modules/package-json/node_modules/cacheable-request/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = __spreadValues({}, options);
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream2 = new PassThroughStream({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream2.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream2.getBufferedLength = () => length;
      return stream2;
    };
  }
});

// ../node_modules/package-json/node_modules/cacheable-request/node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "../node_modules/package-json/node_modules/cacheable-request/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    async function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = __spreadValues({
        maxBuffer: Infinity
      }, options);
      const { maxBuffer } = options;
      let stream2;
      await new Promise((resolve2, reject2) => {
        const rejectPromise = (error) => {
          if (error && stream2.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject2(error);
        };
        stream2 = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve2();
        });
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      });
      return stream2.getBufferedValue();
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream2, options) => getStream(stream2, __spreadProps(__spreadValues({}, options), { encoding: "buffer" }));
    module2.exports.array = (stream2, options) => getStream(stream2, __spreadProps(__spreadValues({}, options), { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// ../node_modules/package-json/node_modules/http-cache-semantics/index.js
var require_http_cache_semantics = __commonJS({
  "../node_modules/package-json/node_modules/http-cache-semantics/index.js"(exports2, module2) {
    "use strict";
    var statusCodeCacheableByDefault = new Set([
      200,
      203,
      204,
      206,
      300,
      301,
      404,
      405,
      410,
      414,
      501
    ]);
    var understoodStatuses = new Set([
      200,
      203,
      204,
      300,
      301,
      302,
      303,
      307,
      308,
      404,
      405,
      410,
      414,
      501
    ]);
    var errorStatusCodes = new Set([
      500,
      502,
      503,
      504
    ]);
    var hopByHopHeaders = {
      date: true,
      connection: true,
      "keep-alive": true,
      "proxy-authenticate": true,
      "proxy-authorization": true,
      te: true,
      trailer: true,
      "transfer-encoding": true,
      upgrade: true
    };
    var excludedFromRevalidationUpdate = {
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function toNumberOrZero(s) {
      const n = parseInt(s, 10);
      return isFinite(n) ? n : 0;
    }
    function isErrorResponse(response) {
      if (!response) {
        return true;
      }
      return errorStatusCodes.has(response.status);
    }
    function parseCacheControl(header) {
      const cc = {};
      if (!header)
        return cc;
      const parts = header.trim().split(/\s*,\s*/);
      for (const part of parts) {
        const [k, v] = part.split(/\s*=\s*/, 2);
        cc[k] = v === void 0 ? true : v.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      let parts = [];
      for (const k in cc) {
        const v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = class CachePolicy {
      constructor(req, res, {
        shared,
        cacheHeuristic,
        immutableMinTimeToLive,
        ignoreCargoCult,
        _fromObject
      } = {}) {
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : 0.1;
        this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, {
            "cache-control": formatCacheControl(this._rescc)
          });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (res.headers["cache-control"] == null && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      now() {
        return Date.now();
      }
      storable() {
        return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.has(this._status) && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc["max-age"] || this._isShared && this._rescc["s-maxage"] || this._rescc.public || statusCodeCacheableByDefault.has(this._status)));
      }
      _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      }
      _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      }
      satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        const requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          const allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      }
      _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
      }
      _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      }
      _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        const fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (const name of fields) {
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      }
      _copyWithoutHopByHopHeaders(inHeaders) {
        const headers = {};
        for (const name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (const name of tokens) {
            delete headers[name];
          }
        }
        if (headers.warning) {
          const warnings = headers.warning.split(/,/).filter((warning) => {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      }
      responseHeaders() {
        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        const age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        headers.date = new Date(this.now()).toUTCString();
        return headers;
      }
      date() {
        const serverDate = Date.parse(this._resHeaders.date);
        if (isFinite(serverDate)) {
          return serverDate;
        }
        return this._responseTime;
      }
      age() {
        let age = this._ageValue();
        const residentTime = (this.now() - this._responseTime) / 1e3;
        return age + residentTime;
      }
      _ageValue() {
        return toNumberOrZero(this._resHeaders.age);
      }
      maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && (this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable)) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return toNumberOrZero(this._rescc["s-maxage"]);
          }
        }
        if (this._rescc["max-age"]) {
          return toNumberOrZero(this._rescc["max-age"]);
        }
        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        const serverDate = this.date();
        if (this._resHeaders.expires) {
          const expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < serverDate) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          const lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && serverDate > lastModified) {
            return Math.max(defaultMinTtl, (serverDate - lastModified) / 1e3 * this._cacheHeuristic);
          }
        }
        return defaultMinTtl;
      }
      timeToLive() {
        const age = this.maxAge() - this.age();
        const staleIfErrorAge = age + toNumberOrZero(this._rescc["stale-if-error"]);
        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
        return Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3;
      }
      stale() {
        return this.maxAge() <= this.age();
      }
      _useStaleIfError() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) > this.age();
      }
      useStaleWhileRevalidate() {
        return this.maxAge() + toNumberOrZero(this._rescc["stale-while-revalidate"]) > this.age();
      }
      static fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      }
      _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      }
      toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      }
      revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        const forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            const etags = headers["if-none-match"].split(/,/).filter((etag) => {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      }
      revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (this._useStaleIfError() && isErrorResponse(response)) {
          return {
            modified: false,
            matches: false,
            policy: this
          };
        }
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        let matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request, response),
            modified: response.status != 304,
            matches: false
          };
        }
        const headers = {};
        for (const k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        const newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse, {
            shared: this._isShared,
            cacheHeuristic: this._cacheHeuristic,
            immutableMinTimeToLive: this._immutableMinTtl
          }),
          modified: false,
          matches: true
        };
      }
    };
  }
});

// ../node_modules/lowercase-keys/index.js
var require_lowercase_keys = __commonJS({
  "../node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      var ret = {};
      var keys = Object.keys(Object(obj));
      for (var i = 0; i < keys.length; i++) {
        ret[keys[i].toLowerCase()] = obj[keys[i]];
      }
      return ret;
    };
  }
});

// ../node_modules/responselike/src/index.js
var require_src2 = __commonJS({
  "../node_modules/responselike/src/index.js"(exports2, module2) {
    "use strict";
    var Readable2 = require("stream").Readable;
    var lowercaseKeys = require_lowercase_keys();
    var Response = class extends Readable2 {
      constructor(statusCode, headers, body, url) {
        if (typeof statusCode !== "number") {
          throw new TypeError("Argument `statusCode` should be a number");
        }
        if (typeof headers !== "object") {
          throw new TypeError("Argument `headers` should be an object");
        }
        if (!(body instanceof Buffer)) {
          throw new TypeError("Argument `body` should be a buffer");
        }
        if (typeof url !== "string") {
          throw new TypeError("Argument `url` should be a string");
        }
        super();
        this.statusCode = statusCode;
        this.headers = lowercaseKeys(headers);
        this.body = body;
        this.url = url;
      }
      _read() {
        this.push(this.body);
        this.push(null);
      }
    };
    module2.exports = Response;
  }
});

// ../node_modules/package-json/node_modules/cacheable-request/node_modules/lowercase-keys/index.js
var require_lowercase_keys2 = __commonJS({
  "../node_modules/package-json/node_modules/cacheable-request/node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object) => {
      const result = {};
      for (const [key, value] of Object.entries(object)) {
        result[key.toLowerCase()] = value;
      }
      return result;
    };
  }
});

// ../node_modules/mimic-response/index.js
var require_mimic_response = __commonJS({
  "../node_modules/mimic-response/index.js"(exports2, module2) {
    "use strict";
    var knownProps = [
      "destroy",
      "setTimeout",
      "socket",
      "headers",
      "trailers",
      "rawHeaders",
      "statusCode",
      "httpVersion",
      "httpVersionMinor",
      "httpVersionMajor",
      "rawTrailers",
      "statusMessage"
    ];
    module2.exports = (fromStream, toStream) => {
      const fromProps = new Set(Object.keys(fromStream).concat(knownProps));
      for (const prop of fromProps) {
        if (prop in toStream) {
          continue;
        }
        toStream[prop] = typeof fromStream[prop] === "function" ? fromStream[prop].bind(fromStream) : fromStream[prop];
      }
    };
  }
});

// ../node_modules/clone-response/src/index.js
var require_src3 = __commonJS({
  "../node_modules/clone-response/src/index.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    var mimicResponse = require_mimic_response();
    var cloneResponse = (response) => {
      if (!(response && response.pipe)) {
        throw new TypeError("Parameter `response` must be a response stream.");
      }
      const clone = new PassThrough();
      mimicResponse(response, clone);
      return response.pipe(clone);
    };
    module2.exports = cloneResponse;
  }
});

// ../node_modules/json-buffer/index.js
var require_json_buffer = __commonJS({
  "../node_modules/json-buffer/index.js"(exports2) {
    exports2.stringify = function stringify(o) {
      if (typeof o == "undefined")
        return o;
      if (o && Buffer.isBuffer(o))
        return JSON.stringify(":base64:" + o.toString("base64"));
      if (o && o.toJSON)
        o = o.toJSON();
      if (o && typeof o === "object") {
        var s = "";
        var array = Array.isArray(o);
        s = array ? "[" : "{";
        var first = true;
        for (var k in o) {
          var ignore = typeof o[k] == "function" || !array && typeof o[k] === "undefined";
          if (Object.hasOwnProperty.call(o, k) && !ignore) {
            if (!first)
              s += ",";
            first = false;
            if (array) {
              if (o[k] == void 0)
                s += "null";
              else
                s += stringify(o[k]);
            } else if (o[k] !== void 0) {
              s += stringify(k) + ":" + stringify(o[k]);
            }
          }
        }
        s += array ? "]" : "}";
        return s;
      } else if (typeof o === "string") {
        return JSON.stringify(/^:/.test(o) ? ":" + o : o);
      } else if (typeof o === "undefined") {
        return "null";
      } else
        return JSON.stringify(o);
    };
    exports2.parse = function(s) {
      return JSON.parse(s, function(key, value) {
        if (typeof value === "string") {
          if (/^:base64:/.test(value))
            return new Buffer(value.substring(8), "base64");
          else
            return /^:/.test(value) ? value.substring(1) : value;
        }
        return value;
      });
    };
  }
});

// ../node_modules/keyv/src/index.js
var require_src4 = __commonJS({
  "../node_modules/keyv/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var JSONB = require_json_buffer();
    var loadStore = (opts) => {
      const adapters = {
        redis: "@keyv/redis",
        mongodb: "@keyv/mongo",
        mongo: "@keyv/mongo",
        sqlite: "@keyv/sqlite",
        postgresql: "@keyv/postgres",
        postgres: "@keyv/postgres",
        mysql: "@keyv/mysql"
      };
      if (opts.adapter || opts.uri) {
        const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
        return new (require(adapters[adapter]))(opts);
      }
      return new Map();
    };
    var Keyv = class extends EventEmitter {
      constructor(uri, opts) {
        super();
        this.opts = Object.assign({ namespace: "keyv" }, typeof uri === "string" ? { uri } : uri, opts);
        if (!this.opts.store) {
          const adapterOpts = Object.assign({}, this.opts);
          this.opts.store = loadStore(adapterOpts);
        }
        if (typeof this.opts.store.on === "function") {
          this.opts.store.on("error", (err) => this.emit("error", err));
        }
        this.opts.store.namespace = this.opts.namespace;
      }
      _getKeyPrefix(key) {
        return `${this.opts.namespace}:${key}`;
      }
      get(key) {
        key = this._getKeyPrefix(key);
        const store = this.opts.store;
        return Promise.resolve().then(() => store.get(key)).then((data) => {
          data = typeof data === "string" ? JSONB.parse(data) : data;
          if (data === void 0) {
            return void 0;
          }
          if (typeof data.expires === "number" && Date.now() > data.expires) {
            this.delete(key);
            return void 0;
          }
          return data.value;
        });
      }
      set(key, value, ttl) {
        key = this._getKeyPrefix(key);
        if (typeof ttl === "undefined") {
          ttl = this.opts.ttl;
        }
        if (ttl === 0) {
          ttl = void 0;
        }
        const store = this.opts.store;
        return Promise.resolve().then(() => {
          const expires = typeof ttl === "number" ? Date.now() + ttl : null;
          value = { value, expires };
          return store.set(key, JSONB.stringify(value), ttl);
        }).then(() => true);
      }
      delete(key) {
        key = this._getKeyPrefix(key);
        const store = this.opts.store;
        return Promise.resolve().then(() => store.delete(key));
      }
      clear() {
        const store = this.opts.store;
        return Promise.resolve().then(() => store.clear());
      }
    };
    module2.exports = Keyv;
  }
});

// ../node_modules/package-json/node_modules/cacheable-request/src/index.js
var require_src5 = __commonJS({
  "../node_modules/package-json/node_modules/cacheable-request/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var urlLib = require("url");
    var normalizeUrl = require_normalize_url();
    var getStream = require_get_stream();
    var CachePolicy = require_http_cache_semantics();
    var Response = require_src2();
    var lowercaseKeys = require_lowercase_keys2();
    var cloneResponse = require_src3();
    var Keyv = require_src4();
    var CacheableRequest = class {
      constructor(request, cacheAdapter) {
        if (typeof request !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request);
      }
      createCacheableRequest(request) {
        return (opts, cb) => {
          let url;
          if (typeof opts === "string") {
            url = normalizeUrlObject(urlLib.parse(opts));
            opts = {};
          } else if (opts instanceof urlLib.URL) {
            url = normalizeUrlObject(urlLib.parse(opts.toString()));
            opts = {};
          } else {
            const [pathname, ...searchParts] = (opts.path || "").split("?");
            const search = searchParts.length > 0 ? `?${searchParts.join("?")}` : "";
            url = normalizeUrlObject(__spreadProps(__spreadValues({}, opts), { pathname, search }));
          }
          opts = __spreadValues(__spreadValues({
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false
          }, opts), urlObjectToRequestOptions(url));
          opts.headers = lowercaseKeys(opts.headers);
          const ee = new EventEmitter();
          const normalizedUrlString = normalizeUrl(urlLib.format(url), {
            stripWWW: false,
            removeTrailingSlash: false,
            stripAuthentication: false
          });
          const key = `${opts.method}:${normalizedUrlString}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            let requestErrored = false;
            let requestErrorCallback;
            const requestErrorPromise = new Promise((resolve2) => {
              requestErrorCallback = () => {
                if (!requestErrored) {
                  requestErrored = true;
                  resolve2();
                }
              };
            });
            const handler = (response) => {
              if (revalidate && !opts2.forceRefresh) {
                response.status = response.statusCode;
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);
                  response.cachePolicy = revalidatedPolicy.policy;
                  response.fromCache = true;
                }
              }
              if (!response.fromCache) {
                response.cachePolicy = new CachePolicy(opts2, response, opts2);
                response.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response);
                (async () => {
                  try {
                    const bodyPromise = getStream.buffer(response);
                    await Promise.race([
                      requestErrorPromise,
                      new Promise((resolve2) => response.once("end", resolve2))
                    ]);
                    if (requestErrored) {
                      return;
                    }
                    const body = await bodyPromise;
                    const value = {
                      cachePolicy: response.cachePolicy.toObject(),
                      url: response.url,
                      statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                      body
                    };
                    let ttl = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                    if (opts2.maxTtl) {
                      ttl = ttl ? Math.min(ttl, opts2.maxTtl) : opts2.maxTtl;
                    }
                    await this.cache.set(key, value, ttl);
                  } catch (error) {
                    ee.emit("error", new CacheableRequest.CacheError(error));
                  }
                })();
              } else if (opts2.cache && revalidate) {
                (async () => {
                  try {
                    await this.cache.delete(key);
                  } catch (error) {
                    ee.emit("error", new CacheableRequest.CacheError(error));
                  }
                })();
              }
              ee.emit("response", clonedResponse || response);
              if (typeof cb === "function") {
                cb(clonedResponse || response);
              }
            };
            try {
              const req = request(opts2, handler);
              req.once("error", requestErrorCallback);
              req.once("abort", requestErrorCallback);
              ee.emit("request", req);
            } catch (error) {
              ee.emit("error", new CacheableRequest.RequestError(error));
            }
          };
          (async () => {
            const get = async (opts2) => {
              await Promise.resolve();
              const cacheEntry = opts2.cache ? await this.cache.get(key) : void 0;
              if (typeof cacheEntry === "undefined") {
                return makeRequest(opts2);
              }
              const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
              if (policy.satisfiesWithoutRevalidation(opts2) && !opts2.forceRefresh) {
                const headers = policy.responseHeaders();
                const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
                response.cachePolicy = policy;
                response.fromCache = true;
                ee.emit("response", response);
                if (typeof cb === "function") {
                  cb(response);
                }
              } else {
                revalidate = cacheEntry;
                opts2.headers = policy.revalidationHeaders(opts2);
                makeRequest(opts2);
              }
            };
            const errorHandler = (error) => ee.emit("error", new CacheableRequest.CacheError(error));
            this.cache.once("error", errorHandler);
            ee.on("response", () => this.cache.removeListener("error", errorHandler));
            try {
              await get(opts);
            } catch (error) {
              if (opts.automaticFailover && !madeRequest) {
                makeRequest(opts);
              }
              ee.emit("error", new CacheableRequest.CacheError(error));
            }
          })();
          return ee;
        };
      }
    };
    function urlObjectToRequestOptions(url) {
      const options = __spreadValues({}, url);
      options.path = `${url.pathname || "/"}${url.search || ""}`;
      delete options.pathname;
      delete options.search;
      return options;
    }
    function normalizeUrlObject(url) {
      return {
        protocol: url.protocol,
        auth: url.auth,
        hostname: url.hostname || url.host || "localhost",
        port: url.port,
        pathname: url.pathname,
        search: url.search
      };
    }
    CacheableRequest.RequestError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "RequestError";
        Object.assign(this, error);
      }
    };
    CacheableRequest.CacheError = class extends Error {
      constructor(error) {
        super(error.message);
        this.name = "CacheError";
        Object.assign(this, error);
      }
    };
    module2.exports = CacheableRequest;
  }
});

// ../node_modules/to-readable-stream/index.js
var require_to_readable_stream = __commonJS({
  "../node_modules/to-readable-stream/index.js"(exports2, module2) {
    "use strict";
    var { Readable: Readable2 } = require("stream");
    module2.exports = (input) => new Readable2({
      read() {
        this.push(input);
        this.push(null);
      }
    });
  }
});

// ../node_modules/package-json/node_modules/defer-to-connect/dist/index.js
var require_dist2 = __commonJS({
  "../node_modules/package-json/node_modules/defer-to-connect/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tls_1 = require("tls");
    var deferToConnect = (socket, fn) => {
      let listeners;
      if (typeof fn === "function") {
        const connect = fn;
        listeners = { connect };
      } else {
        listeners = fn;
      }
      const hasConnectListener = typeof listeners.connect === "function";
      const hasSecureConnectListener = typeof listeners.secureConnect === "function";
      const hasCloseListener = typeof listeners.close === "function";
      const onConnect = () => {
        if (hasConnectListener) {
          listeners.connect();
        }
        if (socket instanceof tls_1.TLSSocket && hasSecureConnectListener) {
          if (socket.authorized) {
            listeners.secureConnect();
          } else if (!socket.authorizationError) {
            socket.once("secureConnect", listeners.secureConnect);
          }
        }
        if (hasCloseListener) {
          socket.once("close", listeners.close);
        }
      };
      if (socket.writable && !socket.connecting) {
        onConnect();
      } else if (socket.connecting) {
        socket.once("connect", onConnect);
      } else if (socket.destroyed && hasCloseListener) {
        listeners.close(socket._hadError);
      }
    };
    exports2.default = deferToConnect;
    module2.exports = deferToConnect;
    module2.exports.default = deferToConnect;
  }
});

// ../node_modules/package-json/node_modules/@szmarczak/http-timer/source/index.js
var require_source2 = __commonJS({
  "../node_modules/package-json/node_modules/@szmarczak/http-timer/source/index.js"(exports2, module2) {
    "use strict";
    var deferToConnect = require_dist2();
    module2.exports = (request) => {
      const timings = {
        start: Date.now(),
        socket: null,
        lookup: null,
        connect: null,
        upload: null,
        response: null,
        end: null,
        error: null,
        phases: {
          wait: null,
          dns: null,
          tcp: null,
          request: null,
          firstByte: null,
          download: null,
          total: null
        }
      };
      const handleError = (origin) => {
        const emit = origin.emit.bind(origin);
        origin.emit = (event, ...args) => {
          if (event === "error") {
            timings.error = Date.now();
            timings.phases.total = timings.error - timings.start;
            origin.emit = emit;
          }
          return emit(event, ...args);
        };
      };
      let uploadFinished = false;
      const onUpload = () => {
        timings.upload = Date.now();
        timings.phases.request = timings.upload - timings.connect;
      };
      handleError(request);
      request.once("socket", (socket) => {
        timings.socket = Date.now();
        timings.phases.wait = timings.socket - timings.start;
        const lookupListener = () => {
          timings.lookup = Date.now();
          timings.phases.dns = timings.lookup - timings.socket;
        };
        socket.once("lookup", lookupListener);
        deferToConnect(socket, () => {
          timings.connect = Date.now();
          if (timings.lookup === null) {
            socket.removeListener("lookup", lookupListener);
            timings.lookup = timings.connect;
            timings.phases.dns = timings.lookup - timings.socket;
          }
          timings.phases.tcp = timings.connect - timings.lookup;
          if (uploadFinished && !timings.upload) {
            onUpload();
          }
        });
      });
      request.once("finish", () => {
        uploadFinished = true;
        if (timings.connect) {
          onUpload();
        }
      });
      request.once("response", (response) => {
        timings.response = Date.now();
        timings.phases.firstByte = timings.response - timings.upload;
        handleError(response);
        response.once("end", () => {
          timings.end = Date.now();
          timings.phases.download = timings.end - timings.response;
          timings.phases.total = timings.end - timings.start;
        });
      });
      return timings;
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/utils/timed-out.js
var require_timed_out = __commonJS({
  "../node_modules/package-json/node_modules/got/source/utils/timed-out.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var TimeoutError = class extends Error {
      constructor(threshold, event) {
        super(`Timeout awaiting '${event}' for ${threshold}ms`);
        this.name = "TimeoutError";
        this.code = "ETIMEDOUT";
        this.event = event;
      }
    };
    var reentry = Symbol("reentry");
    var noop = () => {
    };
    module2.exports = (request, delays, options) => {
      if (request[reentry]) {
        return;
      }
      request[reentry] = true;
      let stopNewTimeouts = false;
      const addTimeout = (delay, callback, ...args) => {
        if (stopNewTimeouts) {
          return noop;
        }
        let immediate;
        const timeout = setTimeout(() => {
          immediate = setImmediate(callback, delay, ...args);
          if (immediate.unref) {
            immediate.unref();
          }
        }, delay);
        if (timeout.unref) {
          timeout.unref();
        }
        const cancel = () => {
          clearTimeout(timeout);
          clearImmediate(immediate);
        };
        cancelers.push(cancel);
        return cancel;
      };
      const { host, hostname } = options;
      const timeoutHandler = (delay, event) => {
        request.emit("error", new TimeoutError(delay, event));
        request.once("error", () => {
        });
        request.abort();
      };
      const cancelers = [];
      const cancelTimeouts = () => {
        stopNewTimeouts = true;
        cancelers.forEach((cancelTimeout) => cancelTimeout());
      };
      request.once("error", cancelTimeouts);
      request.once("response", (response) => {
        response.once("end", cancelTimeouts);
      });
      if (delays.request !== void 0) {
        addTimeout(delays.request, timeoutHandler, "request");
      }
      if (delays.socket !== void 0) {
        const socketTimeoutHandler = () => {
          timeoutHandler(delays.socket, "socket");
        };
        request.setTimeout(delays.socket, socketTimeoutHandler);
        cancelers.push(() => request.removeListener("timeout", socketTimeoutHandler));
      }
      if (delays.lookup !== void 0 && !request.socketPath && !net.isIP(hostname || host)) {
        request.once("socket", (socket) => {
          if (socket.connecting) {
            const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, "lookup");
            socket.once("lookup", cancelTimeout);
          }
        });
      }
      if (delays.connect !== void 0) {
        request.once("socket", (socket) => {
          if (socket.connecting) {
            const timeConnect = () => addTimeout(delays.connect, timeoutHandler, "connect");
            if (request.socketPath || net.isIP(hostname || host)) {
              socket.once("connect", timeConnect());
            } else {
              socket.once("lookup", (error) => {
                if (error === null) {
                  socket.once("connect", timeConnect());
                }
              });
            }
          }
        });
      }
      if (delays.secureConnect !== void 0 && options.protocol === "https:") {
        request.once("socket", (socket) => {
          if (socket.connecting) {
            socket.once("connect", () => {
              const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, "secureConnect");
              socket.once("secureConnect", cancelTimeout);
            });
          }
        });
      }
      if (delays.send !== void 0) {
        request.once("socket", (socket) => {
          const timeRequest = () => addTimeout(delays.send, timeoutHandler, "send");
          if (socket.connecting) {
            socket.once("connect", () => {
              request.once("upload-complete", timeRequest());
            });
          } else {
            request.once("upload-complete", timeRequest());
          }
        });
      }
      if (delays.response !== void 0) {
        request.once("upload-complete", () => {
          const cancelTimeout = addTimeout(delays.response, timeoutHandler, "response");
          request.once("response", cancelTimeout);
        });
      }
    };
    module2.exports.TimeoutError = TimeoutError;
  }
});

// ../node_modules/package-json/node_modules/got/source/utils/is-form-data.js
var require_is_form_data = __commonJS({
  "../node_modules/package-json/node_modules/got/source/utils/is-form-data.js"(exports2, module2) {
    "use strict";
    var is = require_dist();
    module2.exports = (body) => is.nodeStream(body) && is.function(body.getBoundary);
  }
});

// ../node_modules/package-json/node_modules/got/source/utils/get-body-size.js
var require_get_body_size = __commonJS({
  "../node_modules/package-json/node_modules/got/source/utils/get-body-size.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var util = require("util");
    var is = require_dist();
    var isFormData = require_is_form_data();
    module2.exports = async (options) => {
      const { body } = options;
      if (options.headers["content-length"]) {
        return Number(options.headers["content-length"]);
      }
      if (!body && !options.stream) {
        return 0;
      }
      if (is.string(body)) {
        return Buffer.byteLength(body);
      }
      if (isFormData(body)) {
        return util.promisify(body.getLength.bind(body))();
      }
      if (body instanceof fs.ReadStream) {
        const { size } = await util.promisify(fs.stat)(body.path);
        return size;
      }
      return null;
    };
  }
});

// ../node_modules/decompress-response/index.js
var require_decompress_response = __commonJS({
  "../node_modules/decompress-response/index.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    var zlib = require("zlib");
    var mimicResponse = require_mimic_response();
    module2.exports = (response) => {
      if (["gzip", "deflate"].indexOf(response.headers["content-encoding"]) === -1) {
        return response;
      }
      const unzip = zlib.createUnzip();
      const stream2 = new PassThrough();
      mimicResponse(response, stream2);
      unzip.on("error", (err) => {
        if (err.code === "Z_BUF_ERROR") {
          stream2.end();
          return;
        }
        stream2.emit("error", err);
      });
      response.pipe(unzip).pipe(stream2);
      return stream2;
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/progress.js
var require_progress = __commonJS({
  "../node_modules/package-json/node_modules/got/source/progress.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2 } = require("stream");
    module2.exports = {
      download(response, emitter, downloadBodySize) {
        let downloaded = 0;
        return new Transform2({
          transform(chunk, encoding, callback) {
            downloaded += chunk.length;
            const percent = downloadBodySize ? downloaded / downloadBodySize : 0;
            if (percent < 1) {
              emitter.emit("downloadProgress", {
                percent,
                transferred: downloaded,
                total: downloadBodySize
              });
            }
            callback(null, chunk);
          },
          flush(callback) {
            emitter.emit("downloadProgress", {
              percent: 1,
              transferred: downloaded,
              total: downloadBodySize
            });
            callback();
          }
        });
      },
      upload(request, emitter, uploadBodySize) {
        const uploadEventFrequency = 150;
        let uploaded = 0;
        let progressInterval;
        emitter.emit("uploadProgress", {
          percent: 0,
          transferred: 0,
          total: uploadBodySize
        });
        request.once("error", () => {
          clearInterval(progressInterval);
        });
        request.once("response", () => {
          clearInterval(progressInterval);
          emitter.emit("uploadProgress", {
            percent: 1,
            transferred: uploaded,
            total: uploadBodySize
          });
        });
        request.once("socket", (socket) => {
          const onSocketConnect = () => {
            progressInterval = setInterval(() => {
              const lastUploaded = uploaded;
              const headersSize = request._header ? Buffer.byteLength(request._header) : 0;
              uploaded = socket.bytesWritten - headersSize;
              if (uploaded === lastUploaded || uploaded === uploadBodySize) {
                return;
              }
              emitter.emit("uploadProgress", {
                percent: uploadBodySize ? uploaded / uploadBodySize : 0,
                transferred: uploaded,
                total: uploadBodySize
              });
            }, uploadEventFrequency);
          };
          if (socket.connecting) {
            socket.once("connect", onSocketConnect);
          } else if (socket.writable) {
            onSocketConnect();
          }
        });
      }
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/get-response.js
var require_get_response = __commonJS({
  "../node_modules/package-json/node_modules/got/source/get-response.js"(exports2, module2) {
    "use strict";
    var decompressResponse = require_decompress_response();
    var is = require_dist();
    var mimicResponse = require_mimic_response();
    var progress = require_progress();
    module2.exports = (response, options, emitter) => {
      const downloadBodySize = Number(response.headers["content-length"]) || null;
      const progressStream = progress.download(response, emitter, downloadBodySize);
      mimicResponse(response, progressStream);
      const newResponse = options.decompress === true && is.function(decompressResponse) && options.method !== "HEAD" ? decompressResponse(progressStream) : progressStream;
      if (!options.decompress && ["gzip", "deflate"].includes(response.headers["content-encoding"])) {
        options.encoding = null;
      }
      emitter.emit("response", newResponse);
      emitter.emit("downloadProgress", {
        percent: 0,
        transferred: 0,
        total: downloadBodySize
      });
      response.pipe(progressStream);
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/utils/url-to-options.js
var require_url_to_options = __commonJS({
  "../node_modules/package-json/node_modules/got/source/utils/url-to-options.js"(exports2, module2) {
    "use strict";
    var is = require_dist();
    module2.exports = (url) => {
      const options = {
        protocol: url.protocol,
        hostname: url.hostname.startsWith("[") ? url.hostname.slice(1, -1) : url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        href: url.href
      };
      if (is.string(url.port) && url.port.length > 0) {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
      }
      options.path = is.null(url.search) ? url.pathname : `${url.pathname}${url.search}`;
      return options;
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/request-as-event-emitter.js
var require_request_as_event_emitter = __commonJS({
  "../node_modules/package-json/node_modules/got/source/request-as-event-emitter.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var util = require("util");
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var urlLib = require("url");
    var CacheableRequest = require_src5();
    var toReadableStream = require_to_readable_stream();
    var is = require_dist();
    var timer = require_source2();
    var timedOut = require_timed_out();
    var getBodySize = require_get_body_size();
    var getResponse = require_get_response();
    var progress = require_progress();
    var { CacheError, UnsupportedProtocolError, MaxRedirectsError, RequestError, TimeoutError } = require_errors2();
    var urlToOptions = require_url_to_options();
    var getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);
    var allMethodRedirectCodes = new Set([300, 303, 307, 308]);
    module2.exports = (options, input) => {
      const emitter = new EventEmitter();
      const redirects = [];
      let currentRequest;
      let requestUrl;
      let redirectString;
      let uploadBodySize;
      let retryCount = 0;
      let shouldAbort = false;
      const setCookie = options.cookieJar ? util.promisify(options.cookieJar.setCookie.bind(options.cookieJar)) : null;
      const getCookieString = options.cookieJar ? util.promisify(options.cookieJar.getCookieString.bind(options.cookieJar)) : null;
      const agents = is.object(options.agent) ? options.agent : null;
      const emitError = async (error) => {
        try {
          for (const hook of options.hooks.beforeError) {
            error = await hook(error);
          }
          emitter.emit("error", error);
        } catch (error2) {
          emitter.emit("error", error2);
        }
      };
      const get = async (options2) => {
        const currentUrl = redirectString || requestUrl;
        if (options2.protocol !== "http:" && options2.protocol !== "https:") {
          throw new UnsupportedProtocolError(options2);
        }
        decodeURI(currentUrl);
        let fn;
        if (is.function(options2.request)) {
          fn = { request: options2.request };
        } else {
          fn = options2.protocol === "https:" ? https : http;
        }
        if (agents) {
          const protocolName = options2.protocol === "https:" ? "https" : "http";
          options2.agent = agents[protocolName] || options2.agent;
        }
        if (options2.useElectronNet && process.versions.electron) {
          const r = { x: require }["yx".slice(1)];
          const electron = r("electron");
          fn = electron.net || electron.remote.net;
        }
        if (options2.cookieJar) {
          const cookieString = await getCookieString(currentUrl, {});
          if (is.nonEmptyString(cookieString)) {
            options2.headers.cookie = cookieString;
          }
        }
        let timings;
        const handleResponse = async (response) => {
          try {
            if (options2.useElectronNet) {
              response = new Proxy(response, {
                get: (target, name) => {
                  if (name === "trailers" || name === "rawTrailers") {
                    return [];
                  }
                  const value = target[name];
                  return is.function(value) ? value.bind(target) : value;
                }
              });
            }
            const { statusCode } = response;
            response.url = currentUrl;
            response.requestUrl = requestUrl;
            response.retryCount = retryCount;
            response.timings = timings;
            response.redirectUrls = redirects;
            response.request = {
              gotOptions: options2
            };
            const rawCookies = response.headers["set-cookie"];
            if (options2.cookieJar && rawCookies) {
              await Promise.all(rawCookies.map((rawCookie) => setCookie(rawCookie, response.url)));
            }
            if (options2.followRedirect && "location" in response.headers) {
              if (allMethodRedirectCodes.has(statusCode) || getMethodRedirectCodes.has(statusCode) && (options2.method === "GET" || options2.method === "HEAD")) {
                response.resume();
                if (statusCode === 303) {
                  options2.method = "GET";
                }
                if (redirects.length >= 10) {
                  throw new MaxRedirectsError(statusCode, redirects, options2);
                }
                const redirectBuffer = Buffer.from(response.headers.location, "binary").toString();
                const redirectURL = new URL2(redirectBuffer, currentUrl);
                redirectString = redirectURL.toString();
                redirects.push(redirectString);
                const redirectOptions = __spreadValues(__spreadValues({}, options2), urlToOptions(redirectURL));
                for (const hook of options2.hooks.beforeRedirect) {
                  await hook(redirectOptions);
                }
                emitter.emit("redirect", response, redirectOptions);
                await get(redirectOptions);
                return;
              }
            }
            getResponse(response, options2, emitter);
          } catch (error) {
            emitError(error);
          }
        };
        const handleRequest = (request) => {
          if (shouldAbort) {
            request.once("error", () => {
            });
            request.abort();
            return;
          }
          currentRequest = request;
          request.once("error", (error) => {
            if (request.aborted) {
              return;
            }
            if (error instanceof timedOut.TimeoutError) {
              error = new TimeoutError(error, options2);
            } else {
              error = new RequestError(error, options2);
            }
            if (emitter.retry(error) === false) {
              emitError(error);
            }
          });
          timings = timer(request);
          progress.upload(request, emitter, uploadBodySize);
          if (options2.gotTimeout) {
            timedOut(request, options2.gotTimeout, options2);
          }
          emitter.emit("request", request);
          const uploadComplete = () => {
            request.emit("upload-complete");
          };
          try {
            if (is.nodeStream(options2.body)) {
              options2.body.once("end", uploadComplete);
              options2.body.pipe(request);
              options2.body = void 0;
            } else if (options2.body) {
              request.end(options2.body, uploadComplete);
            } else if (input && (options2.method === "POST" || options2.method === "PUT" || options2.method === "PATCH")) {
              input.once("end", uploadComplete);
              input.pipe(request);
            } else {
              request.end(uploadComplete);
            }
          } catch (error) {
            emitError(new RequestError(error, options2));
          }
        };
        if (options2.cache) {
          const cacheableRequest = new CacheableRequest(fn.request, options2.cache);
          const cacheRequest = cacheableRequest(options2, handleResponse);
          cacheRequest.once("error", (error) => {
            if (error instanceof CacheableRequest.RequestError) {
              emitError(new RequestError(error, options2));
            } else {
              emitError(new CacheError(error, options2));
            }
          });
          cacheRequest.once("request", handleRequest);
        } else {
          try {
            handleRequest(fn.request(options2, handleResponse));
          } catch (error) {
            emitError(new RequestError(error, options2));
          }
        }
      };
      emitter.retry = (error) => {
        let backoff;
        try {
          backoff = options.retry.retries(++retryCount, error);
        } catch (error2) {
          emitError(error2);
          return;
        }
        if (backoff) {
          const retry = async (options2) => {
            try {
              for (const hook of options2.hooks.beforeRetry) {
                await hook(options2, error, retryCount);
              }
              await get(options2);
            } catch (error2) {
              emitError(error2);
            }
          };
          setTimeout(retry, backoff, __spreadProps(__spreadValues({}, options), { forceRefresh: true }));
          return true;
        }
        return false;
      };
      emitter.abort = () => {
        if (currentRequest) {
          currentRequest.once("error", () => {
          });
          currentRequest.abort();
        } else {
          shouldAbort = true;
        }
      };
      setImmediate(async () => {
        try {
          const { body } = options;
          if (is.buffer(body)) {
            options.body = toReadableStream(body);
            uploadBodySize = body.length;
          } else {
            uploadBodySize = await getBodySize(options);
          }
          if (is.undefined(options.headers["content-length"]) && is.undefined(options.headers["transfer-encoding"])) {
            if ((uploadBodySize > 0 || options.method === "PUT") && !is.null(uploadBodySize)) {
              options.headers["content-length"] = uploadBodySize;
            }
          }
          for (const hook of options.hooks.beforeRequest) {
            await hook(options);
          }
          requestUrl = options.href || new URL2(options.path, urlLib.format(options)).toString();
          await get(options);
        } catch (error) {
          emitError(error);
        }
      });
      return emitter;
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/as-stream.js
var require_as_stream = __commonJS({
  "../node_modules/package-json/node_modules/got/source/as-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    var duplexer3 = require_duplexer3();
    var requestAsEventEmitter = require_request_as_event_emitter();
    var { HTTPError, ReadError } = require_errors2();
    module2.exports = (options) => {
      const input = new PassThrough();
      const output = new PassThrough();
      const proxy = duplexer3(input, output);
      const piped = new Set();
      let isFinished = false;
      options.retry.retries = () => 0;
      if (options.body) {
        proxy.write = () => {
          throw new Error("Got's stream is not writable when the `body` option is used");
        };
      }
      const emitter = requestAsEventEmitter(options, input);
      proxy._destroy = emitter.abort;
      emitter.on("response", (response) => {
        const { statusCode } = response;
        response.on("error", (error) => {
          proxy.emit("error", new ReadError(error, options));
        });
        if (options.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {
          proxy.emit("error", new HTTPError(response, options), null, response);
          return;
        }
        isFinished = true;
        response.pipe(output);
        for (const destination of piped) {
          if (destination.headersSent) {
            continue;
          }
          for (const [key, value] of Object.entries(response.headers)) {
            const allowed = options.decompress ? key !== "content-encoding" : true;
            if (allowed) {
              destination.setHeader(key, value);
            }
          }
          destination.statusCode = response.statusCode;
        }
        proxy.emit("response", response);
      });
      [
        "error",
        "request",
        "redirect",
        "uploadProgress",
        "downloadProgress"
      ].forEach((event) => emitter.on(event, (...args) => proxy.emit(event, ...args)));
      const pipe = proxy.pipe.bind(proxy);
      const unpipe = proxy.unpipe.bind(proxy);
      proxy.pipe = (destination, options2) => {
        if (isFinished) {
          throw new Error("Failed to pipe. The response has been emitted already.");
        }
        const result = pipe(destination, options2);
        if (Reflect.has(destination, "setHeader")) {
          piped.add(destination);
        }
        return result;
      };
      proxy.unpipe = (stream2) => {
        piped.delete(stream2);
        return unpipe(stream2);
      };
      return proxy;
    };
  }
});

// ../node_modules/get-stream/buffer-stream.js
var require_buffer_stream2 = __commonJS({
  "../node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough } = require("stream");
    module2.exports = (options) => {
      options = Object.assign({}, options);
      const { array } = options;
      let { encoding } = options;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = () => len;
      return stream2;
    };
  }
});

// ../node_modules/get-stream/index.js
var require_get_stream2 = __commonJS({
  "../node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var pump = require_pump();
    var bufferStream = require_buffer_stream2();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream(inputStream, options) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      options = Object.assign({ maxBuffer: Infinity }, options);
      const { maxBuffer } = options;
      let stream2;
      return new Promise((resolve2, reject2) => {
        const rejectPromise = (error) => {
          if (error) {
            error.bufferedData = stream2.getBufferedValue();
          }
          reject2(error);
        };
        stream2 = pump(inputStream, bufferStream(options), (error) => {
          if (error) {
            rejectPromise(error);
            return;
          }
          resolve2();
        });
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            rejectPromise(new MaxBufferError());
          }
        });
      }).then(() => stream2.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, options) => getStream(stream2, Object.assign({}, options, { encoding: "buffer" }));
    module2.exports.array = (stream2, options) => getStream(stream2, Object.assign({}, options, { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// ../node_modules/package-json/node_modules/got/source/known-hook-events.js
var require_known_hook_events = __commonJS({
  "../node_modules/package-json/node_modules/got/source/known-hook-events.js"(exports2, module2) {
    "use strict";
    module2.exports = [
      "beforeError",
      "init",
      "beforeRequest",
      "beforeRedirect",
      "beforeRetry",
      "afterResponse"
    ];
  }
});

// ../node_modules/package-json/node_modules/got/source/merge.js
var require_merge = __commonJS({
  "../node_modules/package-json/node_modules/got/source/merge.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var is = require_dist();
    var knownHookEvents = require_known_hook_events();
    var merge = (target, ...sources) => {
      for (const source of sources) {
        for (const [key, sourceValue] of Object.entries(source)) {
          if (is.undefined(sourceValue)) {
            continue;
          }
          const targetValue = target[key];
          if (is.urlInstance(targetValue) && (is.urlInstance(sourceValue) || is.string(sourceValue))) {
            target[key] = new URL2(sourceValue, targetValue);
          } else if (is.plainObject(sourceValue)) {
            if (is.plainObject(targetValue)) {
              target[key] = merge({}, targetValue, sourceValue);
            } else {
              target[key] = merge({}, sourceValue);
            }
          } else if (is.array(sourceValue)) {
            target[key] = merge([], sourceValue);
          } else {
            target[key] = sourceValue;
          }
        }
      }
      return target;
    };
    var mergeOptions = (...sources) => {
      sources = sources.map((source) => source || {});
      const merged = merge({}, ...sources);
      const hooks = {};
      for (const hook of knownHookEvents) {
        hooks[hook] = [];
      }
      for (const source of sources) {
        if (source.hooks) {
          for (const hook of knownHookEvents) {
            hooks[hook] = hooks[hook].concat(source.hooks[hook]);
          }
        }
      }
      merged.hooks = hooks;
      return merged;
    };
    var mergeInstances = (instances, methods) => {
      const handlers = instances.map((instance) => instance.defaults.handler);
      const size = instances.length - 1;
      return {
        methods,
        options: mergeOptions(...instances.map((instance) => instance.defaults.options)),
        handler: (options, next) => {
          let iteration = -1;
          const iterate = (options2) => handlers[++iteration](options2, iteration === size ? next : iterate);
          return iterate(options);
        }
      };
    };
    module2.exports = merge;
    module2.exports.options = mergeOptions;
    module2.exports.instances = mergeInstances;
  }
});

// ../node_modules/prepend-http/index.js
var require_prepend_http = __commonJS({
  "../node_modules/prepend-http/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (url, opts) => {
      if (typeof url !== "string") {
        throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof url}\``);
      }
      url = url.trim();
      opts = Object.assign({ https: false }, opts);
      if (/^\.*\/|^(?!localhost)\w+:/.test(url)) {
        return url;
      }
      return url.replace(/^(?!(?:\w+:)?\/\/)/, opts.https ? "https://" : "http://");
    };
  }
});

// ../node_modules/url-parse-lax/index.js
var require_url_parse_lax = __commonJS({
  "../node_modules/url-parse-lax/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var prependHttp = require_prepend_http();
    module2.exports = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError(`Expected \`url\` to be of type \`string\`, got \`${typeof input}\` instead.`);
      }
      const finalUrl = prependHttp(input, Object.assign({ https: true }, options));
      return url.parse(finalUrl);
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/normalize-arguments.js
var require_normalize_arguments = __commonJS({
  "../node_modules/package-json/node_modules/got/source/normalize-arguments.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require("url");
    var urlLib = require("url");
    var is = require_dist();
    var urlParseLax = require_url_parse_lax();
    var lowercaseKeys = require_lowercase_keys();
    var urlToOptions = require_url_to_options();
    var isFormData = require_is_form_data();
    var merge = require_merge();
    var knownHookEvents = require_known_hook_events();
    var retryAfterStatusCodes = new Set([413, 429, 503]);
    var preNormalize = (options, defaults) => {
      if (is.nullOrUndefined(options.headers)) {
        options.headers = {};
      } else {
        options.headers = lowercaseKeys(options.headers);
      }
      if (options.baseUrl && !options.baseUrl.toString().endsWith("/")) {
        options.baseUrl += "/";
      }
      if (options.stream) {
        options.json = false;
      }
      if (is.nullOrUndefined(options.hooks)) {
        options.hooks = {};
      } else if (!is.object(options.hooks)) {
        throw new TypeError(`Parameter \`hooks\` must be an object, not ${is(options.hooks)}`);
      }
      for (const event of knownHookEvents) {
        if (is.nullOrUndefined(options.hooks[event])) {
          if (defaults) {
            options.hooks[event] = [...defaults.hooks[event]];
          } else {
            options.hooks[event] = [];
          }
        }
      }
      if (is.number(options.timeout)) {
        options.gotTimeout = { request: options.timeout };
      } else if (is.object(options.timeout)) {
        options.gotTimeout = options.timeout;
      }
      delete options.timeout;
      const { retry } = options;
      options.retry = {
        retries: 0,
        methods: [],
        statusCodes: [],
        errorCodes: []
      };
      if (is.nonEmptyObject(defaults) && retry !== false) {
        options.retry = __spreadValues({}, defaults.retry);
      }
      if (retry !== false) {
        if (is.number(retry)) {
          options.retry.retries = retry;
        } else {
          options.retry = __spreadValues(__spreadValues({}, options.retry), retry);
        }
      }
      if (options.gotTimeout) {
        options.retry.maxRetryAfter = Math.min(...[options.gotTimeout.request, options.gotTimeout.connection].filter((n) => !is.nullOrUndefined(n)));
      }
      if (is.array(options.retry.methods)) {
        options.retry.methods = new Set(options.retry.methods.map((method) => method.toUpperCase()));
      }
      if (is.array(options.retry.statusCodes)) {
        options.retry.statusCodes = new Set(options.retry.statusCodes);
      }
      if (is.array(options.retry.errorCodes)) {
        options.retry.errorCodes = new Set(options.retry.errorCodes);
      }
      return options;
    };
    var normalize = (url, options, defaults) => {
      if (is.plainObject(url)) {
        options = __spreadValues(__spreadValues({}, url), options);
        url = options.url || {};
        delete options.url;
      }
      if (defaults) {
        options = merge({}, defaults.options, options ? preNormalize(options, defaults.options) : {});
      } else {
        options = merge({}, preNormalize(options));
      }
      if (!is.string(url) && !is.object(url)) {
        throw new TypeError(`Parameter \`url\` must be a string or object, not ${is(url)}`);
      }
      if (is.string(url)) {
        if (options.baseUrl) {
          if (url.toString().startsWith("/")) {
            url = url.toString().slice(1);
          }
          url = urlToOptions(new URL2(url, options.baseUrl));
        } else {
          url = url.replace(/^unix:/, "http://$&");
          url = urlParseLax(url);
        }
      } else if (is(url) === "URL") {
        url = urlToOptions(url);
      }
      options = merge({ path: "" }, url, { protocol: url.protocol || "https:" }, options);
      for (const hook of options.hooks.init) {
        const called = hook(options);
        if (is.promise(called)) {
          throw new TypeError("The `init` hook must be a synchronous function");
        }
      }
      const { baseUrl } = options;
      Object.defineProperty(options, "baseUrl", {
        set: () => {
          throw new Error("Failed to set baseUrl. Options are normalized already.");
        },
        get: () => baseUrl
      });
      const { query } = options;
      if (is.nonEmptyString(query) || is.nonEmptyObject(query) || query instanceof URLSearchParams2) {
        if (!is.string(query)) {
          options.query = new URLSearchParams2(query).toString();
        }
        options.path = `${options.path.split("?")[0]}?${options.query}`;
        delete options.query;
      }
      if (options.hostname === "unix") {
        const matches = /(.+?):(.+)/.exec(options.path);
        if (matches) {
          const [, socketPath, path] = matches;
          options = __spreadProps(__spreadValues({}, options), {
            socketPath,
            path,
            host: null
          });
        }
      }
      const { headers } = options;
      for (const [key, value] of Object.entries(headers)) {
        if (is.nullOrUndefined(value)) {
          delete headers[key];
        }
      }
      if (options.json && is.undefined(headers.accept)) {
        headers.accept = "application/json";
      }
      if (options.decompress && is.undefined(headers["accept-encoding"])) {
        headers["accept-encoding"] = "gzip, deflate";
      }
      const { body } = options;
      if (is.nullOrUndefined(body)) {
        options.method = options.method ? options.method.toUpperCase() : "GET";
      } else {
        const isObject = is.object(body) && !is.buffer(body) && !is.nodeStream(body);
        if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(options.form || options.json)) {
          throw new TypeError("The `body` option must be a stream.Readable, string or Buffer");
        }
        if (options.json && !(isObject || is.array(body))) {
          throw new TypeError("The `body` option must be an Object or Array when the `json` option is used");
        }
        if (options.form && !isObject) {
          throw new TypeError("The `body` option must be an Object when the `form` option is used");
        }
        if (isFormData(body)) {
          headers["content-type"] = headers["content-type"] || `multipart/form-data; boundary=${body.getBoundary()}`;
        } else if (options.form) {
          headers["content-type"] = headers["content-type"] || "application/x-www-form-urlencoded";
          options.body = new URLSearchParams2(body).toString();
        } else if (options.json) {
          headers["content-type"] = headers["content-type"] || "application/json";
          options.body = JSON.stringify(body);
        }
        options.method = options.method ? options.method.toUpperCase() : "POST";
      }
      if (!is.function(options.retry.retries)) {
        const { retries } = options.retry;
        options.retry.retries = (iteration, error) => {
          if (iteration > retries) {
            return 0;
          }
          if ((!error || !options.retry.errorCodes.has(error.code)) && (!options.retry.methods.has(error.method) || !options.retry.statusCodes.has(error.statusCode))) {
            return 0;
          }
          if (Reflect.has(error, "headers") && Reflect.has(error.headers, "retry-after") && retryAfterStatusCodes.has(error.statusCode)) {
            let after = Number(error.headers["retry-after"]);
            if (is.nan(after)) {
              after = Date.parse(error.headers["retry-after"]) - Date.now();
            } else {
              after *= 1e3;
            }
            if (after > options.retry.maxRetryAfter) {
              return 0;
            }
            return after;
          }
          if (error.statusCode === 413) {
            return 0;
          }
          const noise = Math.random() * 100;
          return 2 ** (iteration - 1) * 1e3 + noise;
        };
      }
      return options;
    };
    var reNormalize = (options) => normalize(urlLib.format(options), options);
    module2.exports = normalize;
    module2.exports.preNormalize = preNormalize;
    module2.exports.reNormalize = reNormalize;
  }
});

// ../node_modules/package-json/node_modules/got/source/as-promise.js
var require_as_promise = __commonJS({
  "../node_modules/package-json/node_modules/got/source/as-promise.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var getStream = require_get_stream2();
    var is = require_dist();
    var PCancelable = require_p_cancelable();
    var requestAsEventEmitter = require_request_as_event_emitter();
    var { HTTPError, ParseError, ReadError } = require_errors2();
    var { options: mergeOptions } = require_merge();
    var { reNormalize } = require_normalize_arguments();
    var asPromise = (options) => {
      const proxy = new EventEmitter();
      const promise = new PCancelable((resolve2, reject2, onCancel) => {
        const emitter = requestAsEventEmitter(options);
        onCancel(emitter.abort);
        emitter.on("response", async (response) => {
          proxy.emit("response", response);
          const stream2 = is.null(options.encoding) ? getStream.buffer(response) : getStream(response, options);
          let data;
          try {
            data = await stream2;
          } catch (error) {
            reject2(new ReadError(error, options));
            return;
          }
          const limitStatusCode = options.followRedirect ? 299 : 399;
          response.body = data;
          try {
            for (const [index, hook] of Object.entries(options.hooks.afterResponse)) {
              response = await hook(response, (updatedOptions) => {
                updatedOptions = reNormalize(mergeOptions(options, __spreadProps(__spreadValues({}, updatedOptions), {
                  retry: 0,
                  throwHttpErrors: false
                })));
                updatedOptions.hooks.afterResponse = options.hooks.afterResponse.slice(0, index);
                return asPromise(updatedOptions);
              });
            }
          } catch (error) {
            reject2(error);
            return;
          }
          const { statusCode } = response;
          if (options.json && response.body) {
            try {
              response.body = JSON.parse(response.body);
            } catch (error) {
              if (statusCode >= 200 && statusCode < 300) {
                const parseError = new ParseError(error, statusCode, options, data);
                Object.defineProperty(parseError, "response", { value: response });
                reject2(parseError);
                return;
              }
            }
          }
          if (statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {
            const error = new HTTPError(response, options);
            Object.defineProperty(error, "response", { value: response });
            if (emitter.retry(error) === false) {
              if (options.throwHttpErrors) {
                reject2(error);
                return;
              }
              resolve2(response);
            }
            return;
          }
          resolve2(response);
        });
        emitter.once("error", reject2);
        [
          "request",
          "redirect",
          "uploadProgress",
          "downloadProgress"
        ].forEach((event) => emitter.on(event, (...args) => proxy.emit(event, ...args)));
      });
      promise.on = (name, fn) => {
        proxy.on(name, fn);
        return promise;
      };
      return promise;
    };
    module2.exports = asPromise;
  }
});

// ../node_modules/package-json/node_modules/got/source/utils/deep-freeze.js
var require_deep_freeze = __commonJS({
  "../node_modules/package-json/node_modules/got/source/utils/deep-freeze.js"(exports2, module2) {
    "use strict";
    var is = require_dist();
    module2.exports = function deepFreeze(object) {
      for (const [key, value] of Object.entries(object)) {
        if (is.plainObject(value) || is.array(value)) {
          deepFreeze(object[key]);
        }
      }
      return Object.freeze(object);
    };
  }
});

// ../node_modules/package-json/node_modules/got/source/create.js
var require_create2 = __commonJS({
  "../node_modules/package-json/node_modules/got/source/create.js"(exports2, module2) {
    "use strict";
    var errors = require_errors2();
    var asStream = require_as_stream();
    var asPromise = require_as_promise();
    var normalizeArguments = require_normalize_arguments();
    var merge = require_merge();
    var deepFreeze = require_deep_freeze();
    var getPromiseOrStream = (options) => options.stream ? asStream(options) : asPromise(options);
    var aliases = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    var create = (defaults) => {
      defaults = merge({}, defaults);
      normalizeArguments.preNormalize(defaults.options);
      if (!defaults.handler) {
        defaults.handler = (options, next) => next(options);
      }
      function got(url, options) {
        try {
          return defaults.handler(normalizeArguments(url, options, defaults), getPromiseOrStream);
        } catch (error) {
          if (options && options.stream) {
            throw error;
          } else {
            return Promise.reject(error);
          }
        }
      }
      got.create = create;
      got.extend = (options) => {
        let mutableDefaults;
        if (options && Reflect.has(options, "mutableDefaults")) {
          mutableDefaults = options.mutableDefaults;
          delete options.mutableDefaults;
        } else {
          mutableDefaults = defaults.mutableDefaults;
        }
        return create({
          options: merge.options(defaults.options, options),
          handler: defaults.handler,
          mutableDefaults
        });
      };
      got.mergeInstances = (...args) => create(merge.instances(args));
      got.stream = (url, options) => got(url, __spreadProps(__spreadValues({}, options), { stream: true }));
      for (const method of aliases) {
        got[method] = (url, options) => got(url, __spreadProps(__spreadValues({}, options), { method }));
        got.stream[method] = (url, options) => got.stream(url, __spreadProps(__spreadValues({}, options), { method }));
      }
      Object.assign(got, __spreadProps(__spreadValues({}, errors), { mergeOptions: merge.options }));
      Object.defineProperty(got, "defaults", {
        value: defaults.mutableDefaults ? defaults : deepFreeze(defaults),
        writable: defaults.mutableDefaults,
        configurable: defaults.mutableDefaults,
        enumerable: true
      });
      return got;
    };
    module2.exports = create;
  }
});

// ../node_modules/package-json/node_modules/got/source/index.js
var require_source3 = __commonJS({
  "../node_modules/package-json/node_modules/got/source/index.js"(exports2, module2) {
    "use strict";
    var pkg = require_package();
    var create = require_create2();
    var defaults = {
      options: {
        retry: {
          retries: 2,
          methods: [
            "GET",
            "PUT",
            "HEAD",
            "DELETE",
            "OPTIONS",
            "TRACE"
          ],
          statusCodes: [
            408,
            413,
            429,
            500,
            502,
            503,
            504
          ],
          errorCodes: [
            "ETIMEDOUT",
            "ECONNRESET",
            "EADDRINUSE",
            "ECONNREFUSED",
            "EPIPE",
            "ENOTFOUND",
            "ENETUNREACH",
            "EAI_AGAIN"
          ]
        },
        headers: {
          "user-agent": `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`
        },
        hooks: {
          beforeRequest: [],
          beforeRedirect: [],
          beforeRetry: [],
          afterResponse: []
        },
        decompress: true,
        throwHttpErrors: true,
        followRedirect: true,
        stream: false,
        form: false,
        json: false,
        cache: false,
        useElectronNet: false
      },
      mutableDefaults: false
    };
    var got = create(defaults);
    module2.exports = got;
  }
});

// ../node_modules/rc/node_modules/ini/ini.js
var require_ini = __commonJS({
  "../node_modules/rc/node_modules/ini/ini.js"(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _2, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _2, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _2, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _2, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _3, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _2, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_2) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// ../node_modules/rc/node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS({
  "../node_modules/rc/node_modules/strip-json-comments/index.js"(exports2, module2) {
    "use strict";
    var singleComment = 1;
    var multiComment = 2;
    function stripWithoutWhitespace() {
      return "";
    }
    function stripWithWhitespace(str, start, end) {
      return str.slice(start, end).replace(/\S/g, " ");
    }
    module2.exports = function(str, opts) {
      opts = opts || {};
      var currentChar;
      var nextChar;
      var insideString = false;
      var insideComment = false;
      var offset = 0;
      var ret = "";
      var strip = opts.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
      for (var i = 0; i < str.length; i++) {
        currentChar = str[i];
        nextChar = str[i + 1];
        if (!insideComment && currentChar === '"') {
          var escaped = str[i - 1] === "\\" && str[i - 2] !== "\\";
          if (!escaped) {
            insideString = !insideString;
          }
        }
        if (insideString) {
          continue;
        }
        if (!insideComment && currentChar + nextChar === "//") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = singleComment;
          i++;
        } else if (insideComment === singleComment && currentChar + nextChar === "\r\n") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
          continue;
        } else if (insideComment === singleComment && currentChar === "\n") {
          insideComment = false;
          ret += strip(str, offset, i);
          offset = i;
        } else if (!insideComment && currentChar + nextChar === "/*") {
          ret += str.slice(offset, i);
          offset = i;
          insideComment = multiComment;
          i++;
          continue;
        } else if (insideComment === multiComment && currentChar + nextChar === "*/") {
          i++;
          insideComment = false;
          ret += strip(str, offset, i + 1);
          offset = i + 1;
          continue;
        }
      }
      return ret + (insideComment ? strip(str.substr(offset)) : str.substr(offset));
    };
  }
});

// ../node_modules/rc/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/rc/lib/utils.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var ini = require_ini();
    var path = require("path");
    var stripJsonComments = require_strip_json_comments();
    var parse = exports2.parse = function(content) {
      if (/^\s*{/.test(content))
        return JSON.parse(stripJsonComments(content));
      return ini.parse(content);
    };
    var file = exports2.file = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      for (var i in args)
        if (typeof args[i] !== "string")
          return;
      var file2 = path.join.apply(null, args);
      var content;
      try {
        return fs.readFileSync(file2, "utf-8");
      } catch (err) {
        return;
      }
    };
    var json = exports2.json = function() {
      var content = file.apply(null, arguments);
      return content ? parse(content) : null;
    };
    var env = exports2.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env2) {
        if (k.toLowerCase().indexOf(prefix.toLowerCase()) === 0) {
          var keypath = k.substring(l).split("__");
          var _emptyStringIndex;
          while ((_emptyStringIndex = keypath.indexOf("")) > -1) {
            keypath.splice(_emptyStringIndex, 1);
          }
          var cursor = obj;
          keypath.forEach(function _buildSubObj(_subkey, i) {
            if (!_subkey || typeof cursor !== "object")
              return;
            if (i === keypath.length - 1)
              cursor[_subkey] = env2[k];
            if (cursor[_subkey] === void 0)
              cursor[_subkey] = {};
            cursor = cursor[_subkey];
          });
        }
      }
      return obj;
    };
    var find = exports2.find = function() {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file2 = path.join(start, rel2);
        try {
          fs.statSync(file2);
          return file2;
        } catch (err) {
          if (path.dirname(start) !== start)
            return find2(path.dirname(start), rel2);
        }
      }
      return find2(process.cwd(), rel);
    };
  }
});

// ../node_modules/deep-extend/lib/deep-extend.js
var require_deep_extend = __commonJS({
  "../node_modules/deep-extend/lib/deep-extend.js"(exports2, module2) {
    "use strict";
    function isSpecificValue(val) {
      return val instanceof Buffer || val instanceof Date || val instanceof RegExp ? true : false;
    }
    function cloneSpecificValue(val) {
      if (val instanceof Buffer) {
        var x = Buffer.alloc ? Buffer.alloc(val.length) : new Buffer(val.length);
        val.copy(x);
        return x;
      } else if (val instanceof Date) {
        return new Date(val.getTime());
      } else if (val instanceof RegExp) {
        return new RegExp(val);
      } else {
        throw new Error("Unexpected situation");
      }
    }
    function deepCloneArray(arr) {
      var clone = [];
      arr.forEach(function(item, index) {
        if (typeof item === "object" && item !== null) {
          if (Array.isArray(item)) {
            clone[index] = deepCloneArray(item);
          } else if (isSpecificValue(item)) {
            clone[index] = cloneSpecificValue(item);
          } else {
            clone[index] = deepExtend({}, item);
          }
        } else {
          clone[index] = item;
        }
      });
      return clone;
    }
    function safeGetProperty(object, property) {
      return property === "__proto__" ? void 0 : object[property];
    }
    var deepExtend = module2.exports = function() {
      if (arguments.length < 1 || typeof arguments[0] !== "object") {
        return false;
      }
      if (arguments.length < 2) {
        return arguments[0];
      }
      var target = arguments[0];
      var args = Array.prototype.slice.call(arguments, 1);
      var val, src, clone;
      args.forEach(function(obj) {
        if (typeof obj !== "object" || obj === null || Array.isArray(obj)) {
          return;
        }
        Object.keys(obj).forEach(function(key) {
          src = safeGetProperty(target, key);
          val = safeGetProperty(obj, key);
          if (val === target) {
            return;
          } else if (typeof val !== "object" || val === null) {
            target[key] = val;
            return;
          } else if (Array.isArray(val)) {
            target[key] = deepCloneArray(val);
            return;
          } else if (isSpecificValue(val)) {
            target[key] = cloneSpecificValue(val);
            return;
          } else if (typeof src !== "object" || src === null || Array.isArray(src)) {
            target[key] = deepExtend({}, val);
            return;
          } else {
            target[key] = deepExtend(src, val);
            return;
          }
        });
      });
      return target;
    };
  }
});

// ../node_modules/rc/index.js
var require_rc = __commonJS({
  "../node_modules/rc/index.js"(exports2, module2) {
    var cc = require_utils();
    var join = require("path").join;
    var deepExtend = require_deep_extend();
    var etc = "/etc";
    var win = process.platform === "win32";
    var home = win ? process.env.USERPROFILE : process.env.HOME;
    module2.exports = function(name, defaults, argv, parse) {
      if (typeof name !== "string")
        throw new Error("rc(name): name *must* be string");
      if (!argv)
        argv = require_minimist()(process.argv.slice(2));
      defaults = (typeof defaults === "string" ? cc.json(defaults) : defaults) || {};
      parse = parse || cc.parse;
      var env = cc.env(name + "_");
      var configs = [defaults];
      var configFiles = [];
      function addConfigFile(file) {
        if (configFiles.indexOf(file) >= 0)
          return;
        var fileConfig = cc.file(file);
        if (fileConfig) {
          configs.push(parse(fileConfig));
          configFiles.push(file);
        }
      }
      if (!win)
        [
          join(etc, name, "config"),
          join(etc, name + "rc")
        ].forEach(addConfigFile);
      if (home)
        [
          join(home, ".config", name, "config"),
          join(home, ".config", name),
          join(home, "." + name, "config"),
          join(home, "." + name + "rc")
        ].forEach(addConfigFile);
      addConfigFile(cc.find("." + name + "rc"));
      if (env.config)
        addConfigFile(env.config);
      if (argv.config)
        addConfigFile(argv.config);
      return deepExtend.apply(null, configs.concat([
        env,
        argv,
        configFiles.length ? { configs: configFiles, config: configFiles[configFiles.length - 1] } : void 0
      ]));
    };
  }
});

// ../node_modules/registry-url/index.js
var require_registry_url = __commonJS({
  "../node_modules/registry-url/index.js"(exports2, module2) {
    "use strict";
    var rc = require_rc();
    var registryUrl = (scope) => {
      const result = rc("npm", { registry: "https://registry.npmjs.org/" });
      const url = result[`${scope}:registry`] || result.config_registry || result.registry;
      return url.slice(-1) === "/" ? url : `${url}/`;
    };
    module2.exports = registryUrl;
    module2.exports.default = registryUrl;
  }
});

// ../node_modules/registry-auth-token/base64.js
var require_base64 = __commonJS({
  "../node_modules/registry-auth-token/base64.js"(exports2, module2) {
    function decodeBase64(base64) {
      return Buffer.from(base64, "base64").toString("utf8");
    }
    function encodeBase64(string) {
      return Buffer.from(string, "utf8").toString("base64");
    }
    module2.exports = {
      decodeBase64,
      encodeBase64
    };
  }
});

// ../node_modules/registry-auth-token/index.js
var require_registry_auth_token = __commonJS({
  "../node_modules/registry-auth-token/index.js"(exports2, module2) {
    var url = require("url");
    var base64 = require_base64();
    var decodeBase64 = base64.decodeBase64;
    var encodeBase64 = base64.encodeBase64;
    var tokenKey = ":_authToken";
    var legacyTokenKey = ":_auth";
    var userKey = ":username";
    var passwordKey = ":_password";
    module2.exports = function() {
      var checkUrl;
      var options;
      if (arguments.length >= 2) {
        checkUrl = arguments[0];
        options = arguments[1];
      } else if (typeof arguments[0] === "string") {
        checkUrl = arguments[0];
      } else {
        options = arguments[0];
      }
      options = options || {};
      options.npmrc = options.npmrc || require_rc()("npm", { registry: "https://registry.npmjs.org/" }, {
        config: process.env.npm_config_userconfig || process.env.NPM_CONFIG_USERCONFIG
      });
      checkUrl = checkUrl || options.npmrc.registry;
      return getRegistryAuthInfo(checkUrl, options) || getLegacyAuthInfo(options.npmrc);
    };
    function getRegistryAuthInfo(checkUrl, options) {
      var parsed = url.parse(checkUrl, false, true);
      var pathname;
      while (pathname !== "/" && parsed.pathname !== pathname) {
        pathname = parsed.pathname || "/";
        var regUrl = "//" + parsed.host + pathname.replace(/\/$/, "");
        var authInfo = getAuthInfoForUrl(regUrl, options.npmrc);
        if (authInfo) {
          return authInfo;
        }
        if (!options.recursive) {
          return /\/$/.test(checkUrl) ? void 0 : getRegistryAuthInfo(url.resolve(checkUrl, "."), options);
        }
        parsed.pathname = url.resolve(normalizePath(pathname), "..") || "/";
      }
      return void 0;
    }
    function getLegacyAuthInfo(npmrc) {
      if (!npmrc._auth) {
        return void 0;
      }
      var token = replaceEnvironmentVariable(npmrc._auth);
      return { token, type: "Basic" };
    }
    function normalizePath(path) {
      return path[path.length - 1] === "/" ? path : path + "/";
    }
    function getAuthInfoForUrl(regUrl, npmrc) {
      var bearerAuth = getBearerToken(npmrc[regUrl + tokenKey] || npmrc[regUrl + "/" + tokenKey]);
      if (bearerAuth) {
        return bearerAuth;
      }
      var username = npmrc[regUrl + userKey] || npmrc[regUrl + "/" + userKey];
      var password = npmrc[regUrl + passwordKey] || npmrc[regUrl + "/" + passwordKey];
      var basicAuth = getTokenForUsernameAndPassword(username, password);
      if (basicAuth) {
        return basicAuth;
      }
      var basicAuthWithToken = getLegacyAuthToken(npmrc[regUrl + legacyTokenKey] || npmrc[regUrl + "/" + legacyTokenKey]);
      if (basicAuthWithToken) {
        return basicAuthWithToken;
      }
      return void 0;
    }
    function replaceEnvironmentVariable(token) {
      return token.replace(/^\$\{?([^}]*)\}?$/, function(fullMatch, envVar) {
        return process.env[envVar];
      });
    }
    function getBearerToken(tok) {
      if (!tok) {
        return void 0;
      }
      var token = replaceEnvironmentVariable(tok);
      return { token, type: "Bearer" };
    }
    function getTokenForUsernameAndPassword(username, password) {
      if (!username || !password) {
        return void 0;
      }
      var pass = decodeBase64(replaceEnvironmentVariable(password));
      var token = encodeBase64(username + ":" + pass);
      return {
        token,
        type: "Basic",
        password: pass,
        username
      };
    }
    function getLegacyAuthToken(tok) {
      if (!tok) {
        return void 0;
      }
      var token = replaceEnvironmentVariable(tok);
      return { token, type: "Basic" };
    }
  }
});

// ../node_modules/package-json/node_modules/semver/semver.js
var require_semver2 = __commonJS({
  "../node_modules/package-json/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var re = exports2.re = [];
    var src = exports2.src = [];
    var t = exports2.tokens = {};
    var R = 0;
    function tok(n) {
      t[n] = R++;
    }
    tok("NUMERICIDENTIFIER");
    src[t.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    tok("NUMERICIDENTIFIERLOOSE");
    src[t.NUMERICIDENTIFIERLOOSE] = "[0-9]+";
    tok("NONNUMERICIDENTIFIER");
    src[t.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-][a-zA-Z0-9-]*";
    tok("MAINVERSION");
    src[t.MAINVERSION] = "(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")\\.(" + src[t.NUMERICIDENTIFIER] + ")";
    tok("MAINVERSIONLOOSE");
    src[t.MAINVERSIONLOOSE] = "(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[t.NUMERICIDENTIFIERLOOSE] + ")";
    tok("PRERELEASEIDENTIFIER");
    src[t.PRERELEASEIDENTIFIER] = "(?:" + src[t.NUMERICIDENTIFIER] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASEIDENTIFIERLOOSE");
    src[t.PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[t.NUMERICIDENTIFIERLOOSE] + "|" + src[t.NONNUMERICIDENTIFIER] + ")";
    tok("PRERELEASE");
    src[t.PRERELEASE] = "(?:-(" + src[t.PRERELEASEIDENTIFIER] + "(?:\\." + src[t.PRERELEASEIDENTIFIER] + ")*))";
    tok("PRERELEASELOOSE");
    src[t.PRERELEASELOOSE] = "(?:-?(" + src[t.PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[t.PRERELEASEIDENTIFIERLOOSE] + ")*))";
    tok("BUILDIDENTIFIER");
    src[t.BUILDIDENTIFIER] = "[0-9A-Za-z-]+";
    tok("BUILD");
    src[t.BUILD] = "(?:\\+(" + src[t.BUILDIDENTIFIER] + "(?:\\." + src[t.BUILDIDENTIFIER] + ")*))";
    tok("FULL");
    tok("FULLPLAIN");
    src[t.FULLPLAIN] = "v?" + src[t.MAINVERSION] + src[t.PRERELEASE] + "?" + src[t.BUILD] + "?";
    src[t.FULL] = "^" + src[t.FULLPLAIN] + "$";
    tok("LOOSEPLAIN");
    src[t.LOOSEPLAIN] = "[v=\\s]*" + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + "?" + src[t.BUILD] + "?";
    tok("LOOSE");
    src[t.LOOSE] = "^" + src[t.LOOSEPLAIN] + "$";
    tok("GTLT");
    src[t.GTLT] = "((?:<|>)?=?)";
    tok("XRANGEIDENTIFIERLOOSE");
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    tok("XRANGEIDENTIFIER");
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + "|x|X|\\*";
    tok("XRANGEPLAIN");
    src[t.XRANGEPLAIN] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:\\.(" + src[t.XRANGEIDENTIFIER] + ")(?:" + src[t.PRERELEASE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGEPLAINLOOSE");
    src[t.XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[t.XRANGEIDENTIFIERLOOSE] + ")(?:" + src[t.PRERELEASELOOSE] + ")?" + src[t.BUILD] + "?)?)?";
    tok("XRANGE");
    src[t.XRANGE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAIN] + "$";
    tok("XRANGELOOSE");
    src[t.XRANGELOOSE] = "^" + src[t.GTLT] + "\\s*" + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COERCE");
    src[t.COERCE] = "(^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    tok("COERCERTL");
    re[t.COERCERTL] = new RegExp(src[t.COERCE], "g");
    tok("LONETILDE");
    src[t.LONETILDE] = "(?:~>?)";
    tok("TILDETRIM");
    src[t.TILDETRIM] = "(\\s*)" + src[t.LONETILDE] + "\\s+";
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], "g");
    var tildeTrimReplace = "$1~";
    tok("TILDE");
    src[t.TILDE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAIN] + "$";
    tok("TILDELOOSE");
    src[t.TILDELOOSE] = "^" + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("LONECARET");
    src[t.LONECARET] = "(?:\\^)";
    tok("CARETTRIM");
    src[t.CARETTRIM] = "(\\s*)" + src[t.LONECARET] + "\\s+";
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], "g");
    var caretTrimReplace = "$1^";
    tok("CARET");
    src[t.CARET] = "^" + src[t.LONECARET] + src[t.XRANGEPLAIN] + "$";
    tok("CARETLOOSE");
    src[t.CARETLOOSE] = "^" + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + "$";
    tok("COMPARATORLOOSE");
    src[t.COMPARATORLOOSE] = "^" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + ")$|^$";
    tok("COMPARATOR");
    src[t.COMPARATOR] = "^" + src[t.GTLT] + "\\s*(" + src[t.FULLPLAIN] + ")$|^$";
    tok("COMPARATORTRIM");
    src[t.COMPARATORTRIM] = "(\\s*)" + src[t.GTLT] + "\\s*(" + src[t.LOOSEPLAIN] + "|" + src[t.XRANGEPLAIN] + ")";
    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], "g");
    var comparatorTrimReplace = "$1$2$3";
    tok("HYPHENRANGE");
    src[t.HYPHENRANGE] = "^\\s*(" + src[t.XRANGEPLAIN] + ")\\s+-\\s+(" + src[t.XRANGEPLAIN] + ")\\s*$";
    tok("HYPHENRANGELOOSE");
    src[t.HYPHENRANGELOOSE] = "^\\s*(" + src[t.XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[t.XRANGEPLAINLOOSE] + ")\\s*$";
    tok("STAR");
    src[t.STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version !== "string") {
        return null;
      }
      if (version.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? re[t.LOOSE] : re[t.FULL];
      if (!r.test(version)) {
        return null;
      }
      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== "string") {
        throw new TypeError("Invalid Version: " + version);
      }
      if (version.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }
      debug("SemVer", version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version);
      }
      this.raw = version;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.compareBuild = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      var i2 = 0;
      do {
        var a = this.build[i2];
        var b = other.build[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.compareBuild = compareBuild;
    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compareBuild(b, a, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq;
    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1] !== void 0 ? m[1] : "";
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version) {
      debug("Comparator.test", version, this.options.loose);
      if (this.semver === ANY || version === ANY) {
        return true;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      return cmp(version, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        if (this.value === "") {
          return true;
        }
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        if (comp.value === "") {
          return true;
        }
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }
      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function(range2) {
        return this.parseRange(range2.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + range);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range) {
      var loose = this.options.loose;
      range = range.trim();
      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug("hyphen replace", range);
      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range, re[t.COMPARATORTRIM]);
      range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
      range = range.replace(re[t.CARETTRIM], caretTrimReplace);
      range = range.split(/\s+/).join(" ");
      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function(rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function(thisComparator) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every(function(otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }
    exports2.toComparators = toComparators;
    function toComparators(range, options) {
      return new Range(range, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function(_2, M, m, p, pr) {
        debug("tilde", comp, _2, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function(_2, M, m, p, pr) {
        debug("caret", comp, _2, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p + pr;
        } else if (xm) {
          ret = ">=" + M + ".0.0" + pr + " <" + (+M + 1) + ".0.0" + pr;
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0" + pr + " <" + M + "." + (+m + 1) + ".0" + pr;
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version) {
      if (!version) {
        return false;
      }
      if (typeof version === "string") {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version)) {
          return false;
        }
      }
      if (version.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max || maxSV.compare(v) === -1) {
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min || minSV.compare(v) === 1) {
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }
    exports2.minVersion = minVersion;
    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range, options) {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version, range, options) {
      return outside(version, range, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version, range, options) {
      return outside(version, range, ">", options);
    }
    exports2.outside = outside;
    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version, range, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range.set.length; ++i2) {
        var comparators = range.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }
      if (typeof version === "number") {
        version = String(version);
      }
      if (typeof version !== "string") {
        return null;
      }
      options = options || {};
      var match = null;
      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        var next;
        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        re[t.COERCERTL].lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      return parse(match[2] + "." + (match[3] || "0") + "." + (match[4] || "0"), options);
    }
  }
});

// ../node_modules/package-json/index.js
var require_package_json = __commonJS({
  "../node_modules/package-json/index.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = require("url");
    var { Agent: HttpAgent } = require("http");
    var { Agent: HttpsAgent } = require("https");
    var got = require_source3();
    var registryUrl = require_registry_url();
    var registryAuthToken = require_registry_auth_token();
    var semver = require_semver2();
    var agentOptions = {
      keepAlive: true,
      maxSockets: 50
    };
    var httpAgent = new HttpAgent(agentOptions);
    var httpsAgent = new HttpsAgent(agentOptions);
    var PackageNotFoundError = class extends Error {
      constructor(packageName) {
        super(`Package \`${packageName}\` could not be found`);
        this.name = "PackageNotFoundError";
      }
    };
    var VersionNotFoundError = class extends Error {
      constructor(packageName, version) {
        super(`Version \`${version}\` for package \`${packageName}\` could not be found`);
        this.name = "VersionNotFoundError";
      }
    };
    var packageJson = async (packageName, options) => {
      options = __spreadValues({
        version: "latest"
      }, options);
      const scope = packageName.split("/")[0];
      const registryUrl_ = options.registryUrl || registryUrl(scope);
      const packageUrl = new URL2(encodeURIComponent(packageName).replace(/^%40/, "@"), registryUrl_);
      const authInfo = registryAuthToken(registryUrl_.toString(), { recursive: true });
      const headers = {
        accept: "application/vnd.npm.install-v1+json; q=1.0, application/json; q=0.8, */*"
      };
      if (options.fullMetadata) {
        delete headers.accept;
      }
      if (authInfo) {
        headers.authorization = `${authInfo.type} ${authInfo.token}`;
      }
      const gotOptions = {
        json: true,
        headers,
        agent: {
          http: httpAgent,
          https: httpsAgent
        }
      };
      if (options.agent) {
        gotOptions.agent = options.agent;
      }
      let response;
      try {
        response = await got(packageUrl, gotOptions);
      } catch (error) {
        if (error.statusCode === 404) {
          throw new PackageNotFoundError(packageName);
        }
        throw error;
      }
      let data = response.body;
      if (options.allVersions) {
        return data;
      }
      let { version } = options;
      const versionError = new VersionNotFoundError(packageName, version);
      if (data["dist-tags"][version]) {
        data = data.versions[data["dist-tags"][version]];
      } else if (version) {
        if (!data.versions[version]) {
          const versions = Object.keys(data.versions);
          version = semver.maxSatisfying(versions, version);
          if (!version) {
            throw versionError;
          }
        }
        data = data.versions[version];
        if (!data) {
          throw versionError;
        }
      }
      return data;
    };
    module2.exports = packageJson;
    module2.exports.default = packageJson;
    module2.exports.PackageNotFoundError = PackageNotFoundError;
    module2.exports.VersionNotFoundError = VersionNotFoundError;
  }
});

// ../node_modules/latest-version/index.js
var require_latest_version = __commonJS({
  "../node_modules/latest-version/index.js"(exports2, module2) {
    "use strict";
    var packageJson = require_package_json();
    var lastestVersion = async (packageName, options) => {
      const { version } = await packageJson(packageName.toLowerCase(), options);
      return version;
    };
    module2.exports = lastestVersion;
    module2.exports.default = lastestVersion;
  }
});

// ../node_modules/ini/ini.js
var require_ini2 = __commonJS({
  "../node_modules/ini/ini.js"(exports2, module2) {
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    var encode = (obj, opt) => {
      const children = [];
      let out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || Object.create(null);
        opt.whitespace = opt.whitespace === true;
      }
      const separator = opt.whitespace ? " = " : "=";
      for (const k of Object.keys(obj)) {
        const val = obj[k];
        if (val && Array.isArray(val)) {
          for (const item of val)
            out += safe(k + "[]") + separator + safe(item) + "\n";
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      }
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      for (const k of children) {
        const nk = dotSplit(k).join("\\.");
        const section = (opt.section ? opt.section + "." : "") + nk;
        const { whitespace } = opt;
        const child = encode(obj[k], {
          section,
          whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      }
      return out;
    };
    var dotSplit = (str) => str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map((part) => part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, ""));
    var decode = (str) => {
      const out = Object.create(null);
      let p = out;
      let section = null;
      const re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      const lines = str.split(/[\r\n]+/g);
      for (const line of lines) {
        if (!line || line.match(/^\s*[;#]/))
          continue;
        const match = line.match(re);
        if (!match)
          continue;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = Object.create(null);
            continue;
          }
          p = out[section] = out[section] || Object.create(null);
          continue;
        }
        const keyRaw = unsafe(match[2]);
        const isArray = keyRaw.length > 2 && keyRaw.slice(-2) === "[]";
        const key = isArray ? keyRaw.slice(0, -2) : keyRaw;
        if (key === "__proto__")
          continue;
        const valueRaw = match[3] ? unsafe(match[4]) : true;
        const value = valueRaw === "true" || valueRaw === "false" || valueRaw === "null" ? JSON.parse(valueRaw) : valueRaw;
        if (isArray) {
          if (!hasOwnProperty2.call(p, key))
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      }
      const remove = [];
      for (const k of Object.keys(out)) {
        if (!hasOwnProperty2.call(out, k) || typeof out[k] !== "object" || Array.isArray(out[k]))
          continue;
        const parts = dotSplit(k);
        let p2 = out;
        const l = parts.pop();
        const nl = l.replace(/\\\./g, ".");
        for (const part of parts) {
          if (part === "__proto__")
            continue;
          if (!hasOwnProperty2.call(p2, part) || typeof p2[part] !== "object")
            p2[part] = Object.create(null);
          p2 = p2[part];
        }
        if (p2 === out && nl === l)
          continue;
        p2[nl] = out[k];
        remove.push(k);
      }
      for (const del of remove)
        delete out[del];
      return out;
    };
    var isQuoted = (val) => val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    var safe = (val) => typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    var unsafe = (val, doUnesc) => {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_2) {
        }
      } else {
        let esc = false;
        let unesc = "";
        for (let i = 0, l = val.length; i < l; i++) {
          const c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    };
    module2.exports = {
      parse: decode,
      decode,
      stringify: encode,
      encode,
      safe,
      unsafe
    };
  }
});

// ../node_modules/global-dirs/index.js
var require_global_dirs = __commonJS({
  "../node_modules/global-dirs/index.js"(exports2) {
    "use strict";
    var path = require("path");
    var os = require("os");
    var fs = require("fs");
    var ini = require_ini2();
    var isWindows = process.platform === "win32";
    var readRc = (filePath) => {
      try {
        return ini.parse(fs.readFileSync(filePath, "utf8")).prefix;
      } catch {
      }
    };
    var getEnvNpmPrefix = () => {
      return Object.keys(process.env).reduce((prefix, name) => {
        return /^npm_config_prefix$/i.test(name) ? process.env[name] : prefix;
      }, void 0);
    };
    var getGlobalNpmrc = () => {
      if (isWindows && process.env.APPDATA) {
        return path.join(process.env.APPDATA, "/npm/etc/npmrc");
      }
      if (process.execPath.includes("/Cellar/node")) {
        const homebrewPrefix = process.execPath.slice(0, process.execPath.indexOf("/Cellar/node"));
        return path.join(homebrewPrefix, "/lib/node_modules/npm/npmrc");
      }
      if (process.execPath.endsWith("/bin/node")) {
        const installDir = path.dirname(path.dirname(process.execPath));
        return path.join(installDir, "/etc/npmrc");
      }
    };
    var getDefaultNpmPrefix = () => {
      if (isWindows) {
        return path.dirname(process.execPath);
      }
      return path.dirname(path.dirname(process.execPath));
    };
    var getNpmPrefix = () => {
      const envPrefix = getEnvNpmPrefix();
      if (envPrefix) {
        return envPrefix;
      }
      const homePrefix = readRc(path.join(os.homedir(), ".npmrc"));
      if (homePrefix) {
        return homePrefix;
      }
      if (process.env.PREFIX) {
        return process.env.PREFIX;
      }
      const globalPrefix = readRc(getGlobalNpmrc());
      if (globalPrefix) {
        return globalPrefix;
      }
      return getDefaultNpmPrefix();
    };
    var npmPrefix = path.resolve(getNpmPrefix());
    var getYarnWindowsDirectory = () => {
      if (isWindows && process.env.LOCALAPPDATA) {
        const dir = path.join(process.env.LOCALAPPDATA, "Yarn");
        if (fs.existsSync(dir)) {
          return dir;
        }
      }
      return false;
    };
    var getYarnPrefix = () => {
      if (process.env.PREFIX) {
        return process.env.PREFIX;
      }
      const windowsPrefix = getYarnWindowsDirectory();
      if (windowsPrefix) {
        return windowsPrefix;
      }
      const configPrefix = path.join(os.homedir(), ".config/yarn");
      if (fs.existsSync(configPrefix)) {
        return configPrefix;
      }
      const homePrefix = path.join(os.homedir(), ".yarn-config");
      if (fs.existsSync(homePrefix)) {
        return homePrefix;
      }
      return npmPrefix;
    };
    exports2.npm = {};
    exports2.npm.prefix = npmPrefix;
    exports2.npm.packages = path.join(npmPrefix, isWindows ? "node_modules" : "lib/node_modules");
    exports2.npm.binaries = isWindows ? npmPrefix : path.join(npmPrefix, "bin");
    var yarnPrefix = path.resolve(getYarnPrefix());
    exports2.yarn = {};
    exports2.yarn.prefix = yarnPrefix;
    exports2.yarn.packages = path.join(yarnPrefix, getYarnWindowsDirectory() ? "Data/global/node_modules" : "global/node_modules");
    exports2.yarn.binaries = path.join(exports2.yarn.packages, ".bin");
  }
});

// ../node_modules/is-path-inside/index.js
var require_is_path_inside = __commonJS({
  "../node_modules/is-path-inside/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    module2.exports = (childPath, parentPath) => {
      const relation = path.relative(parentPath, childPath);
      return Boolean(relation && relation !== ".." && !relation.startsWith(`..${path.sep}`) && relation !== path.resolve(childPath));
    };
  }
});

// ../node_modules/is-installed-globally/index.js
var require_is_installed_globally = __commonJS({
  "../node_modules/is-installed-globally/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var globalDirs = require_global_dirs();
    var isPathInside = require_is_path_inside();
    module2.exports = (() => {
      try {
        return isPathInside(__dirname, globalDirs.yarn.packages) || isPathInside(__dirname, fs.realpathSync(globalDirs.npm.packages));
      } catch {
        return false;
      }
    })();
  }
});

// src/utils/parseSlug.js
var require_parseSlug = __commonJS({
  "src/utils/parseSlug.js"(exports2, module2) {
    "use strict";
    module2.exports = (slug = "") => {
      let orgName, serviceName, instanceName;
      const splittedSlug = slug.split("/");
      if (splittedSlug.length === 3) {
        orgName = splittedSlug[0].replace("@", "");
        serviceName = splittedSlug[1];
        instanceName = splittedSlug[2];
      } else if (splittedSlug.length === 2) {
        if (splittedSlug[0].startsWith("@")) {
          orgName = splittedSlug[0].replace("@", "");
          serviceName = splittedSlug[1];
        } else {
          serviceName = splittedSlug[0];
          instanceName = splittedSlug[1];
        }
      } else if (splittedSlug.length === 1) {
        if (splittedSlug[0].startsWith("@")) {
          orgName = splittedSlug[0].replace("@", "");
        } else {
          instanceName = splittedSlug[0];
        }
      }
      return {
        orgName,
        serviceName,
        instanceName
      };
    };
  }
});

// src/utils/runWithTimeout.js
var require_runWithTimeout = __commonJS({
  "src/utils/runWithTimeout.js"(exports2, module2) {
    var runWithTimeout = async (asyncPromise, timeLimit) => {
      let timeoutHandle;
      const timeoutPromise = new Promise((resolve2) => {
        timeoutHandle = setTimeout(() => resolve2(), timeLimit);
      });
      return Promise.race([asyncPromise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      });
    };
    module2.exports = runWithTimeout;
  }
});

// package.json
var require_package2 = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "@serverless/cloud",
      version: "2.6.3",
      description: "Serverless Cloud",
      main: "./src/stub.js",
      types: "index.d.ts",
      engines: {
        node: ">=12.0.0"
      },
      exports: {
        ".": "./dist/stub.js",
        "./models": "./src/models/index.js",
        "./svelte": "./svelte/index.js",
        "./utils": "./src/utils/index.js"
      },
      publishConfig: {
        access: "public"
      },
      bin: {
        cloud: "./bin/bin"
      },
      scripts: {
        publish: "npm run build",
        prebuild: "rimraf dist",
        build: "node esbuild.mjs",
        "build-for-smoke": "rm -rf ./smoke-dist; node esbuild-for-smoke.mjs",
        test: 'LOG_LEVEL=silent NODE_OPTIONS="--no-warnings --experimental-vm-modules" jest --injectGlobals --ci --maxConcurrency=4 --collect-coverage',
        lint: "eslint '**/*.js' --max-warnings 0",
        "lint:fix": "eslint '**/*.js' --fix",
        prettier: "prettier --write '**/*.{js,ts}'",
        "prettier:check": "prettier --check '**/*.{js,ts}'"
      },
      author: "Eslam \u03BB Hefnawy",
      license: "Apache-2.0",
      dependencies: {
        chokidar: "^3.5.0"
      },
      devDependencies: {
        "@serverless/eslint-config": "^3.0.0",
        "@serverless/platform-client": "^4.2.4",
        "@serverless/utils": "^4.1.0",
        "@types/express": "^4.17.13",
        "adm-zip": "^0.5.5",
        "ansi-escapes": "^4.3.1",
        axios: "^0.21.1",
        "axios-retry": "^3.2.0",
        chalk: "^4.1.0",
        "child-process-ext": "^2.1.1",
        chunk: "^0.0.3",
        dayjs: "^1.10.4",
        debounce: "^1.2.1",
        del: "^6.0.0",
        download: "^8.0.0",
        "download-git-repo": "^3.0.2",
        esbuild: "~0.13.15",
        "esbuild-plugin-wasm": "^1.0.0",
        eslint: "^7.30.0",
        "eslint-config-prettier": "^8.3.0",
        "eslint-plugin-import": "^2.22.1",
        "fast-glob": "^3.2.5",
        figures: "^3.2.0",
        "fs-extra": "^9.0.1",
        "git-list-updated": "^1.2.1",
        "github-release-from-cc-changelog": "^2.2.0",
        "is-git-url": "^1.0.0",
        "is-installed-globally": "^0.4.0",
        "it-parallel": "^2.0.1",
        jest: "^27.1.0",
        keypress: "^0.2.1",
        "latest-version": "^5.0.0",
        minimist: "^1.2.5",
        "node-emoji": "^1.10.0",
        "normalize-path": "^3.0.0",
        open: "^8.2.0",
        "parse-packagejson-name": "^1.0.1",
        pluralize: "^8.0.0",
        prettier: "^2.5.0",
        ramda: "^0.25.0",
        rimraf: "^3.0.2",
        semver: "^5.7.1",
        "strip-ansi": "^6.0.0",
        "lz4-wasm-nodejs": "^0.7.5"
      }
    };
  }
});

// src/commands/help.js
var require_help = __commonJS({
  "src/commands/help.js"(exports2, module2) {
    "use strict";
    var { version } = require_package2();
    module2.exports = async (cli) => {
      const { bold } = cli.styles;
      cli.log(`
${bold("cloud")}                       Starts interactive development mode with auto deployment
${bold("  --seed")}                    Seed data from your data file on initialization
${bold("  --reseed")}                  Automatically seed data from your data file when it changes
${bold("  --org")}                     Specifies and overwrites the org name in package.json
${bold("  --app")}                     Specifies and overwrites the app name in package.json
${bold("  --template")}                Specifies either a template name or a git url to initialize
${bold("cloud deploy {name}")}         Deploys code to the {name} instance
${bold("  --org")}                     Specifies and overwrites the org name in package.json
${bold("  --app")}                     Specifies and overwrites the app name in package.json
${bold("cloud delete {name}")}         Deletes the {name} instance
${bold("cloud test")}                  Runs your tests in the cloud
${bold("cloud promote {from} {to}")}   Promotes a stage by copying code {from} stage {to} stage
${bold("cloud clone {name}")}          Clones code and data from {name} instance to your personal instance
${bold("  --overwrite")}               Overwrite files in the current directory
${bold("cloud share")}                 Shares your personal instance by creating a new randomly-named instance from it
${bold("cloud share {name}")}          Shares your personal instance by creating a new instance named {name} from it
${bold("  --overwrite")}               Overwrite any existing instance name you provided
${bold("cloud import {file}")}         Imports data from the {file} json file to your personal instance
${bold("cloud export {file}")}         Export data from your personal instance to {file} json file.
${bold("  --overwrite")}               Overwrite the file data if exists
${bold("cloud login")}                 Logs into Serverless Cloud
${bold("cloud logout")}                Logs out of Serverless Cloud

${bold("Version:")}          v${version}
${bold("Documentation:")}    https://serverless.com/cloud/docs
`);
    };
  }
});

// src/utils/stringifyTimer.js
var require_stringifyTimer = __commonJS({
  "src/utils/stringifyTimer.js"(exports2, module2) {
    "use strict";
    module2.exports = (numberOfSeconds) => {
      if (numberOfSeconds === 0) {
        return `less than a second`;
      }
      if (numberOfSeconds === 1) {
        return `1 second`;
      }
      return `${numberOfSeconds} seconds`;
    };
  }
});

// ../node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../node_modules/universalify/index.js"(exports2) {
    "use strict";
    exports2.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve2, reject2) => {
            fn.call(this, ...args, (err, res) => err != null ? reject2(err) : resolve2(res));
          });
        }
      }, "name", { value: fn.name });
    };
    exports2.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (!fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (!fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = function(fs$rename) {
          return function(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          };
        }(fs.rename);
      }
      fs.read = function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _2, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs2.fchmod(fd, mode, function(err2) {
              fs2.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK")) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats.uid < 0)
            stats.uid += 4294967296;
          if (stats.gid < 0)
            stats.gid += 4294967296;
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readdir(path, options, cb);
        function go$readdir(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readdir, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          });
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../node_modules/fs-extra/lib/fs/index.js"(exports2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs[key] === "function";
    });
    Object.keys(fs).forEach((key) => {
      if (key === "promises") {
        return;
      }
      exports2[key] = fs[key];
    });
    api.forEach((method) => {
      exports2[method] = u(fs[method]);
    });
    exports2.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs.exists(filename, callback);
      }
      return new Promise((resolve2) => {
        return fs.exists(filename, resolve2);
      });
    };
    exports2.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve2, reject2) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject2(err);
          resolve2({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports2.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.write(fd, buffer, ...args);
      }
      return new Promise((resolve2, reject2) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject2(err);
          resolve2({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    if (typeof fs.writev === "function") {
      exports2.writev = function(fd, buffers, ...args) {
        if (typeof args[args.length - 1] === "function") {
          return fs.writev(fd, buffers, ...args);
        }
        return new Promise((resolve2, reject2) => {
          fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
            if (err)
              return reject2(err);
            resolve2({ bytesWritten, buffers: buffers2 });
          });
        });
      };
    }
    if (typeof fs.realpath.native === "function") {
      exports2.realpath.native = u(fs.realpath.native);
    }
  }
});

// ../node_modules/at-least-node/index.js
var require_at_least_node = __commonJS({
  "../node_modules/at-least-node/index.js"(exports2, module2) {
    module2.exports = (r) => {
      const n = process.versions.node.split(".").map((x) => parseInt(x, 10));
      r = r.split(".").map((x) => parseInt(x, 10));
      return n[0] > r[0] || n[0] === r[0] && (n[1] > r[1] || n[1] === r[1] && n[2] >= r[2]);
    };
  }
});

// ../node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path = require("path");
    var atLeastNode = require_at_least_node();
    var useNativeRecursiveOption = atLeastNode("10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var processOptions = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        options = { mode: options };
      return __spreadValues(__spreadValues({}, defaults), options);
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    module2.exports.makeDir = async (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path.resolve(input);
        return fs.mkdir(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = async (pth) => {
        try {
          await fs.mkdir(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            await make(path.dirname(pth));
            return make(pth);
          }
          try {
            const stats = await fs.stat(pth);
            if (!stats.isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path.resolve(input));
    };
    module2.exports.makeDirSync = (input, options) => {
      checkPath(input);
      options = processOptions(options);
      if (useNativeRecursiveOption) {
        const pth = path.resolve(input);
        return fs.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
      }
      const make = (pth) => {
        try {
          fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch {
            throw error;
          }
        }
      };
      return make(path.resolve(input));
    };
  }
});

// ../node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../node_modules/fs-extra/lib/mkdirs/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../node_modules/fs-extra/lib/util/utimes.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    function utimesMillis(path, atime, mtime, callback) {
      fs.open(path, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs.futimes(fd, atime, mtime, (futimesErr) => {
          fs.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path, atime, mtime) {
      const fd = fs.openSync(path, "r+");
      fs.futimesSync(fd, atime, mtime);
      return fs.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../node_modules/fs-extra/lib/util/stat.js"(exports2, module2) {
    "use strict";
    var fs = require_fs();
    var path = require("path");
    var util = require("util");
    var atLeastNode = require_at_least_node();
    var nodeSupportsBigInt = atLeastNode("10.5.0");
    var stat = (file) => nodeSupportsBigInt ? fs.stat(file, { bigint: true }) : fs.stat(file);
    var statSync = (file) => nodeSupportsBigInt ? fs.statSync(file, { bigint: true }) : fs.statSync(file);
    function getStats(src, dest) {
      return Promise.all([
        stat(src),
        stat(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest) {
      let destStat;
      const srcStat = statSync(src);
      try {
        destStat = statSync(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, cb) {
      util.callbackify(getStats)(src, dest, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat && areIdentical(srcStat, destStat)) {
          return cb(new Error("Source and destination must not be the same."));
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName) {
      const { srcStat, destStat } = getStatsSync(src, dest);
      if (destStat && areIdentical(srcStat, destStat)) {
        throw new Error("Source and destination must not be the same.");
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (destParent === srcParent || destParent === path.parse(destParent).root)
        return cb();
      const callback = (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      };
      if (nodeSupportsBigInt)
        fs.stat(destParent, { bigint: true }, callback);
      else
        fs.stat(destParent, callback);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (destParent === srcParent || destParent === path.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = statSync(destParent);
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {
        if (nodeSupportsBigInt || destStat.ino < Number.MAX_SAFE_INTEGER) {
          return true;
        }
        if (destStat.size === srcStat.size && destStat.mode === srcStat.mode && destStat.nlink === srcStat.nlink && destStat.atimeMs === srcStat.atimeMs && destStat.mtimeMs === srcStat.mtimeMs && destStat.ctimeMs === srcStat.ctimeMs && destStat.birthtimeMs === srcStat.birthtimeMs) {
          return true;
        }
      }
      return false;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path.resolve(src).split(path.sep).filter((i) => i);
      const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir
    };
  }
});

// ../node_modules/fs-extra/lib/copy-sync/copy-sync.js
var require_copy_sync = __commonJS({
  "../node_modules/fs-extra/lib/copy-sync/copy-sync.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy");
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      return handleFilterAndCopy(destStat, src, dest, opts);
    }
    function handleFilterAndCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path.dirname(dest);
      if (!fs.existsSync(destParent))
        mkdirsSync(destParent);
      return startCopy(destStat, src, dest, opts);
    }
    function startCopy(destStat, src, dest, opts) {
      if (opts.filter && !opts.filter(src, dest))
        return;
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      if (destStat && !destStat.isDirectory()) {
        throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
      }
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy");
      return startCopy(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (fs.statSync(dest).isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs.unlinkSync(dest);
      return fs.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../node_modules/fs-extra/lib/copy-sync/index.js
var require_copy_sync2 = __commonJS({
  "../node_modules/fs-extra/lib/copy-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      copySync: require_copy_sync()
    };
  }
});

// ../node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../node_modules/fs-extra/lib/path-exists/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs = require_fs();
    function pathExists(path) {
      return fs.access(path).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs.existsSync
    };
  }
});

// ../node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../node_modules/fs-extra/lib/copy/copy.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        console.warn(`fs-extra: Using the preserveTimestamps option in 32-bit node is not recommended;

    see https://github.com/jprichardson/node-fs-extra/issues/269`);
      }
      stat.checkPaths(src, dest, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          if (opts.filter)
            return handleFilter(checkParentDir, destStat, src, dest, opts, cb);
          return checkParentDir(destStat, src, dest, opts, cb);
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return startCopy(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return startCopy(destStat, src, dest, opts, cb);
        });
      });
    }
    function handleFilter(onInclude, destStat, src, dest, opts, cb) {
      Promise.resolve(opts.filter(src, dest)).then((include) => {
        if (include)
          return onInclude(destStat, src, dest, opts, cb);
        return cb();
      }, (error) => cb(error));
    }
    function startCopy(destStat, src, dest, opts, cb) {
      if (opts.filter)
        return handleFilter(getStats, destStat, src, dest, opts, cb);
      return getStats(destStat, src, dest, opts, cb);
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs.stat : fs.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      if (destStat && !destStat.isDirectory()) {
        return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
      }
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      stat.checkPaths(srcItem, destItem, "copy", (err, stats) => {
        if (err)
          return cb(err);
        const { destStat } = stats;
        startCopy(destStat, srcItem, destItem, opts, (err2) => {
          if (err2)
            return cb(err2);
          return copyDirItems(items, src, dest, opts, cb);
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs.symlink(resolvedSrc, dest, cb);
        } else {
          fs.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (destStat.isDirectory() && stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// ../node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../node_modules/fs-extra/lib/copy/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy())
    };
  }
});

// ../node_modules/fs-extra/lib/remove/rimraf.js
var require_rimraf = __commonJS({
  "../node_modules/fs-extra/lib/remove/rimraf.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var assert = require("assert");
    var isWindows = process.platform === "win32";
    function defaults(options) {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
    }
    function rimraf(p, options, cb) {
      let busyTries = 0;
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert.strictEqual(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      rimraf_(p, options, function CB(er) {
        if (er) {
          if ((er.code === "EBUSY" || er.code === "ENOTEMPTY" || er.code === "EPERM") && busyTries < options.maxBusyTries) {
            busyTries++;
            const time = busyTries * 100;
            return setTimeout(() => rimraf_(p, options, CB), time);
          }
          if (er.code === "ENOENT")
            er = null;
        }
        cb(er);
      });
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT") {
          return cb(null);
        }
        if (er && er.code === "EPERM" && isWindows) {
          return fixWinEPERM(p, options, er, cb);
        }
        if (st && st.isDirectory()) {
          return rmdir(p, options, er, cb);
        }
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT") {
              return cb(null);
            }
            if (er2.code === "EPERM") {
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            }
            if (er2.code === "EISDIR") {
              return rmdir(p, options, er2, cb);
            }
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2) {
          cb(er2.code === "ENOENT" ? null : er);
        } else {
          options.stat(p, (er3, stats) => {
            if (er3) {
              cb(er3.code === "ENOENT" ? null : er);
            } else if (stats.isDirectory()) {
              rmdir(p, options, er, cb);
            } else {
              options.unlink(p, cb);
            }
          });
        }
      });
    }
    function fixWinEPERMSync(p, options, er) {
      let stats;
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT") {
          return;
        } else {
          throw er;
        }
      }
      if (stats.isDirectory()) {
        rmdirSync(p, options, er);
      } else {
        options.unlinkSync(p);
      }
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")) {
          rmkids(p, options, cb);
        } else if (er && er.code === "ENOTDIR") {
          cb(originalEr);
        } else {
          cb(er);
        }
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        let errState;
        if (n === 0)
          return options.rmdir(p, cb);
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState) {
              return;
            }
            if (er2)
              return cb(errState = er2);
            if (--n === 0) {
              options.rmdir(p, cb);
            }
          });
        });
      });
    }
    function rimrafSync(p, options) {
      let st;
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.strictEqual(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.strictEqual(typeof options, "object", "rimraf: options should be object");
      try {
        st = options.lstatSync(p);
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        }
        if (er.code === "EPERM" && isWindows) {
          fixWinEPERMSync(p, options, er);
        }
      }
      try {
        if (st && st.isDirectory()) {
          rmdirSync(p, options, null);
        } else {
          options.unlinkSync(p);
        }
      } catch (er) {
        if (er.code === "ENOENT") {
          return;
        } else if (er.code === "EPERM") {
          return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
        } else if (er.code !== "EISDIR") {
          throw er;
        }
        rmdirSync(p, options, er);
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOTDIR") {
          throw originalEr;
        } else if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM") {
          rmkidsSync(p, options);
        } else if (er.code !== "ENOENT") {
          throw er;
        }
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      if (isWindows) {
        const startTime = Date.now();
        do {
          try {
            const ret = options.rmdirSync(p, options);
            return ret;
          } catch {
          }
        } while (Date.now() - startTime < 500);
      } else {
        const ret = options.rmdirSync(p, options);
        return ret;
      }
    }
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// ../node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../node_modules/fs-extra/lib/remove/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var rimraf = require_rimraf();
    module2.exports = {
      remove: u(rimraf),
      removeSync: rimraf.sync
    };
  }
});

// ../node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../node_modules/fs-extra/lib/empty/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(function emptyDir2(dir, callback) {
      callback = callback || function() {
      };
      fs.readdir(dir, (err, items) => {
        if (err)
          return mkdir.mkdirs(dir, callback);
        items = items.map((item) => path.join(dir, item));
        deleteItem();
        function deleteItem() {
          const item = items.pop();
          if (!item)
            return callback();
          remove.remove(item, (err2) => {
            if (err2)
              return callback(err2);
            deleteItem();
          });
        }
      });
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../node_modules/fs-extra/lib/ensure/file.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs = require_graceful_fs();
    var mkdir = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path.dirname(file);
        fs.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path.dirname(file);
      try {
        if (!fs.statSync(dir).isDirectory()) {
          fs.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../node_modules/fs-extra/lib/ensure/link.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs = require_graceful_fs();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        fs.lstat(srcpath, (err2) => {
          if (err2) {
            err2.message = err2.message.replace("lstat", "ensureLink");
            return callback(err2);
          }
          const dir = path.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      const destinationExists = fs.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      try {
        fs.lstatSync(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path.dirname(dstpath);
      const dirExists = fs.existsSync(dir);
      if (dirExists)
        return fs.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path.isAbsolute(srcpath)) {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path.isAbsolute(srcpath)) {
        exists = fs.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        exists = fs.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../node_modules/fs-extra/lib/ensure/symlink-type.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../node_modules/fs-extra/lib/ensure/symlink.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs = require_graceful_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      pathExists(dstpath, (err, destinationExists) => {
        if (err)
          return callback(err);
        if (destinationExists)
          return callback(null);
        symlinkPaths(srcpath, dstpath, (err2, relative) => {
          if (err2)
            return callback(err2);
          srcpath = relative.toDst;
          symlinkType(relative.toCwd, type, (err3, type2) => {
            if (err3)
              return callback(err3);
            const dir = path.dirname(dstpath);
            pathExists(dir, (err4, dirExists) => {
              if (err4)
                return callback(err4);
              if (dirExists)
                return fs.symlink(srcpath, dstpath, type2, callback);
              mkdirs(dir, (err5) => {
                if (err5)
                  return callback(err5);
                fs.symlink(srcpath, dstpath, type2, callback);
              });
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      const destinationExists = fs.existsSync(dstpath);
      if (destinationExists)
        return void 0;
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      const exists = fs.existsSync(dir);
      if (exists)
        return fs.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../node_modules/fs-extra/lib/ensure/index.js
var require_ensure3 = __commonJS({
  "../node_modules/fs-extra/lib/ensure/index.js"(exports2, module2) {
    "use strict";
    var file = require_file();
    var link = require_link();
    var symlink = require_symlink();
    module2.exports = {
      createFile: file.createFile,
      createFileSync: file.createFileSync,
      ensureFile: file.createFile,
      ensureFileSync: file.createFileSync,
      createLink: link.createLink,
      createLinkSync: link.createLinkSync,
      ensureLink: link.createLink,
      ensureLinkSync: link.createLinkSync,
      createSymlink: symlink.createSymlink,
      createSymlinkSync: symlink.createSymlinkSync,
      ensureSymlink: symlink.createSymlink,
      ensureSymlinkSync: symlink.createSymlinkSync
    };
  }
});

// ../node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../node_modules/jsonfile/utils.js"(exports2, module2) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// ../node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../node_modules/jsonfile/index.js"(exports2, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_2) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify(obj, options);
      return fs.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// ../node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../node_modules/fs-extra/lib/json/jsonfile.js"(exports2, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../node_modules/fs-extra/lib/output/index.js
var require_output = __commonJS({
  "../node_modules/fs-extra/lib/output/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path.dirname(file);
      if (fs.existsSync(dir)) {
        return fs.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../node_modules/fs-extra/lib/json/output-json.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// ../node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../node_modules/fs-extra/lib/json/output-json-sync.js"(exports2, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../node_modules/fs-extra/lib/json/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../node_modules/fs-extra/lib/move-sync/move-sync.js
var require_move_sync = __commonJS({
  "../node_modules/fs-extra/lib/move-sync/move-sync.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var copySync = require_copy_sync2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat } = stat.checkPathsSync(src, dest, "move");
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      mkdirpSync(path.dirname(dest));
      return doRename(src, dest, overwrite);
    }
    function doRename(src, dest, overwrite) {
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../node_modules/fs-extra/lib/move-sync/index.js
var require_move_sync2 = __commonJS({
  "../node_modules/fs-extra/lib/move-sync/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      moveSync: require_move_sync()
    };
  }
});

// ../node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../node_modules/fs-extra/lib/move/move.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          mkdirp(path.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, cb);
          });
        });
      });
    }
    function doRename(src, dest, overwrite, cb) {
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// ../node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../node_modules/fs-extra/lib/move/index.js"(exports2, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move())
    };
  }
});

// ../node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../node_modules/fs-extra/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = __spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues(__spreadValues({}, require_fs()), require_copy_sync2()), require_copy2()), require_empty()), require_ensure3()), require_json()), require_mkdirs()), require_move_sync2()), require_move2()), require_output()), require_path_exists()), require_remove());
    var fs = require("fs");
    if (Object.getOwnPropertyDescriptor(fs, "promises")) {
      Object.defineProperty(module2.exports, "promises", {
        get() {
          return fs.promises;
        }
      });
    }
  }
});

// ../node_modules/adm-zip/util/fileSystem.js
var require_fileSystem = __commonJS({
  "../node_modules/adm-zip/util/fileSystem.js"(exports2) {
    exports2.require = function() {
      if (typeof process === "object" && process.versions && process.versions["electron"]) {
        try {
          const originalFs = require("original-fs");
          if (Object.keys(originalFs).length > 0) {
            return originalFs;
          }
        } catch (e) {
        }
      }
      return require("fs");
    };
  }
});

// ../node_modules/adm-zip/util/constants.js
var require_constants = __commonJS({
  "../node_modules/adm-zip/util/constants.js"(exports2, module2) {
    module2.exports = {
      LOCHDR: 30,
      LOCSIG: 67324752,
      LOCVER: 4,
      LOCFLG: 6,
      LOCHOW: 8,
      LOCTIM: 10,
      LOCCRC: 14,
      LOCSIZ: 18,
      LOCLEN: 22,
      LOCNAM: 26,
      LOCEXT: 28,
      EXTSIG: 134695760,
      EXTHDR: 16,
      EXTCRC: 4,
      EXTSIZ: 8,
      EXTLEN: 12,
      CENHDR: 46,
      CENSIG: 33639248,
      CENVEM: 4,
      CENVER: 6,
      CENFLG: 8,
      CENHOW: 10,
      CENTIM: 12,
      CENCRC: 16,
      CENSIZ: 20,
      CENLEN: 24,
      CENNAM: 28,
      CENEXT: 30,
      CENCOM: 32,
      CENDSK: 34,
      CENATT: 36,
      CENATX: 38,
      CENOFF: 42,
      ENDHDR: 22,
      ENDSIG: 101010256,
      ENDSUB: 8,
      ENDTOT: 10,
      ENDSIZ: 12,
      ENDOFF: 16,
      ENDCOM: 20,
      END64HDR: 20,
      END64SIG: 117853008,
      END64START: 4,
      END64OFF: 8,
      END64NUMDISKS: 16,
      ZIP64SIG: 101075792,
      ZIP64HDR: 56,
      ZIP64LEAD: 12,
      ZIP64SIZE: 4,
      ZIP64VEM: 12,
      ZIP64VER: 14,
      ZIP64DSK: 16,
      ZIP64DSKDIR: 20,
      ZIP64SUB: 24,
      ZIP64TOT: 32,
      ZIP64SIZB: 40,
      ZIP64OFF: 48,
      ZIP64EXTRA: 56,
      STORED: 0,
      SHRUNK: 1,
      REDUCED1: 2,
      REDUCED2: 3,
      REDUCED3: 4,
      REDUCED4: 5,
      IMPLODED: 6,
      DEFLATED: 8,
      ENHANCED_DEFLATED: 9,
      PKWARE: 10,
      BZIP2: 12,
      LZMA: 14,
      IBM_TERSE: 18,
      IBM_LZ77: 19,
      AES_ENCRYPT: 99,
      FLG_ENC: 1,
      FLG_COMP1: 2,
      FLG_COMP2: 4,
      FLG_DESC: 8,
      FLG_ENH: 16,
      FLG_PATCH: 32,
      FLG_STR: 64,
      FLG_EFS: 2048,
      FLG_MSK: 4096,
      FILE: 2,
      BUFFER: 1,
      NONE: 0,
      EF_ID: 0,
      EF_SIZE: 2,
      ID_ZIP64: 1,
      ID_AVINFO: 7,
      ID_PFS: 8,
      ID_OS2: 9,
      ID_NTFS: 10,
      ID_OPENVMS: 12,
      ID_UNIX: 13,
      ID_FORK: 14,
      ID_PATCH: 15,
      ID_X509_PKCS7: 20,
      ID_X509_CERTID_F: 21,
      ID_X509_CERTID_C: 22,
      ID_STRONGENC: 23,
      ID_RECORD_MGT: 24,
      ID_X509_PKCS7_RL: 25,
      ID_IBM1: 101,
      ID_IBM2: 102,
      ID_POSZIP: 18064,
      EF_ZIP64_OR_32: 4294967295,
      EF_ZIP64_OR_16: 65535,
      EF_ZIP64_SUNCOMP: 0,
      EF_ZIP64_SCOMP: 8,
      EF_ZIP64_RHO: 16,
      EF_ZIP64_DSN: 24
    };
  }
});

// ../node_modules/adm-zip/util/utils.js
var require_utils3 = __commonJS({
  "../node_modules/adm-zip/util/utils.js"(exports2, module2) {
    var fsystem = require_fileSystem().require();
    var pth = require("path");
    var Constants = require_constants();
    var isWin = typeof process === "object" && process.platform === "win32";
    var is_Obj = (obj) => obj && typeof obj === "object";
    var crcTable = new Uint32Array(256).map((t, c) => {
      for (let k = 0; k < 8; k++) {
        if ((c & 1) !== 0) {
          c = 3988292384 ^ c >>> 1;
        } else {
          c >>>= 1;
        }
      }
      return c >>> 0;
    });
    function Utils(opts) {
      this.sep = pth.sep;
      this.fs = fsystem;
      if (is_Obj(opts)) {
        if (is_Obj(opts.fs) && typeof opts.fs.statSync === "function") {
          this.fs = opts.fs;
        }
      }
    }
    module2.exports = Utils;
    Utils.prototype.makeDir = function(folder) {
      const self2 = this;
      function mkdirSync(fpath) {
        let resolvedPath = fpath.split(self2.sep)[0];
        fpath.split(self2.sep).forEach(function(name) {
          if (!name || name.substr(-1, 1) === ":")
            return;
          resolvedPath += self2.sep + name;
          var stat;
          try {
            stat = self2.fs.statSync(resolvedPath);
          } catch (e) {
            self2.fs.mkdirSync(resolvedPath);
          }
          if (stat && stat.isFile())
            throw Errors.FILE_IN_THE_WAY.replace("%s", resolvedPath);
        });
      }
      mkdirSync(folder);
    };
    Utils.prototype.writeFileTo = function(path, content, overwrite, attr) {
      const self2 = this;
      if (self2.fs.existsSync(path)) {
        if (!overwrite)
          return false;
        var stat = self2.fs.statSync(path);
        if (stat.isDirectory()) {
          return false;
        }
      }
      var folder = pth.dirname(path);
      if (!self2.fs.existsSync(folder)) {
        self2.makeDir(folder);
      }
      var fd;
      try {
        fd = self2.fs.openSync(path, "w", 438);
      } catch (e) {
        self2.fs.chmodSync(path, 438);
        fd = self2.fs.openSync(path, "w", 438);
      }
      if (fd) {
        try {
          self2.fs.writeSync(fd, content, 0, content.length, 0);
        } finally {
          self2.fs.closeSync(fd);
        }
      }
      self2.fs.chmodSync(path, attr || 438);
      return true;
    };
    Utils.prototype.writeFileToAsync = function(path, content, overwrite, attr, callback) {
      if (typeof attr === "function") {
        callback = attr;
        attr = void 0;
      }
      const self2 = this;
      self2.fs.exists(path, function(exist) {
        if (exist && !overwrite)
          return callback(false);
        self2.fs.stat(path, function(err, stat) {
          if (exist && stat.isDirectory()) {
            return callback(false);
          }
          var folder = pth.dirname(path);
          self2.fs.exists(folder, function(exists) {
            if (!exists)
              self2.makeDir(folder);
            self2.fs.open(path, "w", 438, function(err2, fd) {
              if (err2) {
                self2.fs.chmod(path, 438, function() {
                  self2.fs.open(path, "w", 438, function(err3, fd2) {
                    self2.fs.write(fd2, content, 0, content.length, 0, function() {
                      self2.fs.close(fd2, function() {
                        self2.fs.chmod(path, attr || 438, function() {
                          callback(true);
                        });
                      });
                    });
                  });
                });
              } else if (fd) {
                self2.fs.write(fd, content, 0, content.length, 0, function() {
                  self2.fs.close(fd, function() {
                    self2.fs.chmod(path, attr || 438, function() {
                      callback(true);
                    });
                  });
                });
              } else {
                self2.fs.chmod(path, attr || 438, function() {
                  callback(true);
                });
              }
            });
          });
        });
      });
    };
    Utils.prototype.findFiles = function(path) {
      const self2 = this;
      function findSync(dir, pattern, recursive) {
        if (typeof pattern === "boolean") {
          recursive = pattern;
          pattern = void 0;
        }
        let files = [];
        self2.fs.readdirSync(dir).forEach(function(file) {
          var path2 = pth.join(dir, file);
          if (self2.fs.statSync(path2).isDirectory() && recursive)
            files = files.concat(findSync(path2, pattern, recursive));
          if (!pattern || pattern.test(path2)) {
            files.push(pth.normalize(path2) + (self2.fs.statSync(path2).isDirectory() ? self2.sep : ""));
          }
        });
        return files;
      }
      return findSync(path, void 0, true);
    };
    Utils.prototype.getAttributes = function() {
    };
    Utils.prototype.setAttributes = function() {
    };
    Utils.crc32update = function(crc, byte) {
      return crcTable[(crc ^ byte) & 255] ^ crc >>> 8;
    };
    Utils.crc32 = function(buf) {
      if (typeof buf === "string") {
        buf = Buffer.from(buf, "utf8");
      }
      if (!crcTable.length)
        genCRCTable();
      let len = buf.length;
      let crc = ~0;
      for (let off = 0; off < len; )
        crc = Utils.crc32update(crc, buf[off++]);
      return ~crc >>> 0;
    };
    Utils.methodToString = function(method) {
      switch (method) {
        case Constants.STORED:
          return "STORED (" + method + ")";
        case Constants.DEFLATED:
          return "DEFLATED (" + method + ")";
        default:
          return "UNSUPPORTED (" + method + ")";
      }
    };
    Utils.canonical = function(path) {
      if (!path)
        return "";
      var safeSuffix = pth.posix.normalize("/" + path.split("\\").join("/"));
      return pth.join(".", safeSuffix);
    };
    Utils.sanitize = function(prefix, name) {
      prefix = pth.resolve(pth.normalize(prefix));
      var parts = name.split("/");
      for (var i = 0, l = parts.length; i < l; i++) {
        var path = pth.normalize(pth.join(prefix, parts.slice(i, l).join(pth.sep)));
        if (path.indexOf(prefix) === 0) {
          return path;
        }
      }
      return pth.normalize(pth.join(prefix, pth.basename(name)));
    };
    Utils.toBuffer = function toBuffer(input) {
      if (Buffer.isBuffer(input)) {
        return input;
      } else if (input instanceof Uint8Array) {
        return Buffer.from(input);
      } else {
        return typeof input === "string" ? Buffer.from(input, "utf8") : Buffer.alloc(0);
      }
    };
    Utils.readBigUInt64LE = function(buffer, index) {
      var slice = Buffer.from(buffer.slice(index, index + 8));
      slice.swap64();
      return parseInt(`0x${slice.toString("hex")}`);
    };
    Utils.isWin = isWin;
    Utils.crcTable = crcTable;
  }
});

// ../node_modules/adm-zip/util/errors.js
var require_errors3 = __commonJS({
  "../node_modules/adm-zip/util/errors.js"(exports2, module2) {
    module2.exports = {
      INVALID_LOC: "Invalid LOC header (bad signature)",
      INVALID_CEN: "Invalid CEN header (bad signature)",
      INVALID_END: "Invalid END header (bad signature)",
      NO_DATA: "Nothing to decompress",
      BAD_CRC: "CRC32 checksum failed",
      FILE_IN_THE_WAY: "There is a file in the way: %s",
      UNKNOWN_METHOD: "Invalid/unsupported compression method",
      AVAIL_DATA: "inflate::Available inflate data did not terminate",
      INVALID_DISTANCE: "inflate::Invalid literal/length or distance code in fixed or dynamic block",
      TO_MANY_CODES: "inflate::Dynamic block code description: too many length or distance codes",
      INVALID_REPEAT_LEN: "inflate::Dynamic block code description: repeat more than specified lengths",
      INVALID_REPEAT_FIRST: "inflate::Dynamic block code description: repeat lengths with no first length",
      INCOMPLETE_CODES: "inflate::Dynamic block code description: code lengths codes incomplete",
      INVALID_DYN_DISTANCE: "inflate::Dynamic block code description: invalid distance code lengths",
      INVALID_CODES_LEN: "inflate::Dynamic block code description: invalid literal/length code lengths",
      INVALID_STORE_BLOCK: "inflate::Stored block length did not match one's complement",
      INVALID_BLOCK_TYPE: "inflate::Invalid block type (type == 3)",
      CANT_EXTRACT_FILE: "Could not extract the file",
      CANT_OVERRIDE: "Target file already exists",
      NO_ZIP: "No zip file was loaded",
      NO_ENTRY: "Entry doesn't exist",
      DIRECTORY_CONTENT_ERROR: "A directory cannot have content",
      FILE_NOT_FOUND: "File not found: %s",
      NOT_IMPLEMENTED: "Not implemented",
      INVALID_FILENAME: "Invalid filename",
      INVALID_FORMAT: "Invalid or unsupported zip format. No END header found"
    };
  }
});

// ../node_modules/adm-zip/util/fattr.js
var require_fattr = __commonJS({
  "../node_modules/adm-zip/util/fattr.js"(exports2, module2) {
    var fs = require_fileSystem().require();
    var pth = require("path");
    fs.existsSync = fs.existsSync || pth.existsSync;
    module2.exports = function(path) {
      var _path = path || "", _obj = newAttr(), _stat = null;
      function newAttr() {
        return {
          directory: false,
          readonly: false,
          hidden: false,
          executable: false,
          mtime: 0,
          atime: 0
        };
      }
      if (_path && fs.existsSync(_path)) {
        _stat = fs.statSync(_path);
        _obj.directory = _stat.isDirectory();
        _obj.mtime = _stat.mtime;
        _obj.atime = _stat.atime;
        _obj.executable = (73 & _stat.mode) !== 0;
        _obj.readonly = (128 & _stat.mode) === 0;
        _obj.hidden = pth.basename(_path)[0] === ".";
      } else {
        console.warn("Invalid path: " + _path);
      }
      return {
        get directory() {
          return _obj.directory;
        },
        get readOnly() {
          return _obj.readonly;
        },
        get hidden() {
          return _obj.hidden;
        },
        get mtime() {
          return _obj.mtime;
        },
        get atime() {
          return _obj.atime;
        },
        get executable() {
          return _obj.executable;
        },
        decodeAttributes: function() {
        },
        encodeAttributes: function() {
        },
        toJSON: function() {
          return {
            path: _path,
            isDirectory: _obj.directory,
            isReadOnly: _obj.readonly,
            isHidden: _obj.hidden,
            isExecutable: _obj.executable,
            mTime: _obj.mtime,
            aTime: _obj.atime
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// ../node_modules/adm-zip/util/index.js
var require_util2 = __commonJS({
  "../node_modules/adm-zip/util/index.js"(exports2, module2) {
    module2.exports = require_utils3();
    module2.exports.Constants = require_constants();
    module2.exports.Errors = require_errors3();
    module2.exports.FileAttr = require_fattr();
  }
});

// ../node_modules/adm-zip/headers/entryHeader.js
var require_entryHeader = __commonJS({
  "../node_modules/adm-zip/headers/entryHeader.js"(exports2, module2) {
    var Utils = require_util2();
    var Constants = Utils.Constants;
    module2.exports = function() {
      var _verMade = 20, _version = 10, _flags = 0, _method = 0, _time = 0, _crc = 0, _compressedSize = 0, _size = 0, _fnameLen = 0, _extraLen = 0, _comLen = 0, _diskStart = 0, _inattr = 0, _attr = 0, _offset = 0;
      _verMade |= Utils.isWin ? 2560 : 768;
      _flags |= Constants.FLG_EFS;
      var _dataHeader = {};
      function setTime(val) {
        val = new Date(val);
        _time = (val.getFullYear() - 1980 & 127) << 25 | val.getMonth() + 1 << 21 | val.getDate() << 16 | val.getHours() << 11 | val.getMinutes() << 5 | val.getSeconds() >> 1;
      }
      setTime(+new Date());
      return {
        get made() {
          return _verMade;
        },
        set made(val) {
          _verMade = val;
        },
        get version() {
          return _version;
        },
        set version(val) {
          _version = val;
        },
        get flags() {
          return _flags;
        },
        set flags(val) {
          _flags = val;
        },
        get method() {
          return _method;
        },
        set method(val) {
          switch (val) {
            case Constants.STORED:
              this.version = 10;
            case Constants.DEFLATED:
            default:
              this.version = 20;
          }
          _method = val;
        },
        get time() {
          return new Date((_time >> 25 & 127) + 1980, (_time >> 21 & 15) - 1, _time >> 16 & 31, _time >> 11 & 31, _time >> 5 & 63, (_time & 31) << 1);
        },
        set time(val) {
          setTime(val);
        },
        get crc() {
          return _crc;
        },
        set crc(val) {
          _crc = Math.max(0, val) >>> 0;
        },
        get compressedSize() {
          return _compressedSize;
        },
        set compressedSize(val) {
          _compressedSize = Math.max(0, val) >>> 0;
        },
        get size() {
          return _size;
        },
        set size(val) {
          _size = Math.max(0, val) >>> 0;
        },
        get fileNameLength() {
          return _fnameLen;
        },
        set fileNameLength(val) {
          _fnameLen = val;
        },
        get extraLength() {
          return _extraLen;
        },
        set extraLength(val) {
          _extraLen = val;
        },
        get commentLength() {
          return _comLen;
        },
        set commentLength(val) {
          _comLen = val;
        },
        get diskNumStart() {
          return _diskStart;
        },
        set diskNumStart(val) {
          _diskStart = Math.max(0, val) >>> 0;
        },
        get inAttr() {
          return _inattr;
        },
        set inAttr(val) {
          _inattr = Math.max(0, val) >>> 0;
        },
        get attr() {
          return _attr;
        },
        set attr(val) {
          _attr = Math.max(0, val) >>> 0;
        },
        get fileAttr() {
          return _attr ? (_attr >>> 0 | 0) >> 16 & 4095 : 0;
        },
        get offset() {
          return _offset;
        },
        set offset(val) {
          _offset = Math.max(0, val) >>> 0;
        },
        get encripted() {
          return (_flags & 1) === 1;
        },
        get entryHeaderSize() {
          return Constants.CENHDR + _fnameLen + _extraLen + _comLen;
        },
        get realDataOffset() {
          return _offset + Constants.LOCHDR + _dataHeader.fnameLen + _dataHeader.extraLen;
        },
        get dataHeader() {
          return _dataHeader;
        },
        loadDataHeaderFromBinary: function(input) {
          var data = input.slice(_offset, _offset + Constants.LOCHDR);
          if (data.readUInt32LE(0) !== Constants.LOCSIG) {
            throw new Error(Utils.Errors.INVALID_LOC);
          }
          _dataHeader = {
            version: data.readUInt16LE(Constants.LOCVER),
            flags: data.readUInt16LE(Constants.LOCFLG),
            method: data.readUInt16LE(Constants.LOCHOW),
            time: data.readUInt32LE(Constants.LOCTIM),
            crc: data.readUInt32LE(Constants.LOCCRC),
            compressedSize: data.readUInt32LE(Constants.LOCSIZ),
            size: data.readUInt32LE(Constants.LOCLEN),
            fnameLen: data.readUInt16LE(Constants.LOCNAM),
            extraLen: data.readUInt16LE(Constants.LOCEXT)
          };
        },
        loadFromBinary: function(data) {
          if (data.length !== Constants.CENHDR || data.readUInt32LE(0) !== Constants.CENSIG) {
            throw new Error(Utils.Errors.INVALID_CEN);
          }
          _verMade = data.readUInt16LE(Constants.CENVEM);
          _version = data.readUInt16LE(Constants.CENVER);
          _flags = data.readUInt16LE(Constants.CENFLG);
          _method = data.readUInt16LE(Constants.CENHOW);
          _time = data.readUInt32LE(Constants.CENTIM);
          _crc = data.readUInt32LE(Constants.CENCRC);
          _compressedSize = data.readUInt32LE(Constants.CENSIZ);
          _size = data.readUInt32LE(Constants.CENLEN);
          _fnameLen = data.readUInt16LE(Constants.CENNAM);
          _extraLen = data.readUInt16LE(Constants.CENEXT);
          _comLen = data.readUInt16LE(Constants.CENCOM);
          _diskStart = data.readUInt16LE(Constants.CENDSK);
          _inattr = data.readUInt16LE(Constants.CENATT);
          _attr = data.readUInt32LE(Constants.CENATX);
          _offset = data.readUInt32LE(Constants.CENOFF);
        },
        dataHeaderToBinary: function() {
          var data = Buffer.alloc(Constants.LOCHDR);
          data.writeUInt32LE(Constants.LOCSIG, 0);
          data.writeUInt16LE(_version, Constants.LOCVER);
          data.writeUInt16LE(_flags, Constants.LOCFLG);
          data.writeUInt16LE(_method, Constants.LOCHOW);
          data.writeUInt32LE(_time, Constants.LOCTIM);
          data.writeUInt32LE(_crc, Constants.LOCCRC);
          data.writeUInt32LE(_compressedSize, Constants.LOCSIZ);
          data.writeUInt32LE(_size, Constants.LOCLEN);
          data.writeUInt16LE(_fnameLen, Constants.LOCNAM);
          data.writeUInt16LE(_extraLen, Constants.LOCEXT);
          return data;
        },
        entryHeaderToBinary: function() {
          var data = Buffer.alloc(Constants.CENHDR + _fnameLen + _extraLen + _comLen);
          data.writeUInt32LE(Constants.CENSIG, 0);
          data.writeUInt16LE(_verMade, Constants.CENVEM);
          data.writeUInt16LE(_version, Constants.CENVER);
          data.writeUInt16LE(_flags, Constants.CENFLG);
          data.writeUInt16LE(_method, Constants.CENHOW);
          data.writeUInt32LE(_time, Constants.CENTIM);
          data.writeUInt32LE(_crc, Constants.CENCRC);
          data.writeUInt32LE(_compressedSize, Constants.CENSIZ);
          data.writeUInt32LE(_size, Constants.CENLEN);
          data.writeUInt16LE(_fnameLen, Constants.CENNAM);
          data.writeUInt16LE(_extraLen, Constants.CENEXT);
          data.writeUInt16LE(_comLen, Constants.CENCOM);
          data.writeUInt16LE(_diskStart, Constants.CENDSK);
          data.writeUInt16LE(_inattr, Constants.CENATT);
          data.writeUInt32LE(_attr, Constants.CENATX);
          data.writeUInt32LE(_offset, Constants.CENOFF);
          data.fill(0, Constants.CENHDR);
          return data;
        },
        toJSON: function() {
          const bytes = function(nr) {
            return nr + " bytes";
          };
          return {
            made: _verMade,
            version: _version,
            flags: _flags,
            method: Utils.methodToString(_method),
            time: this.time,
            crc: "0x" + _crc.toString(16).toUpperCase(),
            compressedSize: bytes(_compressedSize),
            size: bytes(_size),
            fileNameLength: bytes(_fnameLen),
            extraLength: bytes(_extraLen),
            commentLength: bytes(_comLen),
            diskNumStart: _diskStart,
            inAttr: _inattr,
            attr: _attr,
            offset: _offset,
            entryHeaderSize: bytes(Constants.CENHDR + _fnameLen + _extraLen + _comLen)
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// ../node_modules/adm-zip/headers/mainHeader.js
var require_mainHeader = __commonJS({
  "../node_modules/adm-zip/headers/mainHeader.js"(exports2, module2) {
    var Utils = require_util2();
    var Constants = Utils.Constants;
    module2.exports = function() {
      var _volumeEntries = 0, _totalEntries = 0, _size = 0, _offset = 0, _commentLength = 0;
      return {
        get diskEntries() {
          return _volumeEntries;
        },
        set diskEntries(val) {
          _volumeEntries = _totalEntries = val;
        },
        get totalEntries() {
          return _totalEntries;
        },
        set totalEntries(val) {
          _totalEntries = _volumeEntries = val;
        },
        get size() {
          return _size;
        },
        set size(val) {
          _size = val;
        },
        get offset() {
          return _offset;
        },
        set offset(val) {
          _offset = val;
        },
        get commentLength() {
          return _commentLength;
        },
        set commentLength(val) {
          _commentLength = val;
        },
        get mainHeaderSize() {
          return Constants.ENDHDR + _commentLength;
        },
        loadFromBinary: function(data) {
          if ((data.length !== Constants.ENDHDR || data.readUInt32LE(0) !== Constants.ENDSIG) && (data.length < Constants.ZIP64HDR || data.readUInt32LE(0) !== Constants.ZIP64SIG)) {
            throw new Error(Utils.Errors.INVALID_END);
          }
          if (data.readUInt32LE(0) === Constants.ENDSIG) {
            _volumeEntries = data.readUInt16LE(Constants.ENDSUB);
            _totalEntries = data.readUInt16LE(Constants.ENDTOT);
            _size = data.readUInt32LE(Constants.ENDSIZ);
            _offset = data.readUInt32LE(Constants.ENDOFF);
            _commentLength = data.readUInt16LE(Constants.ENDCOM);
          } else {
            _volumeEntries = Utils.readBigUInt64LE(data, Constants.ZIP64SUB);
            _totalEntries = Utils.readBigUInt64LE(data, Constants.ZIP64TOT);
            _size = Utils.readBigUInt64LE(data, Constants.ZIP64SIZ);
            _offset = Utils.readBigUInt64LE(data, Constants.ZIP64OFF);
            _commentLength = 0;
          }
        },
        toBinary: function() {
          var b = Buffer.alloc(Constants.ENDHDR + _commentLength);
          b.writeUInt32LE(Constants.ENDSIG, 0);
          b.writeUInt32LE(0, 4);
          b.writeUInt16LE(_volumeEntries, Constants.ENDSUB);
          b.writeUInt16LE(_totalEntries, Constants.ENDTOT);
          b.writeUInt32LE(_size, Constants.ENDSIZ);
          b.writeUInt32LE(_offset, Constants.ENDOFF);
          b.writeUInt16LE(_commentLength, Constants.ENDCOM);
          b.fill(" ", Constants.ENDHDR);
          return b;
        },
        toJSON: function() {
          const offset = function(nr, len) {
            let offs = nr.toString(16).toUpperCase();
            while (offs.length < len)
              offs = "0" + offs;
            return "0x" + offs;
          };
          return {
            diskEntries: _volumeEntries,
            totalEntries: _totalEntries,
            size: _size + " bytes",
            offset: offset(_offset, 4),
            commentLength: _commentLength
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// ../node_modules/adm-zip/headers/index.js
var require_headers = __commonJS({
  "../node_modules/adm-zip/headers/index.js"(exports2) {
    exports2.EntryHeader = require_entryHeader();
    exports2.MainHeader = require_mainHeader();
  }
});

// ../node_modules/adm-zip/methods/deflater.js
var require_deflater = __commonJS({
  "../node_modules/adm-zip/methods/deflater.js"(exports2, module2) {
    module2.exports = function(inbuf) {
      var zlib = require("zlib");
      var opts = { chunkSize: (parseInt(inbuf.length / 1024) + 1) * 1024 };
      return {
        deflate: function() {
          return zlib.deflateRawSync(inbuf, opts);
        },
        deflateAsync: function(callback) {
          var tmp = zlib.createDeflateRaw(opts), parts = [], total = 0;
          tmp.on("data", function(data) {
            parts.push(data);
            total += data.length;
          });
          tmp.on("end", function() {
            var buf = Buffer.alloc(total), written = 0;
            buf.fill(0);
            for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              part.copy(buf, written);
              written += part.length;
            }
            callback && callback(buf);
          });
          tmp.end(inbuf);
        }
      };
    };
  }
});

// ../node_modules/adm-zip/methods/inflater.js
var require_inflater = __commonJS({
  "../node_modules/adm-zip/methods/inflater.js"(exports2, module2) {
    module2.exports = function(inbuf) {
      var zlib = require("zlib");
      return {
        inflate: function() {
          return zlib.inflateRawSync(inbuf);
        },
        inflateAsync: function(callback) {
          var tmp = zlib.createInflateRaw(), parts = [], total = 0;
          tmp.on("data", function(data) {
            parts.push(data);
            total += data.length;
          });
          tmp.on("end", function() {
            var buf = Buffer.alloc(total), written = 0;
            buf.fill(0);
            for (var i = 0; i < parts.length; i++) {
              var part = parts[i];
              part.copy(buf, written);
              written += part.length;
            }
            callback && callback(buf);
          });
          tmp.end(inbuf);
        }
      };
    };
  }
});

// ../node_modules/adm-zip/methods/zipcrypto.js
var require_zipcrypto = __commonJS({
  "../node_modules/adm-zip/methods/zipcrypto.js"(exports2, module2) {
    "use strict";
    var { randomFillSync } = require("crypto");
    var crctable = new Uint32Array(256).map((t, crc) => {
      for (let j = 0; j < 8; j++) {
        if ((crc & 1) !== 0) {
          crc = crc >>> 1 ^ 3988292384;
        } else {
          crc >>>= 1;
        }
      }
      return crc >>> 0;
    });
    var uMul = (a, b) => Math.imul(a, b) >>> 0;
    var crc32update = (pCrc32, bval) => {
      return crctable[(pCrc32 ^ bval) & 255] ^ pCrc32 >>> 8;
    };
    var genSalt = () => {
      if (typeof randomFillSync === "function") {
        return randomFillSync(Buffer.alloc(12));
      } else {
        return genSalt.node();
      }
    };
    genSalt.node = () => {
      const salt = Buffer.alloc(12);
      const len = salt.length;
      for (let i = 0; i < len; i++)
        salt[i] = Math.random() * 256 & 255;
      return salt;
    };
    var config = {
      genSalt
    };
    function Initkeys(pw) {
      const pass = Buffer.isBuffer(pw) ? pw : Buffer.from(pw);
      this.keys = new Uint32Array([305419896, 591751049, 878082192]);
      for (let i = 0; i < pass.length; i++) {
        this.updateKeys(pass[i]);
      }
    }
    Initkeys.prototype.updateKeys = function(byteValue) {
      const keys = this.keys;
      keys[0] = crc32update(keys[0], byteValue);
      keys[1] += keys[0] & 255;
      keys[1] = uMul(keys[1], 134775813) + 1;
      keys[2] = crc32update(keys[2], keys[1] >>> 24);
      return byteValue;
    };
    Initkeys.prototype.next = function() {
      const k = (this.keys[2] | 2) >>> 0;
      return uMul(k, k ^ 1) >> 8 & 255;
    };
    function make_decrypter(pwd) {
      const keys = new Initkeys(pwd);
      return function(data) {
        const result = Buffer.alloc(data.length);
        let pos = 0;
        for (let c of data) {
          result[pos++] = keys.updateKeys(c ^ keys.next());
        }
        return result;
      };
    }
    function make_encrypter(pwd) {
      const keys = new Initkeys(pwd);
      return function(data, result, pos = 0) {
        if (!result)
          result = Buffer.alloc(data.length);
        for (let c of data) {
          const k = keys.next();
          result[pos++] = c ^ k;
          keys.updateKeys(c);
        }
        return result;
      };
    }
    function decrypt(data, header, pwd) {
      if (!data || !Buffer.isBuffer(data) || data.length < 12) {
        return Buffer.alloc(0);
      }
      const decrypter = make_decrypter(pwd);
      const salt = decrypter(data.slice(0, 12));
      if (salt[11] !== header.crc >>> 24) {
        throw "ADM-ZIP: Wrong Password";
      }
      return decrypter(data.slice(12));
    }
    function _salter(data) {
      if (Buffer.isBuffer(data) && data.length >= 12) {
        config.genSalt = function() {
          return data.slice(0, 12);
        };
      } else if (data === "node") {
        config.genSalt = genSalt.node;
      } else {
        config.genSalt = genSalt;
      }
    }
    function encrypt(data, header, pwd, oldlike = false) {
      if (data == null)
        data = Buffer.alloc(0);
      if (!Buffer.isBuffer(data))
        data = Buffer.from(data.toString());
      const encrypter = make_encrypter(pwd);
      const salt = config.genSalt();
      salt[11] = header.crc >>> 24 & 255;
      if (oldlike)
        salt[10] = header.crc >>> 16 & 255;
      const result = Buffer.alloc(data.length + 12);
      encrypter(salt, result);
      return encrypter(data, result, 12);
    }
    module2.exports = { decrypt, encrypt, _salter };
  }
});

// ../node_modules/adm-zip/methods/index.js
var require_methods = __commonJS({
  "../node_modules/adm-zip/methods/index.js"(exports2) {
    exports2.Deflater = require_deflater();
    exports2.Inflater = require_inflater();
    exports2.ZipCrypto = require_zipcrypto();
  }
});

// ../node_modules/adm-zip/zipEntry.js
var require_zipEntry = __commonJS({
  "../node_modules/adm-zip/zipEntry.js"(exports2, module2) {
    var Utils = require_util2();
    var Headers = require_headers();
    var Constants = Utils.Constants;
    var Methods = require_methods();
    module2.exports = function(input) {
      var _entryHeader = new Headers.EntryHeader(), _entryName = Buffer.alloc(0), _comment = Buffer.alloc(0), _isDirectory = false, uncompressedData = null, _extra = Buffer.alloc(0);
      function getCompressedDataFromZip() {
        if (!input || !Buffer.isBuffer(input)) {
          return Buffer.alloc(0);
        }
        _entryHeader.loadDataHeaderFromBinary(input);
        return input.slice(_entryHeader.realDataOffset, _entryHeader.realDataOffset + _entryHeader.compressedSize);
      }
      function crc32OK(data) {
        if ((_entryHeader.flags & 8) !== 8) {
          if (Utils.crc32(data) !== _entryHeader.dataHeader.crc) {
            return false;
          }
        } else {
        }
        return true;
      }
      function decompress(async, callback, pass) {
        if (typeof callback === "undefined" && typeof async === "string") {
          pass = async;
          async = void 0;
        }
        if (_isDirectory) {
          if (async && callback) {
            callback(Buffer.alloc(0), Utils.Errors.DIRECTORY_CONTENT_ERROR);
          }
          return Buffer.alloc(0);
        }
        var compressedData = getCompressedDataFromZip();
        if (compressedData.length === 0) {
          if (async && callback)
            callback(compressedData);
          return compressedData;
        }
        if (_entryHeader.encripted) {
          if (typeof pass !== "string" && !Buffer.isBuffer(pass)) {
            throw new Error("ADM-ZIP: Incompatible password parameter");
          }
          compressedData = Methods.ZipCrypto.decrypt(compressedData, _entryHeader, pass);
        }
        var data = Buffer.alloc(_entryHeader.size);
        switch (_entryHeader.method) {
          case Utils.Constants.STORED:
            compressedData.copy(data);
            if (!crc32OK(data)) {
              if (async && callback)
                callback(data, Utils.Errors.BAD_CRC);
              throw new Error(Utils.Errors.BAD_CRC);
            } else {
              if (async && callback)
                callback(data);
              return data;
            }
          case Utils.Constants.DEFLATED:
            var inflater = new Methods.Inflater(compressedData);
            if (!async) {
              const result = inflater.inflate(data);
              result.copy(data, 0);
              if (!crc32OK(data)) {
                throw new Error(Utils.Errors.BAD_CRC + " " + _entryName.toString());
              }
              return data;
            } else {
              inflater.inflateAsync(function(result) {
                result.copy(result, 0);
                if (callback) {
                  if (!crc32OK(result)) {
                    callback(result, Utils.Errors.BAD_CRC);
                  } else {
                    callback(result);
                  }
                }
              });
            }
            break;
          default:
            if (async && callback)
              callback(Buffer.alloc(0), Utils.Errors.UNKNOWN_METHOD);
            throw new Error(Utils.Errors.UNKNOWN_METHOD);
        }
      }
      function compress(async, callback) {
        if ((!uncompressedData || !uncompressedData.length) && Buffer.isBuffer(input)) {
          if (async && callback)
            callback(getCompressedDataFromZip());
          return getCompressedDataFromZip();
        }
        if (uncompressedData.length && !_isDirectory) {
          var compressedData;
          switch (_entryHeader.method) {
            case Utils.Constants.STORED:
              _entryHeader.compressedSize = _entryHeader.size;
              compressedData = Buffer.alloc(uncompressedData.length);
              uncompressedData.copy(compressedData);
              if (async && callback)
                callback(compressedData);
              return compressedData;
            default:
            case Utils.Constants.DEFLATED:
              var deflater = new Methods.Deflater(uncompressedData);
              if (!async) {
                var deflated = deflater.deflate();
                _entryHeader.compressedSize = deflated.length;
                return deflated;
              } else {
                deflater.deflateAsync(function(data) {
                  compressedData = Buffer.alloc(data.length);
                  _entryHeader.compressedSize = data.length;
                  data.copy(compressedData);
                  callback && callback(compressedData);
                });
              }
              deflater = null;
              break;
          }
        } else if (async && callback) {
          callback(Buffer.alloc(0));
        } else {
          return Buffer.alloc(0);
        }
      }
      function readUInt64LE2(buffer, offset) {
        return (buffer.readUInt32LE(offset + 4) << 4) + buffer.readUInt32LE(offset);
      }
      function parseExtra(data) {
        var offset = 0;
        var signature, size, part;
        while (offset < data.length) {
          signature = data.readUInt16LE(offset);
          offset += 2;
          size = data.readUInt16LE(offset);
          offset += 2;
          part = data.slice(offset, offset + size);
          offset += size;
          if (Constants.ID_ZIP64 === signature) {
            parseZip64ExtendedInformation(part);
          }
        }
      }
      function parseZip64ExtendedInformation(data) {
        var size, compressedSize, offset, diskNumStart;
        if (data.length >= Constants.EF_ZIP64_SCOMP) {
          size = readUInt64LE2(data, Constants.EF_ZIP64_SUNCOMP);
          if (_entryHeader.size === Constants.EF_ZIP64_OR_32) {
            _entryHeader.size = size;
          }
        }
        if (data.length >= Constants.EF_ZIP64_RHO) {
          compressedSize = readUInt64LE2(data, Constants.EF_ZIP64_SCOMP);
          if (_entryHeader.compressedSize === Constants.EF_ZIP64_OR_32) {
            _entryHeader.compressedSize = compressedSize;
          }
        }
        if (data.length >= Constants.EF_ZIP64_DSN) {
          offset = readUInt64LE2(data, Constants.EF_ZIP64_RHO);
          if (_entryHeader.offset === Constants.EF_ZIP64_OR_32) {
            _entryHeader.offset = offset;
          }
        }
        if (data.length >= Constants.EF_ZIP64_DSN + 4) {
          diskNumStart = data.readUInt32LE(Constants.EF_ZIP64_DSN);
          if (_entryHeader.diskNumStart === Constants.EF_ZIP64_OR_16) {
            _entryHeader.diskNumStart = diskNumStart;
          }
        }
      }
      return {
        get entryName() {
          return _entryName.toString();
        },
        get rawEntryName() {
          return _entryName;
        },
        set entryName(val) {
          _entryName = Utils.toBuffer(val);
          var lastChar = _entryName[_entryName.length - 1];
          _isDirectory = lastChar === 47 || lastChar === 92;
          _entryHeader.fileNameLength = _entryName.length;
        },
        get extra() {
          return _extra;
        },
        set extra(val) {
          _extra = val;
          _entryHeader.extraLength = val.length;
          parseExtra(val);
        },
        get comment() {
          return _comment.toString();
        },
        set comment(val) {
          _comment = Utils.toBuffer(val);
          _entryHeader.commentLength = _comment.length;
        },
        get name() {
          var n = _entryName.toString();
          return _isDirectory ? n.substr(n.length - 1).split("/").pop() : n.split("/").pop();
        },
        get isDirectory() {
          return _isDirectory;
        },
        getCompressedData: function() {
          return compress(false, null);
        },
        getCompressedDataAsync: function(callback) {
          compress(true, callback);
        },
        setData: function(value) {
          uncompressedData = Utils.toBuffer(value);
          if (!_isDirectory && uncompressedData.length) {
            _entryHeader.size = uncompressedData.length;
            _entryHeader.method = Utils.Constants.DEFLATED;
            _entryHeader.crc = Utils.crc32(value);
            _entryHeader.changed = true;
          } else {
            _entryHeader.method = Utils.Constants.STORED;
          }
        },
        getData: function(pass) {
          if (_entryHeader.changed) {
            return uncompressedData;
          } else {
            return decompress(false, null, pass);
          }
        },
        getDataAsync: function(callback, pass) {
          if (_entryHeader.changed) {
            callback(uncompressedData);
          } else {
            decompress(true, callback, pass);
          }
        },
        set attr(attr) {
          _entryHeader.attr = attr;
        },
        get attr() {
          return _entryHeader.attr;
        },
        set header(data) {
          _entryHeader.loadFromBinary(data);
        },
        get header() {
          return _entryHeader;
        },
        packHeader: function() {
          var header = _entryHeader.entryHeaderToBinary();
          var addpos = Utils.Constants.CENHDR;
          _entryName.copy(header, addpos);
          addpos += _entryName.length;
          if (_entryHeader.extraLength) {
            _extra.copy(header, addpos);
            addpos += _entryHeader.extraLength;
          }
          if (_entryHeader.commentLength) {
            _comment.copy(header, addpos);
          }
          return header;
        },
        toJSON: function() {
          const bytes = function(nr) {
            return "<" + (nr && nr.length + " bytes buffer" || "null") + ">";
          };
          return {
            entryName: this.entryName,
            name: this.name,
            comment: this.comment,
            isDirectory: this.isDirectory,
            header: _entryHeader.toJSON(),
            compressedData: bytes(input),
            data: bytes(uncompressedData)
          };
        },
        toString: function() {
          return JSON.stringify(this.toJSON(), null, "	");
        }
      };
    };
  }
});

// ../node_modules/adm-zip/zipFile.js
var require_zipFile = __commonJS({
  "../node_modules/adm-zip/zipFile.js"(exports2, module2) {
    var ZipEntry = require_zipEntry();
    var Headers = require_headers();
    var Utils = require_util2();
    module2.exports = function(inBuffer, options) {
      var entryList = [], entryTable = {}, _comment = Buffer.alloc(0), mainHeader = new Headers.MainHeader(), loadedEntries = false;
      const opts = Object.assign(Object.create(null), options);
      const { noSort } = opts;
      if (inBuffer) {
        readMainHeader(opts.readEntries);
      } else {
        loadedEntries = true;
      }
      function iterateEntries(callback) {
        const totalEntries = mainHeader.diskEntries;
        let index = mainHeader.offset;
        for (let i = 0; i < totalEntries; i++) {
          let tmp = index;
          const entry = new ZipEntry(inBuffer);
          entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);
          entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
          index += entry.header.entryHeaderSize;
          callback(entry);
        }
      }
      function readEntries() {
        loadedEntries = true;
        entryTable = {};
        entryList = new Array(mainHeader.diskEntries);
        var index = mainHeader.offset;
        for (var i = 0; i < entryList.length; i++) {
          var tmp = index, entry = new ZipEntry(inBuffer);
          entry.header = inBuffer.slice(tmp, tmp += Utils.Constants.CENHDR);
          entry.entryName = inBuffer.slice(tmp, tmp += entry.header.fileNameLength);
          if (entry.header.extraLength) {
            entry.extra = inBuffer.slice(tmp, tmp += entry.header.extraLength);
          }
          if (entry.header.commentLength)
            entry.comment = inBuffer.slice(tmp, tmp + entry.header.commentLength);
          index += entry.header.entryHeaderSize;
          entryList[i] = entry;
          entryTable[entry.entryName] = entry;
        }
      }
      function readMainHeader(readNow) {
        var i = inBuffer.length - Utils.Constants.ENDHDR, max = Math.max(0, i - 65535), n = max, endStart = inBuffer.length, endOffset = -1, commentEnd = 0;
        for (i; i >= n; i--) {
          if (inBuffer[i] !== 80)
            continue;
          if (inBuffer.readUInt32LE(i) === Utils.Constants.ENDSIG) {
            endOffset = i;
            commentEnd = i;
            endStart = i + Utils.Constants.ENDHDR;
            n = i - Utils.Constants.END64HDR;
            continue;
          }
          if (inBuffer.readUInt32LE(i) === Utils.Constants.END64SIG) {
            n = max;
            continue;
          }
          if (inBuffer.readUInt32LE(i) === Utils.Constants.ZIP64SIG) {
            endOffset = i;
            endStart = i + Utils.readBigUInt64LE(inBuffer, i + Utils.Constants.ZIP64SIZE) + Utils.Constants.ZIP64LEAD;
            break;
          }
        }
        if (!~endOffset)
          throw new Error(Utils.Errors.INVALID_FORMAT);
        mainHeader.loadFromBinary(inBuffer.slice(endOffset, endStart));
        if (mainHeader.commentLength) {
          _comment = inBuffer.slice(commentEnd + Utils.Constants.ENDHDR);
        }
        if (readNow)
          readEntries();
      }
      function sortEntries() {
        if (entryList.length > 1 && !noSort) {
          entryList.sort((a, b) => a.entryName.toLowerCase().localeCompare(b.entryName.toLowerCase()));
        }
      }
      return {
        get entries() {
          if (!loadedEntries) {
            readEntries();
          }
          return entryList;
        },
        get comment() {
          return _comment.toString();
        },
        set comment(val) {
          _comment = Utils.toBuffer(val);
          mainHeader.commentLength = _comment.length;
        },
        getEntryCount: function() {
          if (!loadedEntries) {
            return mainHeader.diskEntries;
          }
          return entryList.length;
        },
        forEach: function(callback) {
          if (!loadedEntries) {
            iterateEntries(callback);
            return;
          }
          entryList.forEach(callback);
        },
        getEntry: function(entryName) {
          if (!loadedEntries) {
            readEntries();
          }
          return entryTable[entryName] || null;
        },
        setEntry: function(entry) {
          if (!loadedEntries) {
            readEntries();
          }
          entryList.push(entry);
          entryTable[entry.entryName] = entry;
          mainHeader.totalEntries = entryList.length;
        },
        deleteEntry: function(entryName) {
          if (!loadedEntries) {
            readEntries();
          }
          var entry = entryTable[entryName];
          if (entry && entry.isDirectory) {
            var _self = this;
            this.getEntryChildren(entry).forEach(function(child) {
              if (child.entryName !== entryName) {
                _self.deleteEntry(child.entryName);
              }
            });
          }
          entryList.splice(entryList.indexOf(entry), 1);
          delete entryTable[entryName];
          mainHeader.totalEntries = entryList.length;
        },
        getEntryChildren: function(entry) {
          if (!loadedEntries) {
            readEntries();
          }
          if (entry && entry.isDirectory) {
            const list = [];
            const name = entry.entryName;
            const len = name.length;
            entryList.forEach(function(zipEntry) {
              if (zipEntry.entryName.substr(0, len) === name) {
                list.push(zipEntry);
              }
            });
            return list;
          }
          return [];
        },
        compressToBuffer: function() {
          if (!loadedEntries) {
            readEntries();
          }
          sortEntries();
          const dataBlock = [];
          const entryHeaders = [];
          let totalSize = 0;
          let dindex = 0;
          mainHeader.size = 0;
          mainHeader.offset = 0;
          for (const entry of entryList) {
            const compressedData = entry.getCompressedData();
            entry.header.offset = dindex;
            const dataHeader = entry.header.dataHeaderToBinary();
            const entryNameLen = entry.rawEntryName.length;
            const postHeader = Buffer.alloc(entryNameLen + entry.extra.length);
            entry.rawEntryName.copy(postHeader, 0);
            postHeader.copy(entry.extra, entryNameLen);
            const dataLength = dataHeader.length + postHeader.length + compressedData.length;
            dindex += dataLength;
            dataBlock.push(dataHeader);
            dataBlock.push(postHeader);
            dataBlock.push(compressedData);
            const entryHeader = entry.packHeader();
            entryHeaders.push(entryHeader);
            mainHeader.size += entryHeader.length;
            totalSize += dataLength + entryHeader.length;
          }
          totalSize += mainHeader.mainHeaderSize;
          mainHeader.offset = dindex;
          dindex = 0;
          const outBuffer = Buffer.alloc(totalSize);
          for (const content of dataBlock) {
            content.copy(outBuffer, dindex);
            dindex += content.length;
          }
          for (const content of entryHeaders) {
            content.copy(outBuffer, dindex);
            dindex += content.length;
          }
          const mh = mainHeader.toBinary();
          if (_comment) {
            _comment.copy(mh, Utils.Constants.ENDHDR);
          }
          mh.copy(outBuffer, dindex);
          return outBuffer;
        },
        toAsyncBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
          try {
            if (!loadedEntries) {
              readEntries();
            }
            sortEntries();
            const dataBlock = [];
            const entryHeaders = [];
            let totalSize = 0;
            let dindex = 0;
            mainHeader.size = 0;
            mainHeader.offset = 0;
            const compress2Buffer = function(entryLists) {
              if (entryLists.length) {
                const entry = entryLists.pop();
                const name = entry.entryName + entry.extra.toString();
                if (onItemStart)
                  onItemStart(name);
                entry.getCompressedDataAsync(function(compressedData) {
                  if (onItemEnd)
                    onItemEnd(name);
                  entry.header.offset = dindex;
                  const dataHeader = entry.header.dataHeaderToBinary();
                  const postHeader = Buffer.alloc(name.length, name);
                  const dataLength = dataHeader.length + postHeader.length + compressedData.length;
                  dindex += dataLength;
                  dataBlock.push(dataHeader);
                  dataBlock.push(postHeader);
                  dataBlock.push(compressedData);
                  const entryHeader = entry.packHeader();
                  entryHeaders.push(entryHeader);
                  mainHeader.size += entryHeader.length;
                  totalSize += dataLength + entryHeader.length;
                  compress2Buffer(entryLists);
                });
              } else {
                totalSize += mainHeader.mainHeaderSize;
                mainHeader.offset = dindex;
                dindex = 0;
                const outBuffer = Buffer.alloc(totalSize);
                dataBlock.forEach(function(content) {
                  content.copy(outBuffer, dindex);
                  dindex += content.length;
                });
                entryHeaders.forEach(function(content) {
                  content.copy(outBuffer, dindex);
                  dindex += content.length;
                });
                const mh = mainHeader.toBinary();
                if (_comment) {
                  _comment.copy(mh, Utils.Constants.ENDHDR);
                }
                mh.copy(outBuffer, dindex);
                onSuccess(outBuffer);
              }
            };
            compress2Buffer(entryList);
          } catch (e) {
            onFail(e);
          }
        }
      };
    };
  }
});

// ../node_modules/adm-zip/adm-zip.js
var require_adm_zip = __commonJS({
  "../node_modules/adm-zip/adm-zip.js"(exports2, module2) {
    var Utils = require_util2();
    var pth = require("path");
    var ZipEntry = require_zipEntry();
    var ZipFile = require_zipFile();
    var get_Bool = (val, def) => typeof val === "boolean" ? val : def;
    var get_Str = (val, def) => typeof val === "string" ? val : def;
    var defaultOptions = {
      noSort: false,
      readEntries: false,
      method: Utils.Constants.NONE,
      fs: null
    };
    module2.exports = function(input, options) {
      let inBuffer = null;
      const opts = Object.assign(Object.create(null), defaultOptions);
      if (input && typeof input === "object") {
        if (!(input instanceof Uint8Array)) {
          Object.assign(opts, input);
          input = opts.input ? opts.input : void 0;
          if (opts.input)
            delete opts.input;
        }
        if (Buffer.isBuffer(input)) {
          inBuffer = input;
          opts.method = Utils.Constants.BUFFER;
          input = void 0;
        }
      }
      Object.assign(opts, options);
      const filetools = new Utils(opts);
      if (input && typeof input === "string") {
        if (filetools.fs.existsSync(input)) {
          opts.method = Utils.Constants.FILE;
          opts.filename = input;
          inBuffer = filetools.fs.readFileSync(input);
        } else {
          throw new Error(Utils.Errors.INVALID_FILENAME);
        }
      }
      const _zip = new ZipFile(inBuffer, opts);
      const { canonical, sanitize } = Utils;
      function getEntry(entry) {
        if (entry && _zip) {
          var item;
          if (typeof entry === "string")
            item = _zip.getEntry(entry);
          if (typeof entry === "object" && typeof entry.entryName !== "undefined" && typeof entry.header !== "undefined")
            item = _zip.getEntry(entry.entryName);
          if (item) {
            return item;
          }
        }
        return null;
      }
      function fixPath(zipPath) {
        const { join, normalize, sep } = pth.posix;
        return join(".", normalize(sep + zipPath.split("\\").join(sep) + sep));
      }
      return {
        readFile: function(entry, pass) {
          var item = getEntry(entry);
          return item && item.getData(pass) || null;
        },
        readFileAsync: function(entry, callback) {
          var item = getEntry(entry);
          if (item) {
            item.getDataAsync(callback);
          } else {
            callback(null, "getEntry failed for:" + entry);
          }
        },
        readAsText: function(entry, encoding) {
          var item = getEntry(entry);
          if (item) {
            var data = item.getData();
            if (data && data.length) {
              return data.toString(encoding || "utf8");
            }
          }
          return "";
        },
        readAsTextAsync: function(entry, callback, encoding) {
          var item = getEntry(entry);
          if (item) {
            item.getDataAsync(function(data, err) {
              if (err) {
                callback(data, err);
                return;
              }
              if (data && data.length) {
                callback(data.toString(encoding || "utf8"));
              } else {
                callback("");
              }
            });
          } else {
            callback("");
          }
        },
        deleteFile: function(entry) {
          var item = getEntry(entry);
          if (item) {
            _zip.deleteEntry(item.entryName);
          }
        },
        addZipComment: function(comment) {
          _zip.comment = comment;
        },
        getZipComment: function() {
          return _zip.comment || "";
        },
        addZipEntryComment: function(entry, comment) {
          var item = getEntry(entry);
          if (item) {
            item.comment = comment;
          }
        },
        getZipEntryComment: function(entry) {
          var item = getEntry(entry);
          if (item) {
            return item.comment || "";
          }
          return "";
        },
        updateFile: function(entry, content) {
          var item = getEntry(entry);
          if (item) {
            item.setData(content);
          }
        },
        addLocalFile: function(localPath, zipPath, zipName, comment) {
          if (filetools.fs.existsSync(localPath)) {
            zipPath = zipPath ? fixPath(zipPath) : "";
            var p = localPath.split("\\").join("/").split("/").pop();
            zipPath += zipName ? zipName : p;
            const _attr = filetools.fs.statSync(localPath);
            this.addFile(zipPath, filetools.fs.readFileSync(localPath), comment, _attr);
          } else {
            throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
          }
        },
        addLocalFolder: function(localPath, zipPath, filter) {
          if (filter instanceof RegExp) {
            filter = function(rx) {
              return function(filename) {
                return rx.test(filename);
              };
            }(filter);
          } else if (typeof filter !== "function") {
            filter = function() {
              return true;
            };
          }
          zipPath = zipPath ? fixPath(zipPath) : "";
          localPath = pth.normalize(localPath);
          if (filetools.fs.existsSync(localPath)) {
            const items = filetools.findFiles(localPath);
            const self2 = this;
            if (items.length) {
              items.forEach(function(filepath) {
                var p = pth.relative(localPath, filepath).split("\\").join("/");
                if (filter(p)) {
                  var stats = filetools.fs.statSync(filepath);
                  if (stats.isFile()) {
                    self2.addFile(zipPath + p, filetools.fs.readFileSync(filepath), "", stats);
                  } else {
                    self2.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                  }
                }
              });
            }
          } else {
            throw new Error(Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
          }
        },
        addLocalFolderAsync: function(localPath, callback, zipPath, filter) {
          if (filter instanceof RegExp) {
            filter = function(rx) {
              return function(filename) {
                return rx.test(filename);
              };
            }(filter);
          } else if (typeof filter !== "function") {
            filter = function() {
              return true;
            };
          }
          zipPath = zipPath ? fixPath(zipPath) : "";
          localPath = pth.normalize(localPath);
          var self2 = this;
          filetools.fs.open(localPath, "r", function(err) {
            if (err && err.code === "ENOENT") {
              callback(void 0, Utils.Errors.FILE_NOT_FOUND.replace("%s", localPath));
            } else if (err) {
              callback(void 0, err);
            } else {
              var items = filetools.findFiles(localPath);
              var i = -1;
              var next = function() {
                i += 1;
                if (i < items.length) {
                  var filepath = items[i];
                  var p = pth.relative(localPath, filepath).split("\\").join("/");
                  p = p.normalize("NFD").replace(/[\u0300-\u036f]/g, "").replace(/[^\x20-\x7E]/g, "");
                  if (filter(p)) {
                    filetools.fs.stat(filepath, function(er0, stats) {
                      if (er0)
                        callback(void 0, er0);
                      if (stats.isFile()) {
                        filetools.fs.readFile(filepath, function(er1, data) {
                          if (er1) {
                            callback(void 0, er1);
                          } else {
                            self2.addFile(zipPath + p, data, "", stats);
                            next();
                          }
                        });
                      } else {
                        self2.addFile(zipPath + p + "/", Buffer.alloc(0), "", stats);
                        next();
                      }
                    });
                  } else {
                    next();
                  }
                } else {
                  callback(true, void 0);
                }
              };
              next();
            }
          });
        },
        addLocalFolderPromise: function(localPath, props) {
          return new Promise((resolve2, reject2) => {
            const { filter, zipPath } = Object.assign({}, props);
            this.addLocalFolderAsync(localPath, (done, err) => {
              if (err)
                reject2(err);
              if (done)
                resolve2(this);
            }, zipPath, filter);
          });
        },
        addFile: function(entryName, content, comment, attr) {
          let entry = getEntry(entryName);
          const update = entry != null;
          if (!update) {
            entry = new ZipEntry();
            entry.entryName = entryName;
          }
          entry.comment = comment || "";
          const isStat = typeof attr === "object" && attr instanceof filetools.fs.Stats;
          if (isStat) {
            entry.header.time = attr.mtime;
          }
          var fileattr = entry.isDirectory ? 16 : 0;
          if (!Utils.isWin) {
            let unix = entry.isDirectory ? 16384 : 32768;
            if (isStat) {
              unix |= 4095 & attr.mode;
            } else if (typeof attr === "number") {
              unix |= 4095 & attr;
            } else {
              unix |= entry.isDirectory ? 493 : 420;
            }
            fileattr = (fileattr | unix << 16) >>> 0;
          }
          entry.attr = fileattr;
          entry.setData(content);
          if (!update)
            _zip.setEntry(entry);
        },
        getEntries: function() {
          return _zip ? _zip.entries : [];
        },
        getEntry: function(name) {
          return getEntry(name);
        },
        getEntryCount: function() {
          return _zip.getEntryCount();
        },
        forEach: function(callback) {
          return _zip.forEach(callback);
        },
        extractEntryTo: function(entry, targetPath, maintainEntryPath, overwrite, keepOriginalPermission, outFileName) {
          overwrite = get_Bool(overwrite, false);
          keepOriginalPermission = get_Bool(keepOriginalPermission, false);
          maintainEntryPath = get_Bool(maintainEntryPath, true);
          outFileName = get_Str(outFileName, get_Str(keepOriginalPermission, void 0));
          var item = getEntry(entry);
          if (!item) {
            throw new Error(Utils.Errors.NO_ENTRY);
          }
          var entryName = canonical(item.entryName);
          var target = sanitize(targetPath, outFileName && !item.isDirectory ? outFileName : maintainEntryPath ? entryName : pth.basename(entryName));
          if (item.isDirectory) {
            var children = _zip.getEntryChildren(item);
            children.forEach(function(child) {
              if (child.isDirectory)
                return;
              var content2 = child.getData();
              if (!content2) {
                throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
              }
              var name = canonical(child.entryName);
              var childName = sanitize(targetPath, maintainEntryPath ? name : pth.basename(name));
              const fileAttr2 = keepOriginalPermission ? child.header.fileAttr : void 0;
              filetools.writeFileTo(childName, content2, overwrite, fileAttr2);
            });
            return true;
          }
          var content = item.getData();
          if (!content)
            throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
          if (filetools.fs.existsSync(target) && !overwrite) {
            throw new Error(Utils.Errors.CANT_OVERRIDE);
          }
          const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
          filetools.writeFileTo(target, content, overwrite, fileAttr);
          return true;
        },
        test: function(pass) {
          if (!_zip) {
            return false;
          }
          for (var entry in _zip.entries) {
            try {
              if (entry.isDirectory) {
                continue;
              }
              var content = _zip.entries[entry].getData(pass);
              if (!content) {
                return false;
              }
            } catch (err) {
              return false;
            }
          }
          return true;
        },
        extractAllTo: function(targetPath, overwrite, keepOriginalPermission, pass) {
          overwrite = get_Bool(overwrite, false);
          pass = get_Str(keepOriginalPermission, pass);
          keepOriginalPermission = get_Bool(keepOriginalPermission, false);
          if (!_zip) {
            throw new Error(Utils.Errors.NO_ZIP);
          }
          _zip.entries.forEach(function(entry) {
            var entryName = sanitize(targetPath, canonical(entry.entryName.toString()));
            if (entry.isDirectory) {
              filetools.makeDir(entryName);
              return;
            }
            var content = entry.getData(pass);
            if (!content) {
              throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
            }
            const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
            filetools.writeFileTo(entryName, content, overwrite, fileAttr);
            try {
              filetools.fs.utimesSync(entryName, entry.header.time, entry.header.time);
            } catch (err) {
              throw new Error(Utils.Errors.CANT_EXTRACT_FILE);
            }
          });
        },
        extractAllToAsync: function(targetPath, overwrite, keepOriginalPermission, callback) {
          if (!callback) {
            callback = function() {
            };
          }
          overwrite = get_Bool(overwrite, false);
          if (typeof keepOriginalPermission === "function" && !callback)
            callback = keepOriginalPermission;
          keepOriginalPermission = get_Bool(keepOriginalPermission, false);
          if (!_zip) {
            callback(new Error(Utils.Errors.NO_ZIP));
            return;
          }
          targetPath = pth.resolve(targetPath);
          const getPath = (entry) => sanitize(targetPath, pth.normalize(canonical(entry.entryName.toString())));
          const getError = (msg, file) => new Error(msg + ': "' + file + '"');
          const dirEntries = [];
          const fileEntries = new Set();
          _zip.entries.forEach((e) => {
            if (e.isDirectory) {
              dirEntries.push(e);
            } else {
              fileEntries.add(e);
            }
          });
          for (const entry of dirEntries) {
            const dirPath = getPath(entry);
            const dirAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
            try {
              filetools.makeDir(dirPath);
              if (dirAttr)
                filetools.fs.chmodSync(dirPath, dirAttr);
              filetools.fs.utimesSync(dirPath, entry.header.time, entry.header.time);
            } catch (er) {
              callback(getError("Unable to create folder", dirPath));
            }
          }
          const done = () => {
            if (fileEntries.size === 0) {
              callback();
            }
          };
          for (const entry of fileEntries.values()) {
            const entryName = pth.normalize(canonical(entry.entryName.toString()));
            const filePath = sanitize(targetPath, entryName);
            entry.getDataAsync(function(content, err_1) {
              if (err_1) {
                callback(new Error(err_1));
                return;
              }
              if (!content) {
                callback(new Error(Utils.Errors.CANT_EXTRACT_FILE));
              } else {
                const fileAttr = keepOriginalPermission ? entry.header.fileAttr : void 0;
                filetools.writeFileToAsync(filePath, content, overwrite, fileAttr, function(succ) {
                  if (!succ) {
                    callback(getError("Unable to write file", filePath));
                    return;
                  }
                  filetools.fs.utimes(filePath, entry.header.time, entry.header.time, function(err_2) {
                    if (err_2) {
                      callback(getError("Unable to set times", filePath));
                      return;
                    }
                    fileEntries.delete(entry);
                    done();
                  });
                });
              }
            });
          }
          done();
        },
        writeZip: function(targetFileName, callback) {
          if (arguments.length === 1) {
            if (typeof targetFileName === "function") {
              callback = targetFileName;
              targetFileName = "";
            }
          }
          if (!targetFileName && opts.filename) {
            targetFileName = opts.filename;
          }
          if (!targetFileName)
            return;
          var zipData = _zip.compressToBuffer();
          if (zipData) {
            var ok = filetools.writeFileTo(targetFileName, zipData, true);
            if (typeof callback === "function")
              callback(!ok ? new Error("failed") : null, "");
          }
        },
        writeZipPromise: function(targetFileName, props) {
          const { overwrite, perm } = Object.assign({ overwrite: true }, props);
          return new Promise((resolve2, reject2) => {
            if (!targetFileName && opts.filename)
              targetFileName = opts.filename;
            if (!targetFileName)
              reject2("ADM-ZIP: ZIP File Name Missing");
            this.toBufferPromise().then((zipData) => {
              const ret = (done) => done ? resolve2(done) : reject2("ADM-ZIP: Wasn't able to write zip file");
              filetools.writeFileToAsync(targetFileName, zipData, overwrite, perm, ret);
            }, reject2);
          });
        },
        toBufferPromise: function() {
          return new Promise((resolve2, reject2) => {
            _zip.toAsyncBuffer(resolve2, reject2);
          });
        },
        toBuffer: function(onSuccess, onFail, onItemStart, onItemEnd) {
          this.valueOf = 2;
          if (typeof onSuccess === "function") {
            _zip.toAsyncBuffer(onSuccess, onFail, onItemStart, onItemEnd);
            return null;
          }
          return _zip.compressToBuffer();
        }
      };
    };
  }
});

// ../node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "../node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../node_modules/content-disposition/index.js
var require_content_disposition = __commonJS({
  "../node_modules/content-disposition/index.js"(exports2, module2) {
    "use strict";
    module2.exports = contentDisposition;
    module2.exports.parse = parse;
    var basename = require("path").basename;
    var Buffer2 = require_safe_buffer2().Buffer;
    var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
    var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
    var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
    var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
    var QESC_REGEXP = /\\([\u0000-\u007f])/g;
    var QUOTE_REGEXP = /([\\"])/g;
    var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
    var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
    var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
    var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
    var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
    function contentDisposition(filename, options) {
      var opts = options || {};
      var type = opts.type || "attachment";
      var params = createparams(filename, opts.fallback);
      return format(new ContentDisposition(type, params));
    }
    function createparams(filename, fallback) {
      if (filename === void 0) {
        return;
      }
      var params = {};
      if (typeof filename !== "string") {
        throw new TypeError("filename must be a string");
      }
      if (fallback === void 0) {
        fallback = true;
      }
      if (typeof fallback !== "string" && typeof fallback !== "boolean") {
        throw new TypeError("fallback must be a string or boolean");
      }
      if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
        throw new TypeError("fallback must be ISO-8859-1 string");
      }
      var name = basename(filename);
      var isQuotedString = TEXT_REGEXP.test(name);
      var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name) : basename(fallback);
      var hasFallback = typeof fallbackName === "string" && fallbackName !== name;
      if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name)) {
        params["filename*"] = name;
      }
      if (isQuotedString || hasFallback) {
        params.filename = hasFallback ? fallbackName : name;
      }
      return params;
    }
    function format(obj) {
      var parameters = obj.parameters;
      var type = obj.type;
      if (!type || typeof type !== "string" || !TOKEN_REGEXP.test(type)) {
        throw new TypeError("invalid type");
      }
      var string = String(type).toLowerCase();
      if (parameters && typeof parameters === "object") {
        var param;
        var params = Object.keys(parameters).sort();
        for (var i = 0; i < params.length; i++) {
          param = params[i];
          var val = param.substr(-1) === "*" ? ustring(parameters[param]) : qstring(parameters[param]);
          string += "; " + param + "=" + val;
        }
      }
      return string;
    }
    function decodefield(str) {
      var match = EXT_VALUE_REGEXP.exec(str);
      if (!match) {
        throw new TypeError("invalid extended field value");
      }
      var charset = match[1].toLowerCase();
      var encoded = match[2];
      var value;
      var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
      switch (charset) {
        case "iso-8859-1":
          value = getlatin1(binary);
          break;
        case "utf-8":
          value = Buffer2.from(binary, "binary").toString("utf8");
          break;
        default:
          throw new TypeError("unsupported charset in extended field");
      }
      return value;
    }
    function getlatin1(val) {
      return String(val).replace(NON_LATIN1_REGEXP, "?");
    }
    function parse(string) {
      if (!string || typeof string !== "string") {
        throw new TypeError("argument string is required");
      }
      var match = DISPOSITION_TYPE_REGEXP.exec(string);
      if (!match) {
        throw new TypeError("invalid type format");
      }
      var index = match[0].length;
      var type = match[1].toLowerCase();
      var key;
      var names = [];
      var params = {};
      var value;
      index = PARAM_REGEXP.lastIndex = match[0].substr(-1) === ";" ? index - 1 : index;
      while (match = PARAM_REGEXP.exec(string)) {
        if (match.index !== index) {
          throw new TypeError("invalid parameter format");
        }
        index += match[0].length;
        key = match[1].toLowerCase();
        value = match[2];
        if (names.indexOf(key) !== -1) {
          throw new TypeError("invalid duplicate parameter");
        }
        names.push(key);
        if (key.indexOf("*") + 1 === key.length) {
          key = key.slice(0, -1);
          value = decodefield(value);
          params[key] = value;
          continue;
        }
        if (typeof params[key] === "string") {
          continue;
        }
        if (value[0] === '"') {
          value = value.substr(1, value.length - 2).replace(QESC_REGEXP, "$1");
        }
        params[key] = value;
      }
      if (index !== -1 && index !== string.length) {
        throw new TypeError("invalid parameter format");
      }
      return new ContentDisposition(type, params);
    }
    function pdecode(str, hex) {
      return String.fromCharCode(parseInt(hex, 16));
    }
    function pencode(char) {
      return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
    }
    function qstring(val) {
      var str = String(val);
      return '"' + str.replace(QUOTE_REGEXP, "\\$1") + '"';
    }
    function ustring(val) {
      var str = String(val);
      var encoded = encodeURIComponent(str).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
      return "UTF-8''" + encoded;
    }
    function ContentDisposition(type, parameters) {
      this.type = type;
      this.parameters = parameters;
    }
  }
});

// ../node_modules/archive-type/node_modules/file-type/index.js
var require_file_type = __commonJS({
  "../node_modules/archive-type/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i = 0; i < header.length; i++) {
          if (header[i] !== buf[i + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4]) && check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (check([80, 75, 3, 4]) && check([77, 69, 84, 65, 45, 73, 78, 70, 47, 109, 111, 122, 105, 108, 108, 97, 46, 114, 115, 97], { offset: 30 })) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([0, 0, 0]) && (buf[3] === 24 || buf[3] === 32) && check([102, 116, 121, 112], { offset: 4 }) || check([51, 103, 112, 53]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50]) && check([109, 112, 52, 49, 109, 112, 52, 50, 105, 115, 111, 109], { offset: 16 }) || check([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50, 0, 0, 0, 0])) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([0, 0, 0, 28, 102, 116, 121, 112, 77, 52, 86])) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos >= 0) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([73, 68, 51]) || check([255, 251])) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "application/font-woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "application/font-woff"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "application/font-sfnt"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "application/font-sfnt"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      return null;
    };
  }
});

// ../node_modules/archive-type/index.js
var require_archive_type = __commonJS({
  "../node_modules/archive-type/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type();
    var exts = new Set([
      "7z",
      "bz2",
      "gz",
      "rar",
      "tar",
      "zip",
      "xz",
      "gz"
    ]);
    module2.exports = (input) => {
      const ret = fileType2(input);
      return exts.has(ret && ret.ext) ? ret : null;
    };
  }
});

// ../node_modules/decompress-tar/node_modules/file-type/index.js
var require_file_type2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i = 0; i < header.length; i++) {
          if (header[i] !== buf[i + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4]) && check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (check([80, 75, 3, 4]) && check([77, 69, 84, 65, 45, 73, 78, 70, 47, 109, 111, 122, 105, 108, 108, 97, 46, 114, 115, 97], { offset: 30 })) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([0, 0, 0]) && (buf[3] === 24 || buf[3] === 32) && check([102, 116, 121, 112], { offset: 4 }) || check([51, 103, 112, 53]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50]) && check([109, 112, 52, 49, 109, 112, 52, 50, 105, 115, 111, 109], { offset: 16 }) || check([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50, 0, 0, 0, 0])) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([0, 0, 0, 28, 102, 116, 121, 112, 77, 52, 86])) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos >= 0) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([73, 68, 51]) || check([255, 251])) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      return null;
    };
  }
});

// ../node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "../node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// ../node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../node_modules/isarray/index.js"(exports2, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/core-util-is/lib/util.js
var require_util3 = __commonJS({
  "../node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream2();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy2();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream2, cb) {
      var er = new Error("write after end");
      stream2.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream2.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream2.emit("error", err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable2();
    var Writable = require_stream_writable2();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../node_modules/decompress-tar/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream2();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy2();
    var StringDecoder;
    util.inherits(Readable2, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex2();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder2().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex2();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream2.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream2.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            stream2.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream2.emit("data", chunk);
        stream2.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder2().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream2);
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream2);
        else
          emitReadable_(stream2);
      }
    }
    function emitReadable_(stream2) {
      debug("emit readable");
      stream2.emit("readable");
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream2.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var Duplex = require_stream_duplex2();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream2._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream2.push(null);
    }
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform2();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/readable.js
var require_readable2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable2();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable2();
      exports2.Duplex = require_stream_duplex2();
      exports2.Transform = require_stream_transform2();
      exports2.PassThrough = require_stream_passthrough2();
    }
  }
});

// ../node_modules/decompress-tar/node_modules/readable-stream/duplex.js
var require_duplex = __commonJS({
  "../node_modules/decompress-tar/node_modules/readable-stream/duplex.js"(exports2, module2) {
    module2.exports = require_readable2().Duplex;
  }
});

// ../node_modules/decompress-tar/node_modules/bl/bl.js
var require_bl = __commonJS({
  "../node_modules/decompress-tar/node_modules/bl/bl.js"(exports2, module2) {
    var DuplexStream = require_duplex();
    var util = require("util");
    var Buffer2 = require_safe_buffer2().Buffer;
    function BufferList(callback) {
      if (!(this instanceof BufferList))
        return new BufferList(callback);
      this._bufs = [];
      this.length = 0;
      if (typeof callback == "function") {
        this._callback = callback;
        var piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
      } else {
        this.append(callback);
      }
      DuplexStream.call(this);
    }
    util.inherits(BufferList, DuplexStream);
    BufferList.prototype._offset = function _offset(offset) {
      var tot = 0, i = 0, _t;
      if (offset === 0)
        return [0, 0];
      for (; i < this._bufs.length; i++) {
        _t = tot + this._bufs[i].length;
        if (offset < _t || i == this._bufs.length - 1)
          return [i, offset - tot];
        tot = _t;
      }
    };
    BufferList.prototype.append = function append(buf) {
      var i = 0;
      if (Buffer2.isBuffer(buf)) {
        this._appendBuffer(buf);
      } else if (Array.isArray(buf)) {
        for (; i < buf.length; i++)
          this.append(buf[i]);
      } else if (buf instanceof BufferList) {
        for (; i < buf._bufs.length; i++)
          this.append(buf._bufs[i]);
      } else if (buf != null) {
        if (typeof buf == "number")
          buf = buf.toString();
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback == "function")
        callback();
    };
    BufferList.prototype._read = function _read(size) {
      if (!this.length)
        return this.push(null);
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferList.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferList.prototype.get = function get(index) {
      return this.slice(index, index + 1)[0];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start == "number" && start < 0)
        start += this.length;
      if (typeof end == "number" && end < 0)
        end += this.length;
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart != "number" || srcStart < 0)
        srcStart = 0;
      if (typeof srcEnd != "number" || srcEnd > this.length)
        srcEnd = this.length;
      if (srcStart >= this.length)
        return dst || Buffer2.alloc(0);
      if (srcEnd <= 0)
        return dst || Buffer2.alloc(0);
      var copy2 = !!dst, off = this._offset(srcStart), len = srcEnd - srcStart, bytes = len, bufoff = copy2 && dstStart || 0, start = off[1], l, i;
      if (srcStart === 0 && srcEnd == this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2)
        dst = Buffer2.allocUnsafe(len);
      for (i = off[0]; i < this._bufs.length; i++) {
        l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start)
          start = 0;
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = end || this.length;
      if (start < 0)
        start += this.length;
      if (end < 0)
        end += this.length;
      var startOffset = this._offset(start), endOffset = this._offset(end), buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] == 0)
        buffers.pop();
      else
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      if (startOffset[1] != 0)
        buffers[0] = buffers[0].slice(startOffset[1]);
      return new BufferList(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      var i = 0, copy = new BufferList();
      for (; i < this._bufs.length; i++)
        copy.append(this._bufs[i]);
      return copy;
    };
    BufferList.prototype.destroy = function destroy() {
      this._bufs.length = 0;
      this.length = 0;
      this.push(null);
    };
    (function() {
      var methods = {
        "readDoubleBE": 8,
        "readDoubleLE": 8,
        "readFloatBE": 4,
        "readFloatLE": 4,
        "readInt32BE": 4,
        "readInt32LE": 4,
        "readUInt32BE": 4,
        "readUInt32LE": 4,
        "readInt16BE": 2,
        "readInt16LE": 2,
        "readUInt16BE": 2,
        "readUInt16LE": 2,
        "readInt8": 1,
        "readUInt8": 1
      };
      for (var m in methods) {
        (function(m2) {
          BufferList.prototype[m2] = function(offset) {
            return this.slice(offset, offset + methods[m2])[m2](0);
          };
        })(m);
      }
    })();
    module2.exports = BufferList;
  }
});

// ../node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "../node_modules/xtend/immutable.js"(exports2, module2) {
    module2.exports = extend;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// ../node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "../node_modules/to-buffer/index.js"(exports2, module2) {
    module2.exports = toBuffer;
    var makeBuffer = Buffer.from && Buffer.from !== Uint8Array.from ? Buffer.from : bufferFrom;
    function bufferFrom(buf, enc) {
      return new Buffer(buf, enc);
    }
    function toBuffer(buf, enc) {
      if (Buffer.isBuffer(buf))
        return buf;
      if (typeof buf === "string")
        return makeBuffer(buf, enc);
      if (Array.isArray(buf))
        return makeBuffer(buf);
      throw new Error("Input should be a buffer or a string");
    }
  }
});

// ../node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS({
  "../node_modules/buffer-fill/index.js"(exports2, module2) {
    var hasFullSupport = function() {
      try {
        if (!Buffer.isEncoding("latin1")) {
          return false;
        }
        var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
        buf.fill("ab", "ucs2");
        return buf.toString("hex") === "61006200";
      } catch (_2) {
        return false;
      }
    }();
    function isSingleByte(val) {
      return val.length === 1 && val.charCodeAt(0) < 256;
    }
    function fillWithNumber(buffer, val, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      if (end > start) {
        buffer.fill(val, start, end);
      }
      return buffer;
    }
    function fillWithBuffer(buffer, val, start, end) {
      if (start < 0 || end > buffer.length) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return buffer;
      }
      start = start >>> 0;
      end = end === void 0 ? buffer.length : end >>> 0;
      var pos = start;
      var len = val.length;
      while (pos <= end - len) {
        val.copy(buffer, pos);
        pos += len;
      }
      if (pos !== end) {
        val.copy(buffer, pos, 0, end - pos);
      }
      return buffer;
    }
    function fill(buffer, val, start, end, encoding) {
      if (hasFullSupport) {
        return buffer.fill(val, start, end, encoding);
      }
      if (typeof val === "number") {
        return fillWithNumber(buffer, val, start, end);
      }
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = buffer.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = buffer.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (encoding === "latin1") {
          encoding = "binary";
        }
        if (typeof encoding === "string" && !Buffer.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val === "") {
          return fillWithNumber(buffer, 0, start, end);
        }
        if (isSingleByte(val)) {
          return fillWithNumber(buffer, val.charCodeAt(0), start, end);
        }
        val = new Buffer(val, encoding);
      }
      if (Buffer.isBuffer(val)) {
        return fillWithBuffer(buffer, val, start, end);
      }
      return fillWithNumber(buffer, 0, start, end);
    }
    module2.exports = fill;
  }
});

// ../node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS({
  "../node_modules/buffer-alloc-unsafe/index.js"(exports2, module2) {
    function allocUnsafe(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.allocUnsafe) {
        return Buffer.allocUnsafe(size);
      } else {
        return new Buffer(size);
      }
    }
    module2.exports = allocUnsafe;
  }
});

// ../node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS({
  "../node_modules/buffer-alloc/index.js"(exports2, module2) {
    var bufferFill = require_buffer_fill();
    var allocUnsafe = require_buffer_alloc_unsafe();
    module2.exports = function alloc(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be a number');
      }
      if (size < 0) {
        throw new RangeError('"size" argument must not be negative');
      }
      if (Buffer.alloc) {
        return Buffer.alloc(size, fill, encoding);
      }
      var buffer = allocUnsafe(size);
      if (size === 0) {
        return buffer;
      }
      if (fill === void 0) {
        return bufferFill(buffer, 0);
      }
      if (typeof encoding !== "string") {
        encoding = void 0;
      }
      return bufferFill(buffer, fill, encoding);
    };
  }
});

// ../node_modules/decompress-tar/node_modules/tar-stream/headers.js
var require_headers2 = __commonJS({
  "../node_modules/decompress-tar/node_modules/tar-stream/headers.js"(exports2) {
    var toBuffer = require_to_buffer();
    var alloc = require_buffer_alloc();
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR = "ustar\x0000";
    var MASK = parseInt("7777", 8);
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      var sum = 8 * 32;
      for (var i = 0; i < 148; i++)
        sum += block[i];
      for (var j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    function parse256(buf) {
      var positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      var zero = false;
      var tuple = [];
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i];
        if (positive)
          tuple.push(byte);
        else if (zero && byte === 0)
          tuple.push(0);
        else if (zero) {
          zero = false;
          tuple.push(256 - byte);
        } else
          tuple.push(255 - byte);
      }
      var sum = 0;
      var l = tuple.length;
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length) {
      val = val.slice(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
    };
    var addLength = function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return toBuffer(result);
    };
    exports2.decodePax = function(buf) {
      var result = {};
      while (buf.length) {
        var i = 0;
        while (i < buf.length && buf[i] !== 32)
          i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len)
          return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result;
    };
    exports2.encode = function(opts) {
      var buf = alloc(512);
      var name = opts.name;
      var prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (Buffer.byteLength(name) !== name.length)
        return null;
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
        return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf.write(opts.linkname, 157);
      buf.write(USTAR, 257);
      if (opts.uname)
        buf.write(opts.uname, 265);
      if (opts.gname)
        buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf.write(prefix, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      if (buf[345])
        name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      var c = cksum(buf);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// ../node_modules/decompress-tar/node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "../node_modules/decompress-tar/node_modules/tar-stream/extract.js"(exports2, module2) {
    var util = require("util");
    var bl = require_bl();
    var xtend = require_immutable();
    var headers = require_headers2();
    var Writable = require_readable2().Writable;
    var PassThrough = require_readable2().PassThrough;
    var noop = function() {
    };
    var overflow = function(size) {
      size &= 511;
      return size && 512 - size;
    };
    var emptyStream = function(self2, offset) {
      var s = new Source(self2, offset);
      s.end();
      return s;
    };
    var mixinPax = function(header, pax) {
      if (pax.path)
        header.name = pax.path;
      if (pax.linkpath)
        header.linkname = pax.linkpath;
      if (pax.size)
        header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    };
    var Source = function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough.call(this);
    };
    util.inherits(Source, PassThrough);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = function(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Writable.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b = self2._buffer;
      var oncontinue = function() {
        self2._continue();
      };
      var onunlock = function(err) {
        self2._locked = false;
        if (err)
          return self2.destroy(err);
        if (!self2._stream)
          oncontinue();
      };
      var onstreamend = function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain)
          self2._parse(drain, ondrain);
        else
          self2._parse(512, onheader);
        if (!self2._locked)
          oncontinue();
      };
      var ondrain = function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      };
      var onpaxglobalheader = function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
      };
      var onpaxheader = function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b.slice(0, size));
        if (self2._paxGlobal)
          self2._pax = xtend(self2._paxGlobal, self2._pax);
        b.consume(size);
        onstreamend();
      };
      var ongnulongpath = function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var ongnulonglinkpath = function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var onheader = function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding);
        } catch (err) {
          self2.emit("error", err);
        }
        b.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      };
      this._onheader = onheader;
      this._parse(512, onheader);
    };
    util.inherits(Extract, Writable);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream)
        this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed)
        return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader)
        this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed)
        return;
      var cb = this._cb;
      this._cb = noop;
      if (this._overflow)
        this._write(this._overflow, void 0, cb);
      else
        cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed)
        return;
      var s = this._stream;
      var b = this._buffer;
      var missing = this._missing;
      if (data.length)
        this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s)
          return s.write(data, cb);
        b.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s)
        s.end(data);
      else
        b.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial)
        return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  }
});

// ../node_modules/fs-constants/index.js
var require_fs_constants = __commonJS({
  "../node_modules/fs-constants/index.js"(exports2, module2) {
    module2.exports = require("fs").constants || require("constants");
  }
});

// ../node_modules/decompress-tar/node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "../node_modules/decompress-tar/node_modules/tar-stream/pack.js"(exports2, module2) {
    var constants = require_fs_constants();
    var eos = require_end_of_stream2();
    var util = require("util");
    var alloc = require_buffer_alloc();
    var toBuffer = require_to_buffer();
    var Readable2 = require_readable2().Readable;
    var Writable = require_readable2().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var headers = require_headers2();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc(1024);
    var noop = function() {
    };
    var overflow = function(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.slice(0, 512 - size));
    };
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    var Sink = function(to) {
      Writable.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    };
    util.inherits(Sink, Writable);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data))
        return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = function() {
      Writable.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder("utf-8");
      this._destroyed = false;
    };
    util.inherits(LinkSink, Writable);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = function() {
      Writable.call(this);
      this._destroyed = false;
    };
    util.inherits(Void, Writable);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = function(opts) {
      if (!(this instanceof Pack))
        return new Pack(opts);
      Readable2.call(this, opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    };
    util.inherits(Pack, Readable2);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream)
        throw new Error("already piping an entry");
      if (this._finalized || this._destroyed)
        return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      var self2 = this;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = new Date();
      if (typeof buffer === "string")
        buffer = toBuffer(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        this.push(buffer);
        overflow(self2, header.size);
        process.nextTick(callback);
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing)
          self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy)
        this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n) {
      var drain = this._drain;
      this._drain = noop;
      drain();
    };
    module2.exports = Pack;
  }
});

// ../node_modules/decompress-tar/node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "../node_modules/decompress-tar/node_modules/tar-stream/index.js"(exports2) {
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// ../node_modules/decompress-tar/index.js
var require_decompress_tar = __commonJS({
  "../node_modules/decompress-tar/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type2();
    var isStream = require_is_stream();
    var tarStream = require_tar_stream();
    module2.exports = () => (input) => {
      if (!Buffer.isBuffer(input) && !isStream(input)) {
        return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
      }
      if (Buffer.isBuffer(input) && (!fileType2(input) || fileType2(input).ext !== "tar")) {
        return Promise.resolve([]);
      }
      const extract = tarStream.extract();
      const files = [];
      extract.on("entry", (header, stream2, cb) => {
        const chunk = [];
        stream2.on("data", (data) => chunk.push(data));
        stream2.on("end", () => {
          const file = {
            data: Buffer.concat(chunk),
            mode: header.mode,
            mtime: header.mtime,
            path: header.name,
            type: header.type
          };
          if (header.type === "symlink" || header.type === "link") {
            file.linkname = header.linkname;
          }
          files.push(file);
          cb();
        });
      });
      const promise = new Promise((resolve2, reject2) => {
        if (!Buffer.isBuffer(input)) {
          input.on("error", reject2);
        }
        extract.on("finish", () => resolve2(files));
        extract.on("error", reject2);
      });
      extract.then = promise.then.bind(promise);
      extract.catch = promise.catch.bind(promise);
      if (Buffer.isBuffer(input)) {
        extract.end(input);
      } else {
        input.pipe(extract);
      }
      return extract;
    };
  }
});

// ../node_modules/decompress-tarbz2/node_modules/file-type/index.js
var require_file_type3 = __commonJS({
  "../node_modules/decompress-tarbz2/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    var toBytes = (s) => Array.from(s).map((c) => c.charCodeAt(0));
    var xpiZipFilename2 = toBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes2 = toBytes("[Content_Types].xml");
    var oxmlRels2 = toBytes("_rels/.rels");
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i = 0; i < header.length; i++) {
          if (opts.mask) {
            if (header[i] !== (opts.mask[i] & buf[i + opts.offset])) {
              return false;
            }
          } else if (header[i] !== buf[i + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename2, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (check(oxmlContentTypes2, { offset: 30 }) || check(oxmlRels2, { offset: 30 })) {
          const sliced = buf.subarray(4, 4 + 2e3);
          const nextZipHeaderIndex = (arr) => arr.findIndex((el, i, arr2) => arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
          const header2Pos = nextZipHeaderIndex(sliced);
          if (header2Pos !== -1) {
            const slicedAgain = buf.subarray(header2Pos + 8, header2Pos + 8 + 1e3);
            const header3Pos = nextZipHeaderIndex(slicedAgain);
            if (header3Pos !== -1) {
              const offset = 8 + header2Pos + header3Pos + 30;
              if (check(toBytes("word/"), { offset })) {
                return {
                  ext: "docx",
                  mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                };
              }
              if (check(toBytes("ppt/"), { offset })) {
                return {
                  ext: "pptx",
                  mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                };
              }
              if (check(toBytes("xl/"), { offset })) {
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              }
            }
          }
        }
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([51, 103, 112, 53]) || check([0, 0, 0]) && check([102, 116, 121, 112], { offset: 4 }) && (check([109, 112, 52, 49], { offset: 8 }) || check([109, 112, 52, 50], { offset: 8 }) || check([105, 115, 111, 109], { offset: 8 }) || check([105, 115, 111, 50], { offset: 8 }) || check([109, 109, 112, 52], { offset: 8 }) || check([77, 52, 86], { offset: 8 }) || check([100, 97, 115, 104], { offset: 8 }))) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || check([255, 226], { offset: start, mask: [255, 226] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      return null;
    };
  }
});

// ../node_modules/seek-bzip/lib/bitreader.js
var require_bitreader = __commonJS({
  "../node_modules/seek-bzip/lib/bitreader.js"(exports2, module2) {
    var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    var BitReader = function(stream2) {
      this.stream = stream2;
      this.bitOffset = 0;
      this.curByte = 0;
      this.hasByte = false;
    };
    BitReader.prototype._ensureByte = function() {
      if (!this.hasByte) {
        this.curByte = this.stream.readByte();
        this.hasByte = true;
      }
    };
    BitReader.prototype.read = function(bits) {
      var result = 0;
      while (bits > 0) {
        this._ensureByte();
        var remaining = 8 - this.bitOffset;
        if (bits >= remaining) {
          result <<= remaining;
          result |= BITMASK[remaining] & this.curByte;
          this.hasByte = false;
          this.bitOffset = 0;
          bits -= remaining;
        } else {
          result <<= bits;
          var shift = remaining - bits;
          result |= (this.curByte & BITMASK[bits] << shift) >> shift;
          this.bitOffset += bits;
          bits = 0;
        }
      }
      return result;
    };
    BitReader.prototype.seek = function(pos) {
      var n_bit = pos % 8;
      var n_byte = (pos - n_bit) / 8;
      this.bitOffset = n_bit;
      this.stream.seek(n_byte);
      this.hasByte = false;
    };
    BitReader.prototype.pi = function() {
      var buf = new Buffer(6), i;
      for (i = 0; i < buf.length; i++) {
        buf[i] = this.read(8);
      }
      return buf.toString("hex");
    };
    module2.exports = BitReader;
  }
});

// ../node_modules/seek-bzip/lib/stream.js
var require_stream3 = __commonJS({
  "../node_modules/seek-bzip/lib/stream.js"(exports2, module2) {
    var Stream = function() {
    };
    Stream.prototype.readByte = function() {
      throw new Error("abstract method readByte() not implemented");
    };
    Stream.prototype.read = function(buffer, bufOffset, length) {
      var bytesRead = 0;
      while (bytesRead < length) {
        var c = this.readByte();
        if (c < 0) {
          return bytesRead === 0 ? -1 : bytesRead;
        }
        buffer[bufOffset++] = c;
        bytesRead++;
      }
      return bytesRead;
    };
    Stream.prototype.seek = function(new_pos) {
      throw new Error("abstract method seek() not implemented");
    };
    Stream.prototype.writeByte = function(_byte) {
      throw new Error("abstract method readByte() not implemented");
    };
    Stream.prototype.write = function(buffer, bufOffset, length) {
      var i;
      for (i = 0; i < length; i++) {
        this.writeByte(buffer[bufOffset++]);
      }
      return length;
    };
    Stream.prototype.flush = function() {
    };
    module2.exports = Stream;
  }
});

// ../node_modules/seek-bzip/lib/crc32.js
var require_crc32 = __commonJS({
  "../node_modules/seek-bzip/lib/crc32.js"(exports2, module2) {
    module2.exports = function() {
      var crc32Lookup = new Uint32Array([
        0,
        79764919,
        159529838,
        222504665,
        319059676,
        398814059,
        445009330,
        507990021,
        638119352,
        583659535,
        797628118,
        726387553,
        890018660,
        835552979,
        1015980042,
        944750013,
        1276238704,
        1221641927,
        1167319070,
        1095957929,
        1595256236,
        1540665371,
        1452775106,
        1381403509,
        1780037320,
        1859660671,
        1671105958,
        1733955601,
        2031960084,
        2111593891,
        1889500026,
        1952343757,
        2552477408,
        2632100695,
        2443283854,
        2506133561,
        2334638140,
        2414271883,
        2191915858,
        2254759653,
        3190512472,
        3135915759,
        3081330742,
        3009969537,
        2905550212,
        2850959411,
        2762807018,
        2691435357,
        3560074640,
        3505614887,
        3719321342,
        3648080713,
        3342211916,
        3287746299,
        3467911202,
        3396681109,
        4063920168,
        4143685023,
        4223187782,
        4286162673,
        3779000052,
        3858754371,
        3904687514,
        3967668269,
        881225847,
        809987520,
        1023691545,
        969234094,
        662832811,
        591600412,
        771767749,
        717299826,
        311336399,
        374308984,
        453813921,
        533576470,
        25881363,
        88864420,
        134795389,
        214552010,
        2023205639,
        2086057648,
        1897238633,
        1976864222,
        1804852699,
        1867694188,
        1645340341,
        1724971778,
        1587496639,
        1516133128,
        1461550545,
        1406951526,
        1302016099,
        1230646740,
        1142491917,
        1087903418,
        2896545431,
        2825181984,
        2770861561,
        2716262478,
        3215044683,
        3143675388,
        3055782693,
        3001194130,
        2326604591,
        2389456536,
        2200899649,
        2280525302,
        2578013683,
        2640855108,
        2418763421,
        2498394922,
        3769900519,
        3832873040,
        3912640137,
        3992402750,
        4088425275,
        4151408268,
        4197601365,
        4277358050,
        3334271071,
        3263032808,
        3476998961,
        3422541446,
        3585640067,
        3514407732,
        3694837229,
        3640369242,
        1762451694,
        1842216281,
        1619975040,
        1682949687,
        2047383090,
        2127137669,
        1938468188,
        2001449195,
        1325665622,
        1271206113,
        1183200824,
        1111960463,
        1543535498,
        1489069629,
        1434599652,
        1363369299,
        622672798,
        568075817,
        748617968,
        677256519,
        907627842,
        853037301,
        1067152940,
        995781531,
        51762726,
        131386257,
        177728840,
        240578815,
        269590778,
        349224269,
        429104020,
        491947555,
        4046411278,
        4126034873,
        4172115296,
        4234965207,
        3794477266,
        3874110821,
        3953728444,
        4016571915,
        3609705398,
        3555108353,
        3735388376,
        3664026991,
        3290680682,
        3236090077,
        3449943556,
        3378572211,
        3174993278,
        3120533705,
        3032266256,
        2961025959,
        2923101090,
        2868635157,
        2813903052,
        2742672763,
        2604032198,
        2683796849,
        2461293480,
        2524268063,
        2284983834,
        2364738477,
        2175806836,
        2238787779,
        1569362073,
        1498123566,
        1409854455,
        1355396672,
        1317987909,
        1246755826,
        1192025387,
        1137557660,
        2072149281,
        2135122070,
        1912620623,
        1992383480,
        1753615357,
        1816598090,
        1627664531,
        1707420964,
        295390185,
        358241886,
        404320391,
        483945776,
        43990325,
        106832002,
        186451547,
        266083308,
        932423249,
        861060070,
        1041341759,
        986742920,
        613929101,
        542559546,
        756411363,
        701822548,
        3316196985,
        3244833742,
        3425377559,
        3370778784,
        3601682597,
        3530312978,
        3744426955,
        3689838204,
        3819031489,
        3881883254,
        3928223919,
        4007849240,
        4037393693,
        4100235434,
        4180117107,
        4259748804,
        2310601993,
        2373574846,
        2151335527,
        2231098320,
        2596047829,
        2659030626,
        2470359227,
        2550115596,
        2947551409,
        2876312838,
        2788305887,
        2733848168,
        3165939309,
        3094707162,
        3040238851,
        2985771188
      ]);
      var CRC32 = function() {
        var crc = 4294967295;
        this.getCRC = function() {
          return ~crc >>> 0;
        };
        this.updateCRC = function(value) {
          crc = crc << 8 ^ crc32Lookup[(crc >>> 24 ^ value) & 255];
        };
        this.updateCRCRun = function(value, count) {
          while (count-- > 0) {
            crc = crc << 8 ^ crc32Lookup[(crc >>> 24 ^ value) & 255];
          }
        };
      };
      return CRC32;
    }();
  }
});

// ../node_modules/seek-bzip/package.json
var require_package3 = __commonJS({
  "../node_modules/seek-bzip/package.json"(exports2, module2) {
    module2.exports = {
      name: "seek-bzip",
      version: "1.0.6",
      contributors: [
        "C. Scott Ananian (http://cscott.net)",
        "Eli Skeggs",
        "Kevin Kwok",
        "Rob Landley (http://landley.net)"
      ],
      description: "a pure-JavaScript Node.JS module for random-access decoding bzip2 data",
      main: "./lib/index.js",
      repository: {
        type: "git",
        url: "https://github.com/cscott/seek-bzip.git"
      },
      license: "MIT",
      bin: {
        "seek-bunzip": "./bin/seek-bunzip",
        "seek-table": "./bin/seek-bzip-table"
      },
      directories: {
        test: "test"
      },
      dependencies: {
        commander: "^2.8.1"
      },
      devDependencies: {
        fibers: "~1.0.6",
        mocha: "~2.2.5"
      },
      scripts: {
        test: "mocha"
      }
    };
  }
});

// ../node_modules/seek-bzip/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/seek-bzip/lib/index.js"(exports2, module2) {
    var BitReader = require_bitreader();
    var Stream = require_stream3();
    var CRC32 = require_crc32();
    var pjson = require_package3();
    var MAX_HUFCODE_BITS = 20;
    var MAX_SYMBOLS = 258;
    var SYMBOL_RUNA = 0;
    var SYMBOL_RUNB = 1;
    var MIN_GROUPS = 2;
    var MAX_GROUPS = 6;
    var GROUP_SIZE = 50;
    var WHOLEPI = "314159265359";
    var SQRTPI = "177245385090";
    var mtf = function(array, index) {
      var src = array[index], i;
      for (i = index; i > 0; i--) {
        array[i] = array[i - 1];
      }
      array[0] = src;
      return src;
    };
    var Err = {
      OK: 0,
      LAST_BLOCK: -1,
      NOT_BZIP_DATA: -2,
      UNEXPECTED_INPUT_EOF: -3,
      UNEXPECTED_OUTPUT_EOF: -4,
      DATA_ERROR: -5,
      OUT_OF_MEMORY: -6,
      OBSOLETE_INPUT: -7,
      END_OF_BLOCK: -8
    };
    var ErrorMessages = {};
    ErrorMessages[Err.LAST_BLOCK] = "Bad file checksum";
    ErrorMessages[Err.NOT_BZIP_DATA] = "Not bzip data";
    ErrorMessages[Err.UNEXPECTED_INPUT_EOF] = "Unexpected input EOF";
    ErrorMessages[Err.UNEXPECTED_OUTPUT_EOF] = "Unexpected output EOF";
    ErrorMessages[Err.DATA_ERROR] = "Data error";
    ErrorMessages[Err.OUT_OF_MEMORY] = "Out of memory";
    ErrorMessages[Err.OBSOLETE_INPUT] = "Obsolete (pre 0.9.5) bzip format not supported.";
    var _throw = function(status, optDetail) {
      var msg = ErrorMessages[status] || "unknown error";
      if (optDetail) {
        msg += ": " + optDetail;
      }
      var e = new TypeError(msg);
      e.errorCode = status;
      throw e;
    };
    var Bunzip = function(inputStream, outputStream) {
      this.writePos = this.writeCurrent = this.writeCount = 0;
      this._start_bunzip(inputStream, outputStream);
    };
    Bunzip.prototype._init_block = function() {
      var moreBlocks = this._get_next_block();
      if (!moreBlocks) {
        this.writeCount = -1;
        return false;
      }
      this.blockCRC = new CRC32();
      return true;
    };
    Bunzip.prototype._start_bunzip = function(inputStream, outputStream) {
      var buf = new Buffer(4);
      if (inputStream.read(buf, 0, 4) !== 4 || String.fromCharCode(buf[0], buf[1], buf[2]) !== "BZh")
        _throw(Err.NOT_BZIP_DATA, "bad magic");
      var level = buf[3] - 48;
      if (level < 1 || level > 9)
        _throw(Err.NOT_BZIP_DATA, "level out of range");
      this.reader = new BitReader(inputStream);
      this.dbufSize = 1e5 * level;
      this.nextoutput = 0;
      this.outputStream = outputStream;
      this.streamCRC = 0;
    };
    Bunzip.prototype._get_next_block = function() {
      var i, j, k;
      var reader = this.reader;
      var h = reader.pi();
      if (h === SQRTPI) {
        return false;
      }
      if (h !== WHOLEPI)
        _throw(Err.NOT_BZIP_DATA);
      this.targetBlockCRC = reader.read(32) >>> 0;
      this.streamCRC = (this.targetBlockCRC ^ (this.streamCRC << 1 | this.streamCRC >>> 31)) >>> 0;
      if (reader.read(1))
        _throw(Err.OBSOLETE_INPUT);
      var origPointer = reader.read(24);
      if (origPointer > this.dbufSize)
        _throw(Err.DATA_ERROR, "initial position out of bounds");
      var t = reader.read(16);
      var symToByte = new Buffer(256), symTotal = 0;
      for (i = 0; i < 16; i++) {
        if (t & 1 << 15 - i) {
          var o = i * 16;
          k = reader.read(16);
          for (j = 0; j < 16; j++)
            if (k & 1 << 15 - j)
              symToByte[symTotal++] = o + j;
        }
      }
      var groupCount = reader.read(3);
      if (groupCount < MIN_GROUPS || groupCount > MAX_GROUPS)
        _throw(Err.DATA_ERROR);
      var nSelectors = reader.read(15);
      if (nSelectors === 0)
        _throw(Err.DATA_ERROR);
      var mtfSymbol = new Buffer(256);
      for (i = 0; i < groupCount; i++)
        mtfSymbol[i] = i;
      var selectors = new Buffer(nSelectors);
      for (i = 0; i < nSelectors; i++) {
        for (j = 0; reader.read(1); j++)
          if (j >= groupCount)
            _throw(Err.DATA_ERROR);
        selectors[i] = mtf(mtfSymbol, j);
      }
      var symCount = symTotal + 2;
      var groups = [], hufGroup;
      for (j = 0; j < groupCount; j++) {
        var length = new Buffer(symCount), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
        t = reader.read(5);
        for (i = 0; i < symCount; i++) {
          for (; ; ) {
            if (t < 1 || t > MAX_HUFCODE_BITS)
              _throw(Err.DATA_ERROR);
            if (!reader.read(1))
              break;
            if (!reader.read(1))
              t++;
            else
              t--;
          }
          length[i] = t;
        }
        var minLen, maxLen;
        minLen = maxLen = length[0];
        for (i = 1; i < symCount; i++) {
          if (length[i] > maxLen)
            maxLen = length[i];
          else if (length[i] < minLen)
            minLen = length[i];
        }
        hufGroup = {};
        groups.push(hufGroup);
        hufGroup.permute = new Uint16Array(MAX_SYMBOLS);
        hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 2);
        hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var pp = 0;
        for (i = minLen; i <= maxLen; i++) {
          temp[i] = hufGroup.limit[i] = 0;
          for (t = 0; t < symCount; t++)
            if (length[t] === i)
              hufGroup.permute[pp++] = t;
        }
        for (i = 0; i < symCount; i++)
          temp[length[i]]++;
        pp = t = 0;
        for (i = minLen; i < maxLen; i++) {
          pp += temp[i];
          hufGroup.limit[i] = pp - 1;
          pp <<= 1;
          t += temp[i];
          hufGroup.base[i + 1] = pp - t;
        }
        hufGroup.limit[maxLen + 1] = Number.MAX_VALUE;
        hufGroup.limit[maxLen] = pp + temp[maxLen] - 1;
        hufGroup.base[minLen] = 0;
      }
      var byteCount = new Uint32Array(256);
      for (i = 0; i < 256; i++)
        mtfSymbol[i] = i;
      var runPos = 0, dbufCount = 0, selector = 0, uc;
      var dbuf = this.dbuf = new Uint32Array(this.dbufSize);
      symCount = 0;
      for (; ; ) {
        if (!symCount--) {
          symCount = GROUP_SIZE - 1;
          if (selector >= nSelectors) {
            _throw(Err.DATA_ERROR);
          }
          hufGroup = groups[selectors[selector++]];
        }
        i = hufGroup.minLen;
        j = reader.read(i);
        for (; ; i++) {
          if (i > hufGroup.maxLen) {
            _throw(Err.DATA_ERROR);
          }
          if (j <= hufGroup.limit[i])
            break;
          j = j << 1 | reader.read(1);
        }
        j -= hufGroup.base[i];
        if (j < 0 || j >= MAX_SYMBOLS) {
          _throw(Err.DATA_ERROR);
        }
        var nextSym = hufGroup.permute[j];
        if (nextSym === SYMBOL_RUNA || nextSym === SYMBOL_RUNB) {
          if (!runPos) {
            runPos = 1;
            t = 0;
          }
          if (nextSym === SYMBOL_RUNA)
            t += runPos;
          else
            t += 2 * runPos;
          runPos <<= 1;
          continue;
        }
        if (runPos) {
          runPos = 0;
          if (dbufCount + t > this.dbufSize) {
            _throw(Err.DATA_ERROR);
          }
          uc = symToByte[mtfSymbol[0]];
          byteCount[uc] += t;
          while (t--)
            dbuf[dbufCount++] = uc;
        }
        if (nextSym > symTotal)
          break;
        if (dbufCount >= this.dbufSize) {
          _throw(Err.DATA_ERROR);
        }
        i = nextSym - 1;
        uc = mtf(mtfSymbol, i);
        uc = symToByte[uc];
        byteCount[uc]++;
        dbuf[dbufCount++] = uc;
      }
      if (origPointer < 0 || origPointer >= dbufCount) {
        _throw(Err.DATA_ERROR);
      }
      j = 0;
      for (i = 0; i < 256; i++) {
        k = j + byteCount[i];
        byteCount[i] = j;
        j = k;
      }
      for (i = 0; i < dbufCount; i++) {
        uc = dbuf[i] & 255;
        dbuf[byteCount[uc]] |= i << 8;
        byteCount[uc]++;
      }
      var pos = 0, current = 0, run = 0;
      if (dbufCount) {
        pos = dbuf[origPointer];
        current = pos & 255;
        pos >>= 8;
        run = -1;
      }
      this.writePos = pos;
      this.writeCurrent = current;
      this.writeCount = dbufCount;
      this.writeRun = run;
      return true;
    };
    Bunzip.prototype._read_bunzip = function(outputBuffer, len) {
      var copies, previous, outbyte;
      if (this.writeCount < 0) {
        return 0;
      }
      var gotcount = 0;
      var dbuf = this.dbuf, pos = this.writePos, current = this.writeCurrent;
      var dbufCount = this.writeCount, outputsize = this.outputsize;
      var run = this.writeRun;
      while (dbufCount) {
        dbufCount--;
        previous = current;
        pos = dbuf[pos];
        current = pos & 255;
        pos >>= 8;
        if (run++ === 3) {
          copies = current;
          outbyte = previous;
          current = -1;
        } else {
          copies = 1;
          outbyte = current;
        }
        this.blockCRC.updateCRCRun(outbyte, copies);
        while (copies--) {
          this.outputStream.writeByte(outbyte);
          this.nextoutput++;
        }
        if (current != previous)
          run = 0;
      }
      this.writeCount = dbufCount;
      if (this.blockCRC.getCRC() !== this.targetBlockCRC) {
        _throw(Err.DATA_ERROR, "Bad block CRC (got " + this.blockCRC.getCRC().toString(16) + " expected " + this.targetBlockCRC.toString(16) + ")");
      }
      return this.nextoutput;
    };
    var coerceInputStream = function(input) {
      if ("readByte" in input) {
        return input;
      }
      var inputStream = new Stream();
      inputStream.pos = 0;
      inputStream.readByte = function() {
        return input[this.pos++];
      };
      inputStream.seek = function(pos) {
        this.pos = pos;
      };
      inputStream.eof = function() {
        return this.pos >= input.length;
      };
      return inputStream;
    };
    var coerceOutputStream = function(output) {
      var outputStream = new Stream();
      var resizeOk = true;
      if (output) {
        if (typeof output === "number") {
          outputStream.buffer = new Buffer(output);
          resizeOk = false;
        } else if ("writeByte" in output) {
          return output;
        } else {
          outputStream.buffer = output;
          resizeOk = false;
        }
      } else {
        outputStream.buffer = new Buffer(16384);
      }
      outputStream.pos = 0;
      outputStream.writeByte = function(_byte) {
        if (resizeOk && this.pos >= this.buffer.length) {
          var newBuffer = new Buffer(this.buffer.length * 2);
          this.buffer.copy(newBuffer);
          this.buffer = newBuffer;
        }
        this.buffer[this.pos++] = _byte;
      };
      outputStream.getBuffer = function() {
        if (this.pos !== this.buffer.length) {
          if (!resizeOk)
            throw new TypeError("outputsize does not match decoded input");
          var newBuffer = new Buffer(this.pos);
          this.buffer.copy(newBuffer, 0, 0, this.pos);
          this.buffer = newBuffer;
        }
        return this.buffer;
      };
      outputStream._coerced = true;
      return outputStream;
    };
    Bunzip.Err = Err;
    Bunzip.decode = function(input, output, multistream) {
      var inputStream = coerceInputStream(input);
      var outputStream = coerceOutputStream(output);
      var bz = new Bunzip(inputStream, outputStream);
      while (true) {
        if ("eof" in inputStream && inputStream.eof())
          break;
        if (bz._init_block()) {
          bz._read_bunzip();
        } else {
          var targetStreamCRC = bz.reader.read(32) >>> 0;
          if (targetStreamCRC !== bz.streamCRC) {
            _throw(Err.DATA_ERROR, "Bad stream CRC (got " + bz.streamCRC.toString(16) + " expected " + targetStreamCRC.toString(16) + ")");
          }
          if (multistream && "eof" in inputStream && !inputStream.eof()) {
            bz._start_bunzip(inputStream, outputStream);
          } else
            break;
        }
      }
      if ("getBuffer" in outputStream)
        return outputStream.getBuffer();
    };
    Bunzip.decodeBlock = function(input, pos, output) {
      var inputStream = coerceInputStream(input);
      var outputStream = coerceOutputStream(output);
      var bz = new Bunzip(inputStream, outputStream);
      bz.reader.seek(pos);
      var moreBlocks = bz._get_next_block();
      if (moreBlocks) {
        bz.blockCRC = new CRC32();
        bz.writeCopies = 0;
        bz._read_bunzip();
      }
      if ("getBuffer" in outputStream)
        return outputStream.getBuffer();
    };
    Bunzip.table = function(input, callback, multistream) {
      var inputStream = new Stream();
      inputStream.delegate = coerceInputStream(input);
      inputStream.pos = 0;
      inputStream.readByte = function() {
        this.pos++;
        return this.delegate.readByte();
      };
      if (inputStream.delegate.eof) {
        inputStream.eof = inputStream.delegate.eof.bind(inputStream.delegate);
      }
      var outputStream = new Stream();
      outputStream.pos = 0;
      outputStream.writeByte = function() {
        this.pos++;
      };
      var bz = new Bunzip(inputStream, outputStream);
      var blockSize = bz.dbufSize;
      while (true) {
        if ("eof" in inputStream && inputStream.eof())
          break;
        var position = inputStream.pos * 8 + bz.reader.bitOffset;
        if (bz.reader.hasByte) {
          position -= 8;
        }
        if (bz._init_block()) {
          var start = outputStream.pos;
          bz._read_bunzip();
          callback(position, outputStream.pos - start);
        } else {
          var crc = bz.reader.read(32);
          if (multistream && "eof" in inputStream && !inputStream.eof()) {
            bz._start_bunzip(inputStream, outputStream);
            console.assert(bz.dbufSize === blockSize, "shouldn't change block size within multistream file");
          } else
            break;
        }
      }
    };
    Bunzip.Stream = Stream;
    Bunzip.version = pjson.version;
    Bunzip.license = pjson.license;
    module2.exports = Bunzip;
  }
});

// ../node_modules/through/index.js
var require_through = __commonJS({
  "../node_modules/through/index.js"(exports2, module2) {
    var Stream = require("stream");
    exports2 = module2.exports = through;
    through.through = through;
    function through(write, end, opts) {
      write = write || function(data) {
        this.queue(data);
      };
      end = end || function() {
        this.queue(null);
      };
      var ended = false, destroyed = false, buffer = [], _ended = false;
      var stream2 = new Stream();
      stream2.readable = stream2.writable = true;
      stream2.paused = false;
      stream2.autoDestroy = !(opts && opts.autoDestroy === false);
      stream2.write = function(data) {
        write.call(this, data);
        return !stream2.paused;
      };
      function drain() {
        while (buffer.length && !stream2.paused) {
          var data = buffer.shift();
          if (data === null)
            return stream2.emit("end");
          else
            stream2.emit("data", data);
        }
      }
      stream2.queue = stream2.push = function(data) {
        if (_ended)
          return stream2;
        if (data === null)
          _ended = true;
        buffer.push(data);
        drain();
        return stream2;
      };
      stream2.on("end", function() {
        stream2.readable = false;
        if (!stream2.writable && stream2.autoDestroy)
          process.nextTick(function() {
            stream2.destroy();
          });
      });
      function _end() {
        stream2.writable = false;
        end.call(stream2);
        if (!stream2.readable && stream2.autoDestroy)
          stream2.destroy();
      }
      stream2.end = function(data) {
        if (ended)
          return;
        ended = true;
        if (arguments.length)
          stream2.write(data);
        _end();
        return stream2;
      };
      stream2.destroy = function() {
        if (destroyed)
          return;
        destroyed = true;
        ended = true;
        buffer.length = 0;
        stream2.writable = stream2.readable = false;
        stream2.emit("close");
        return stream2;
      };
      stream2.pause = function() {
        if (stream2.paused)
          return;
        stream2.paused = true;
        return stream2;
      };
      stream2.resume = function() {
        if (stream2.paused) {
          stream2.paused = false;
          stream2.emit("resume");
        }
        drain();
        if (!stream2.paused)
          stream2.emit("drain");
        return stream2;
      };
      return stream2;
    }
  }
});

// ../node_modules/unbzip2-stream/lib/bzip2.js
var require_bzip2 = __commonJS({
  "../node_modules/unbzip2-stream/lib/bzip2.js"(exports2, module2) {
    function Bzip2Error(message2) {
      this.name = "Bzip2Error";
      this.message = message2;
      this.stack = new Error().stack;
    }
    Bzip2Error.prototype = new Error();
    var message = {
      Error: function(message2) {
        throw new Bzip2Error(message2);
      }
    };
    var bzip2 = {};
    bzip2.Bzip2Error = Bzip2Error;
    bzip2.crcTable = [
      0,
      79764919,
      159529838,
      222504665,
      319059676,
      398814059,
      445009330,
      507990021,
      638119352,
      583659535,
      797628118,
      726387553,
      890018660,
      835552979,
      1015980042,
      944750013,
      1276238704,
      1221641927,
      1167319070,
      1095957929,
      1595256236,
      1540665371,
      1452775106,
      1381403509,
      1780037320,
      1859660671,
      1671105958,
      1733955601,
      2031960084,
      2111593891,
      1889500026,
      1952343757,
      2552477408,
      2632100695,
      2443283854,
      2506133561,
      2334638140,
      2414271883,
      2191915858,
      2254759653,
      3190512472,
      3135915759,
      3081330742,
      3009969537,
      2905550212,
      2850959411,
      2762807018,
      2691435357,
      3560074640,
      3505614887,
      3719321342,
      3648080713,
      3342211916,
      3287746299,
      3467911202,
      3396681109,
      4063920168,
      4143685023,
      4223187782,
      4286162673,
      3779000052,
      3858754371,
      3904687514,
      3967668269,
      881225847,
      809987520,
      1023691545,
      969234094,
      662832811,
      591600412,
      771767749,
      717299826,
      311336399,
      374308984,
      453813921,
      533576470,
      25881363,
      88864420,
      134795389,
      214552010,
      2023205639,
      2086057648,
      1897238633,
      1976864222,
      1804852699,
      1867694188,
      1645340341,
      1724971778,
      1587496639,
      1516133128,
      1461550545,
      1406951526,
      1302016099,
      1230646740,
      1142491917,
      1087903418,
      2896545431,
      2825181984,
      2770861561,
      2716262478,
      3215044683,
      3143675388,
      3055782693,
      3001194130,
      2326604591,
      2389456536,
      2200899649,
      2280525302,
      2578013683,
      2640855108,
      2418763421,
      2498394922,
      3769900519,
      3832873040,
      3912640137,
      3992402750,
      4088425275,
      4151408268,
      4197601365,
      4277358050,
      3334271071,
      3263032808,
      3476998961,
      3422541446,
      3585640067,
      3514407732,
      3694837229,
      3640369242,
      1762451694,
      1842216281,
      1619975040,
      1682949687,
      2047383090,
      2127137669,
      1938468188,
      2001449195,
      1325665622,
      1271206113,
      1183200824,
      1111960463,
      1543535498,
      1489069629,
      1434599652,
      1363369299,
      622672798,
      568075817,
      748617968,
      677256519,
      907627842,
      853037301,
      1067152940,
      995781531,
      51762726,
      131386257,
      177728840,
      240578815,
      269590778,
      349224269,
      429104020,
      491947555,
      4046411278,
      4126034873,
      4172115296,
      4234965207,
      3794477266,
      3874110821,
      3953728444,
      4016571915,
      3609705398,
      3555108353,
      3735388376,
      3664026991,
      3290680682,
      3236090077,
      3449943556,
      3378572211,
      3174993278,
      3120533705,
      3032266256,
      2961025959,
      2923101090,
      2868635157,
      2813903052,
      2742672763,
      2604032198,
      2683796849,
      2461293480,
      2524268063,
      2284983834,
      2364738477,
      2175806836,
      2238787779,
      1569362073,
      1498123566,
      1409854455,
      1355396672,
      1317987909,
      1246755826,
      1192025387,
      1137557660,
      2072149281,
      2135122070,
      1912620623,
      1992383480,
      1753615357,
      1816598090,
      1627664531,
      1707420964,
      295390185,
      358241886,
      404320391,
      483945776,
      43990325,
      106832002,
      186451547,
      266083308,
      932423249,
      861060070,
      1041341759,
      986742920,
      613929101,
      542559546,
      756411363,
      701822548,
      3316196985,
      3244833742,
      3425377559,
      3370778784,
      3601682597,
      3530312978,
      3744426955,
      3689838204,
      3819031489,
      3881883254,
      3928223919,
      4007849240,
      4037393693,
      4100235434,
      4180117107,
      4259748804,
      2310601993,
      2373574846,
      2151335527,
      2231098320,
      2596047829,
      2659030626,
      2470359227,
      2550115596,
      2947551409,
      2876312838,
      2788305887,
      2733848168,
      3165939309,
      3094707162,
      3040238851,
      2985771188
    ];
    bzip2.array = function(bytes) {
      var bit = 0, byte = 0;
      var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
      return function(n) {
        var result = 0;
        while (n > 0) {
          var left = 8 - bit;
          if (n >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n -= left;
          } else {
            result <<= n;
            result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
            bit += n;
            n = 0;
          }
        }
        return result;
      };
    };
    bzip2.simple = function(srcbuffer, stream2) {
      var bits = bzip2.array(srcbuffer);
      var size = bzip2.header(bits);
      var ret = false;
      var bufsize = 1e5 * size;
      var buf = new Int32Array(bufsize);
      do {
        ret = bzip2.decompress(bits, stream2, buf, bufsize);
      } while (!ret);
    };
    bzip2.header = function(bits) {
      this.byteCount = new Int32Array(256);
      this.symToByte = new Uint8Array(256);
      this.mtfSymbol = new Int32Array(256);
      this.selectors = new Uint8Array(32768);
      if (bits(8 * 3) != 4348520)
        message.Error("No magic number found");
      var i = bits(8) - 48;
      if (i < 1 || i > 9)
        message.Error("Not a BZIP archive");
      return i;
    };
    bzip2.decompress = function(bits, stream2, buf, bufsize, streamCRC) {
      var MAX_HUFCODE_BITS = 20;
      var MAX_SYMBOLS = 258;
      var SYMBOL_RUNA = 0;
      var SYMBOL_RUNB = 1;
      var GROUP_SIZE = 50;
      var crc = 0 ^ -1;
      for (var h = "", i = 0; i < 6; i++)
        h += bits(8).toString(16);
      if (h == "177245385090") {
        var finalCRC = bits(32) | 0;
        if (finalCRC !== streamCRC)
          message.Error("Error in bzip2: crc32 do not match");
        bits(null);
        return null;
      }
      if (h != "314159265359")
        message.Error("eek not valid bzip data");
      var crcblock = bits(32) | 0;
      if (bits(1))
        message.Error("unsupported obsolete version");
      var origPtr = bits(24);
      if (origPtr > bufsize)
        message.Error("Initial position larger than buffer size");
      var t = bits(16);
      var symTotal = 0;
      for (i = 0; i < 16; i++) {
        if (t & 1 << 15 - i) {
          var k = bits(16);
          for (j = 0; j < 16; j++) {
            if (k & 1 << 15 - j) {
              this.symToByte[symTotal++] = 16 * i + j;
            }
          }
        }
      }
      var groupCount = bits(3);
      if (groupCount < 2 || groupCount > 6)
        message.Error("another error");
      var nSelectors = bits(15);
      if (nSelectors == 0)
        message.Error("meh");
      for (var i = 0; i < groupCount; i++)
        this.mtfSymbol[i] = i;
      for (var i = 0; i < nSelectors; i++) {
        for (var j = 0; bits(1); j++)
          if (j >= groupCount)
            message.Error("whoops another error");
        var uc = this.mtfSymbol[j];
        for (var k = j - 1; k >= 0; k--) {
          this.mtfSymbol[k + 1] = this.mtfSymbol[k];
        }
        this.mtfSymbol[0] = uc;
        this.selectors[i] = uc;
      }
      var symCount = symTotal + 2;
      var groups = [];
      var length = new Uint8Array(MAX_SYMBOLS), temp = new Uint16Array(MAX_HUFCODE_BITS + 1);
      var hufGroup;
      for (var j = 0; j < groupCount; j++) {
        t = bits(5);
        for (var i = 0; i < symCount; i++) {
          while (true) {
            if (t < 1 || t > MAX_HUFCODE_BITS)
              message.Error("I gave up a while ago on writing error messages");
            if (!bits(1))
              break;
            if (!bits(1))
              t++;
            else
              t--;
          }
          length[i] = t;
        }
        var minLen, maxLen;
        minLen = maxLen = length[0];
        for (var i = 1; i < symCount; i++) {
          if (length[i] > maxLen)
            maxLen = length[i];
          else if (length[i] < minLen)
            minLen = length[i];
        }
        hufGroup = groups[j] = {};
        hufGroup.permute = new Int32Array(MAX_SYMBOLS);
        hufGroup.limit = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.base = new Int32Array(MAX_HUFCODE_BITS + 1);
        hufGroup.minLen = minLen;
        hufGroup.maxLen = maxLen;
        var base = hufGroup.base;
        var limit = hufGroup.limit;
        var pp = 0;
        for (var i = minLen; i <= maxLen; i++)
          for (var t = 0; t < symCount; t++)
            if (length[t] == i)
              hufGroup.permute[pp++] = t;
        for (i = minLen; i <= maxLen; i++)
          temp[i] = limit[i] = 0;
        for (i = 0; i < symCount; i++)
          temp[length[i]]++;
        pp = t = 0;
        for (i = minLen; i < maxLen; i++) {
          pp += temp[i];
          limit[i] = pp - 1;
          pp <<= 1;
          base[i + 1] = pp - (t += temp[i]);
        }
        limit[maxLen] = pp + temp[maxLen] - 1;
        base[minLen] = 0;
      }
      for (var i = 0; i < 256; i++) {
        this.mtfSymbol[i] = i;
        this.byteCount[i] = 0;
      }
      var runPos, count, symCount, selector;
      runPos = count = symCount = selector = 0;
      while (true) {
        if (!symCount--) {
          symCount = GROUP_SIZE - 1;
          if (selector >= nSelectors)
            message.Error("meow i'm a kitty, that's an error");
          hufGroup = groups[this.selectors[selector++]];
          base = hufGroup.base;
          limit = hufGroup.limit;
        }
        i = hufGroup.minLen;
        j = bits(i);
        while (true) {
          if (i > hufGroup.maxLen)
            message.Error("rawr i'm a dinosaur");
          if (j <= limit[i])
            break;
          i++;
          j = j << 1 | bits(1);
        }
        j -= base[i];
        if (j < 0 || j >= MAX_SYMBOLS)
          message.Error("moo i'm a cow");
        var nextSym = hufGroup.permute[j];
        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {
          if (!runPos) {
            runPos = 1;
            t = 0;
          }
          if (nextSym == SYMBOL_RUNA)
            t += runPos;
          else
            t += 2 * runPos;
          runPos <<= 1;
          continue;
        }
        if (runPos) {
          runPos = 0;
          if (count + t > bufsize)
            message.Error("Boom.");
          uc = this.symToByte[this.mtfSymbol[0]];
          this.byteCount[uc] += t;
          while (t--)
            buf[count++] = uc;
        }
        if (nextSym > symTotal)
          break;
        if (count >= bufsize)
          message.Error("I can't think of anything. Error");
        i = nextSym - 1;
        uc = this.mtfSymbol[i];
        for (var k = i - 1; k >= 0; k--) {
          this.mtfSymbol[k + 1] = this.mtfSymbol[k];
        }
        this.mtfSymbol[0] = uc;
        uc = this.symToByte[uc];
        this.byteCount[uc]++;
        buf[count++] = uc;
      }
      if (origPtr < 0 || origPtr >= count)
        message.Error("I'm a monkey and I'm throwing something at someone, namely you");
      var j = 0;
      for (var i = 0; i < 256; i++) {
        k = j + this.byteCount[i];
        this.byteCount[i] = j;
        j = k;
      }
      for (var i = 0; i < count; i++) {
        uc = buf[i] & 255;
        buf[this.byteCount[uc]] |= i << 8;
        this.byteCount[uc]++;
      }
      var pos = 0, current = 0, run = 0;
      if (count) {
        pos = buf[origPtr];
        current = pos & 255;
        pos >>= 8;
        run = -1;
      }
      count = count;
      var copies, previous, outbyte;
      while (count) {
        count--;
        previous = current;
        pos = buf[pos];
        current = pos & 255;
        pos >>= 8;
        if (run++ == 3) {
          copies = current;
          outbyte = previous;
          current = -1;
        } else {
          copies = 1;
          outbyte = current;
        }
        while (copies--) {
          crc = (crc << 8 ^ this.crcTable[(crc >> 24 ^ outbyte) & 255]) & 4294967295;
          stream2(outbyte);
        }
        if (current != previous)
          run = 0;
      }
      crc = (crc ^ -1) >>> 0;
      if ((crc | 0) != (crcblock | 0))
        message.Error("Error in bzip2: crc32 do not match");
      streamCRC = (crc ^ (streamCRC << 1 | streamCRC >>> 31)) & 4294967295;
      return streamCRC;
    };
    module2.exports = bzip2;
  }
});

// ../node_modules/unbzip2-stream/lib/bit_iterator.js
var require_bit_iterator = __commonJS({
  "../node_modules/unbzip2-stream/lib/bit_iterator.js"(exports2, module2) {
    var BITMASK = [0, 1, 3, 7, 15, 31, 63, 127, 255];
    module2.exports = function bitIterator(nextBuffer) {
      var bit = 0, byte = 0;
      var bytes = nextBuffer();
      var f = function(n) {
        if (n === null && bit != 0) {
          bit = 0;
          byte++;
          return;
        }
        var result = 0;
        while (n > 0) {
          if (byte >= bytes.length) {
            byte = 0;
            bytes = nextBuffer();
          }
          var left = 8 - bit;
          if (bit === 0 && n > 0)
            f.bytesRead++;
          if (n >= left) {
            result <<= left;
            result |= BITMASK[left] & bytes[byte++];
            bit = 0;
            n -= left;
          } else {
            result <<= n;
            result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;
            bit += n;
            n = 0;
          }
        }
        return result;
      };
      f.bytesRead = 0;
      return f;
    };
  }
});

// ../node_modules/unbzip2-stream/index.js
var require_unbzip2_stream = __commonJS({
  "../node_modules/unbzip2-stream/index.js"(exports2, module2) {
    var through = require_through();
    var bz2 = require_bzip2();
    var bitIterator = require_bit_iterator();
    module2.exports = unbzip2Stream;
    function unbzip2Stream() {
      var bufferQueue = [];
      var hasBytes = 0;
      var blockSize = 0;
      var broken = false;
      var done = false;
      var bitReader = null;
      var streamCRC = null;
      function decompressBlock(push) {
        if (!blockSize) {
          blockSize = bz2.header(bitReader);
          streamCRC = 0;
          return true;
        } else {
          var bufsize = 1e5 * blockSize;
          var buf = new Int32Array(bufsize);
          var chunk = [];
          var f = function(b) {
            chunk.push(b);
          };
          streamCRC = bz2.decompress(bitReader, f, buf, bufsize, streamCRC);
          if (streamCRC === null) {
            blockSize = 0;
            return false;
          } else {
            push(Buffer.from(chunk));
            return true;
          }
        }
      }
      var outlength = 0;
      function decompressAndQueue(stream2) {
        if (broken)
          return;
        try {
          return decompressBlock(function(d) {
            stream2.queue(d);
            if (d !== null) {
              outlength += d.length;
            } else {
            }
          });
        } catch (e) {
          stream2.emit("error", e);
          broken = true;
          return false;
        }
      }
      return through(function write(data) {
        bufferQueue.push(data);
        hasBytes += data.length;
        if (bitReader === null) {
          bitReader = bitIterator(function() {
            return bufferQueue.shift();
          });
        }
        while (!broken && hasBytes - bitReader.bytesRead + 1 >= (25e3 + 1e5 * blockSize || 4)) {
          decompressAndQueue(this);
        }
      }, function end(x) {
        while (!broken && bitReader && hasBytes > bitReader.bytesRead) {
          decompressAndQueue(this);
        }
        if (!broken) {
          if (streamCRC !== null)
            this.emit("error", new Error("input stream ended prematurely"));
          this.queue(null);
        }
      });
    }
  }
});

// ../node_modules/decompress-tarbz2/index.js
var require_decompress_tarbz2 = __commonJS({
  "../node_modules/decompress-tarbz2/index.js"(exports2, module2) {
    "use strict";
    var decompressTar = require_decompress_tar();
    var fileType2 = require_file_type3();
    var isStream = require_is_stream();
    var seekBzip = require_lib2();
    var unbzip2Stream = require_unbzip2_stream();
    module2.exports = () => (input) => {
      if (!Buffer.isBuffer(input) && !isStream(input)) {
        return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
      }
      if (Buffer.isBuffer(input) && (!fileType2(input) || fileType2(input).ext !== "bz2")) {
        return Promise.resolve([]);
      }
      if (Buffer.isBuffer(input)) {
        return decompressTar()(seekBzip.decode(input));
      }
      return decompressTar()(input.pipe(unbzip2Stream()));
    };
  }
});

// ../node_modules/decompress-targz/node_modules/file-type/index.js
var require_file_type4 = __commonJS({
  "../node_modules/decompress-targz/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (input) => {
      const buf = new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, opts) => {
        opts = Object.assign({
          offset: 0
        }, opts);
        for (let i = 0; i < header.length; i++) {
          if (header[i] !== buf[i + opts.offset]) {
            return false;
          }
        }
        return true;
      };
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4]) && check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (check([80, 75, 3, 4]) && check([77, 69, 84, 65, 45, 73, 78, 70, 47, 109, 111, 122, 105, 108, 108, 97, 46, 114, 115, 97], { offset: 30 })) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([0, 0, 0]) && (buf[3] === 24 || buf[3] === 32) && check([102, 116, 121, 112], { offset: 4 }) || check([51, 103, 112, 53]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50]) && check([109, 112, 52, 49, 109, 112, 52, 50, 105, 115, 111, 109], { offset: 16 }) || check([0, 0, 0, 28, 102, 116, 121, 112, 105, 115, 111, 109]) || check([0, 0, 0, 28, 102, 116, 121, 112, 109, 112, 52, 50, 0, 0, 0, 0])) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([0, 0, 0, 28, 102, 116, 121, 112, 77, 52, 86])) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos >= 0) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => Array.from(type).every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70]) && check([65, 86, 73], { offset: 8 })) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([73, 68, 51]) || check([255, 251])) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([82, 73, 70, 70]) && check([87, 65, 86, 69], { offset: 8 })) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      return null;
    };
  }
});

// ../node_modules/decompress-targz/index.js
var require_decompress_targz = __commonJS({
  "../node_modules/decompress-targz/index.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var decompressTar = require_decompress_tar();
    var fileType2 = require_file_type4();
    var isStream = require_is_stream();
    module2.exports = () => (input) => {
      if (!Buffer.isBuffer(input) && !isStream(input)) {
        return Promise.reject(new TypeError(`Expected a Buffer or Stream, got ${typeof input}`));
      }
      if (Buffer.isBuffer(input) && (!fileType2(input) || fileType2(input).ext !== "gz")) {
        return Promise.resolve([]);
      }
      const unzip = zlib.createGunzip();
      const result = decompressTar()(unzip);
      if (Buffer.isBuffer(input)) {
        unzip.end(input);
      } else {
        input.pipe(unzip);
      }
      return result;
    };
  }
});

// ../node_modules/decompress-unzip/node_modules/file-type/index.js
var require_file_type5 = __commonJS({
  "../node_modules/decompress-unzip/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(buf) {
      if (!(buf && buf.length > 1)) {
        return null;
      }
      if (buf[0] === 255 && buf[1] === 216 && buf[2] === 255) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (buf[0] === 137 && buf[1] === 80 && buf[2] === 78 && buf[3] === 71) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (buf[0] === 71 && buf[1] === 73 && buf[2] === 70) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (buf[8] === 87 && buf[9] === 69 && buf[10] === 66 && buf[11] === 80) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (buf[0] === 70 && buf[1] === 76 && buf[2] === 73 && buf[3] === 70) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) && buf[8] === 67 && buf[9] === 82) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (buf[0] === 73 && buf[1] === 73 && buf[2] === 42 && buf[3] === 0 || buf[0] === 77 && buf[1] === 77 && buf[2] === 0 && buf[3] === 42) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (buf[0] === 66 && buf[1] === 77) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (buf[0] === 73 && buf[1] === 73 && buf[2] === 188) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (buf[0] === 56 && buf[1] === 66 && buf[2] === 80 && buf[3] === 83) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 109 && buf[31] === 105 && buf[32] === 109 && buf[33] === 101 && buf[34] === 116 && buf[35] === 121 && buf[36] === 112 && buf[37] === 101 && buf[38] === 97 && buf[39] === 112 && buf[40] === 112 && buf[41] === 108 && buf[42] === 105 && buf[43] === 99 && buf[44] === 97 && buf[45] === 116 && buf[46] === 105 && buf[47] === 111 && buf[48] === 110 && buf[49] === 47 && buf[50] === 101 && buf[51] === 112 && buf[52] === 117 && buf[53] === 98 && buf[54] === 43 && buf[55] === 122 && buf[56] === 105 && buf[57] === 112) {
        return {
          ext: "epub",
          mime: "application/epub+zip"
        };
      }
      if (buf[0] === 80 && buf[1] === 75 && buf[2] === 3 && buf[3] === 4 && buf[30] === 77 && buf[31] === 69 && buf[32] === 84 && buf[33] === 65 && buf[34] === 45 && buf[35] === 73 && buf[36] === 78 && buf[37] === 70 && buf[38] === 47 && buf[39] === 109 && buf[40] === 111 && buf[41] === 122 && buf[42] === 105 && buf[43] === 108 && buf[44] === 108 && buf[45] === 97 && buf[46] === 46 && buf[47] === 114 && buf[48] === 115 && buf[49] === 97) {
        return {
          ext: "xpi",
          mime: "application/x-xpinstall"
        };
      }
      if (buf[0] === 80 && buf[1] === 75 && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (buf[257] === 117 && buf[258] === 115 && buf[259] === 116 && buf[260] === 97 && buf[261] === 114) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (buf[0] === 82 && buf[1] === 97 && buf[2] === 114 && buf[3] === 33 && buf[4] === 26 && buf[5] === 7 && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (buf[0] === 31 && buf[1] === 139 && buf[2] === 8) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (buf[0] === 66 && buf[1] === 90 && buf[2] === 104) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (buf[0] === 55 && buf[1] === 122 && buf[2] === 188 && buf[3] === 175 && buf[4] === 39 && buf[5] === 28) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (buf[0] === 120 && buf[1] === 1) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && (buf[3] === 24 || buf[3] === 32) && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 || buf[0] === 51 && buf[1] === 103 && buf[2] === 112 && buf[3] === 53 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[16] === 109 && buf[17] === 112 && buf[18] === 52 && buf[19] === 49 && buf[20] === 109 && buf[21] === 112 && buf[22] === 52 && buf[23] === 50 && buf[24] === 105 && buf[25] === 115 && buf[26] === 111 && buf[27] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 105 && buf[9] === 115 && buf[10] === 111 && buf[11] === 109 || buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 109 && buf[9] === 112 && buf[10] === 52 && buf[11] === 50 && buf[12] === 0 && buf[13] === 0 && buf[14] === 0 && buf[15] === 0) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 28 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 86) {
        return {
          ext: "m4v",
          mime: "video/x-m4v"
        };
      }
      if (buf[0] === 77 && buf[1] === 84 && buf[2] === 104 && buf[3] === 100) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (buf[31] === 109 && buf[32] === 97 && buf[33] === 116 && buf[34] === 114 && buf[35] === 111 && buf[36] === 115 && buf[37] === 107 && buf[38] === 97) {
        return {
          ext: "mkv",
          mime: "video/x-matroska"
        };
      }
      if (buf[0] === 26 && buf[1] === 69 && buf[2] === 223 && buf[3] === 163) {
        return {
          ext: "webm",
          mime: "video/webm"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 0 && buf[3] === 20 && buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 65 && buf[9] === 86 && buf[10] === 73) {
        return {
          ext: "avi",
          mime: "video/x-msvideo"
        };
      }
      if (buf[0] === 48 && buf[1] === 38 && buf[2] === 178 && buf[3] === 117 && buf[4] === 142 && buf[5] === 102 && buf[6] === 207 && buf[7] === 17 && buf[8] === 166 && buf[9] === 217) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3].toString(16)[0] === "b") {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (buf[0] === 73 && buf[1] === 68 && buf[2] === 51 || buf[0] === 255 && buf[1] === 251) {
        return {
          ext: "mp3",
          mime: "audio/mpeg"
        };
      }
      if (buf[4] === 102 && buf[5] === 116 && buf[6] === 121 && buf[7] === 112 && buf[8] === 77 && buf[9] === 52 && buf[10] === 65 || buf[0] === 77 && buf[1] === 52 && buf[2] === 65 && buf[3] === 32) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (buf[28] === 79 && buf[29] === 112 && buf[30] === 117 && buf[31] === 115 && buf[32] === 72 && buf[33] === 101 && buf[34] === 97 && buf[35] === 100) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (buf[0] === 79 && buf[1] === 103 && buf[2] === 103 && buf[3] === 83) {
        return {
          ext: "ogg",
          mime: "audio/ogg"
        };
      }
      if (buf[0] === 102 && buf[1] === 76 && buf[2] === 97 && buf[3] === 67) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (buf[0] === 82 && buf[1] === 73 && buf[2] === 70 && buf[3] === 70 && buf[8] === 87 && buf[9] === 65 && buf[10] === 86 && buf[11] === 69) {
        return {
          ext: "wav",
          mime: "audio/x-wav"
        };
      }
      if (buf[0] === 35 && buf[1] === 33 && buf[2] === 65 && buf[3] === 77 && buf[4] === 82 && buf[5] === 10) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (buf[0] === 37 && buf[1] === 80 && buf[2] === 68 && buf[3] === 70) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (buf[0] === 77 && buf[1] === 90) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && buf[1] === 87 && buf[2] === 83) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (buf[0] === 123 && buf[1] === 92 && buf[2] === 114 && buf[3] === 116 && buf[4] === 102) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 70 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
        return {
          ext: "woff",
          mime: "application/font-woff"
        };
      }
      if (buf[0] === 119 && buf[1] === 79 && buf[2] === 70 && buf[3] === 50 && (buf[4] === 0 && buf[5] === 1 && buf[6] === 0 && buf[7] === 0 || buf[4] === 79 && buf[5] === 84 && buf[6] === 84 && buf[7] === 79)) {
        return {
          ext: "woff2",
          mime: "application/font-woff"
        };
      }
      if (buf[34] === 76 && buf[35] === 80 && (buf[8] === 0 && buf[9] === 0 && buf[10] === 1 || buf[8] === 1 && buf[9] === 0 && buf[10] === 2 || buf[8] === 2 && buf[9] === 0 && buf[10] === 2)) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (buf[0] === 0 && buf[1] === 1 && buf[2] === 0 && buf[3] === 0 && buf[4] === 0) {
        return {
          ext: "ttf",
          mime: "application/font-sfnt"
        };
      }
      if (buf[0] === 79 && buf[1] === 84 && buf[2] === 84 && buf[3] === 79 && buf[4] === 0) {
        return {
          ext: "otf",
          mime: "application/font-sfnt"
        };
      }
      if (buf[0] === 0 && buf[1] === 0 && buf[2] === 1 && buf[3] === 0) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (buf[0] === 70 && buf[1] === 76 && buf[2] === 86 && buf[3] === 1) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (buf[0] === 37 && buf[1] === 33) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (buf[0] === 253 && buf[1] === 55 && buf[2] === 122 && buf[3] === 88 && buf[4] === 90 && buf[5] === 0) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (buf[0] === 83 && buf[1] === 81 && buf[2] === 76 && buf[3] === 105) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (buf[0] === 78 && buf[1] === 69 && buf[2] === 83 && buf[3] === 26) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (buf[0] === 67 && buf[1] === 114 && buf[2] === 50 && buf[3] === 52) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (buf[0] === 77 && buf[1] === 83 && buf[2] === 67 && buf[3] === 70 || buf[0] === 73 && buf[1] === 83 && buf[2] === 99 && buf[3] === 40) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62 && buf[7] === 10 && buf[8] === 100 && buf[9] === 101 && buf[10] === 98 && buf[11] === 105 && buf[12] === 97 && buf[13] === 110 && buf[14] === 45 && buf[15] === 98 && buf[16] === 105 && buf[17] === 110 && buf[18] === 97 && buf[19] === 114 && buf[20] === 121) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (buf[0] === 33 && buf[1] === 60 && buf[2] === 97 && buf[3] === 114 && buf[4] === 99 && buf[5] === 104 && buf[6] === 62) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (buf[0] === 237 && buf[1] === 171 && buf[2] === 238 && buf[3] === 219) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (buf[0] === 31 && buf[1] === 160 || buf[0] === 31 && buf[1] === 157) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (buf[0] === 76 && buf[1] === 90 && buf[2] === 73 && buf[3] === 80) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (buf[0] === 208 && buf[1] === 207 && buf[2] === 17 && buf[3] === 224 && buf[4] === 161 && buf[5] === 177 && buf[6] === 26 && buf[7] === 225) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      return null;
    };
  }
});

// ../node_modules/pinkie/index.js
var require_pinkie = __commonJS({
  "../node_modules/pinkie/index.js"(exports2, module2) {
    "use strict";
    var PENDING = "pending";
    var SETTLED = "settled";
    var FULFILLED = "fulfilled";
    var REJECTED = "rejected";
    var NOOP = function() {
    };
    var isNode = typeof global !== "undefined" && typeof global.process !== "undefined" && typeof global.process.emit === "function";
    var asyncSetTimer = typeof setImmediate === "undefined" ? setTimeout : setImmediate;
    var asyncQueue = [];
    var asyncTimer;
    function asyncFlush() {
      for (var i = 0; i < asyncQueue.length; i++) {
        asyncQueue[i][0](asyncQueue[i][1]);
      }
      asyncQueue = [];
      asyncTimer = false;
    }
    function asyncCall(callback, arg) {
      asyncQueue.push([callback, arg]);
      if (!asyncTimer) {
        asyncTimer = true;
        asyncSetTimer(asyncFlush, 0);
      }
    }
    function invokeResolver(resolver, promise) {
      function resolvePromise(value) {
        resolve2(promise, value);
      }
      function rejectPromise(reason) {
        reject2(promise, reason);
      }
      try {
        resolver(resolvePromise, rejectPromise);
      } catch (e) {
        rejectPromise(e);
      }
    }
    function invokeCallback(subscriber) {
      var owner = subscriber.owner;
      var settled = owner._state;
      var value = owner._data;
      var callback = subscriber[settled];
      var promise = subscriber.then;
      if (typeof callback === "function") {
        settled = FULFILLED;
        try {
          value = callback(value);
        } catch (e) {
          reject2(promise, e);
        }
      }
      if (!handleThenable(promise, value)) {
        if (settled === FULFILLED) {
          resolve2(promise, value);
        }
        if (settled === REJECTED) {
          reject2(promise, value);
        }
      }
    }
    function handleThenable(promise, value) {
      var resolved;
      try {
        if (promise === value) {
          throw new TypeError("A promises callback cannot return that same promise.");
        }
        if (value && (typeof value === "function" || typeof value === "object")) {
          var then = value.then;
          if (typeof then === "function") {
            then.call(value, function(val) {
              if (!resolved) {
                resolved = true;
                if (value === val) {
                  fulfill(promise, val);
                } else {
                  resolve2(promise, val);
                }
              }
            }, function(reason) {
              if (!resolved) {
                resolved = true;
                reject2(promise, reason);
              }
            });
            return true;
          }
        }
      } catch (e) {
        if (!resolved) {
          reject2(promise, e);
        }
        return true;
      }
      return false;
    }
    function resolve2(promise, value) {
      if (promise === value || !handleThenable(promise, value)) {
        fulfill(promise, value);
      }
    }
    function fulfill(promise, value) {
      if (promise._state === PENDING) {
        promise._state = SETTLED;
        promise._data = value;
        asyncCall(publishFulfillment, promise);
      }
    }
    function reject2(promise, reason) {
      if (promise._state === PENDING) {
        promise._state = SETTLED;
        promise._data = reason;
        asyncCall(publishRejection, promise);
      }
    }
    function publish(promise) {
      promise._then = promise._then.forEach(invokeCallback);
    }
    function publishFulfillment(promise) {
      promise._state = FULFILLED;
      publish(promise);
    }
    function publishRejection(promise) {
      promise._state = REJECTED;
      publish(promise);
      if (!promise._handled && isNode) {
        global.process.emit("unhandledRejection", promise._data, promise);
      }
    }
    function notifyRejectionHandled(promise) {
      global.process.emit("rejectionHandled", promise);
    }
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("Promise resolver " + resolver + " is not a function");
      }
      if (this instanceof Promise2 === false) {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      this._then = [];
      invokeResolver(resolver, this);
    }
    Promise2.prototype = {
      constructor: Promise2,
      _state: PENDING,
      _then: null,
      _data: void 0,
      _handled: false,
      then: function(onFulfillment, onRejection) {
        var subscriber = {
          owner: this,
          then: new this.constructor(NOOP),
          fulfilled: onFulfillment,
          rejected: onRejection
        };
        if ((onRejection || onFulfillment) && !this._handled) {
          this._handled = true;
          if (this._state === REJECTED && isNode) {
            asyncCall(notifyRejectionHandled, this);
          }
        }
        if (this._state === FULFILLED || this._state === REJECTED) {
          asyncCall(invokeCallback, subscriber);
        } else {
          this._then.push(subscriber);
        }
        return subscriber.then;
      },
      catch: function(onRejection) {
        return this.then(null, onRejection);
      }
    };
    Promise2.all = function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("You must pass an array to Promise.all().");
      }
      return new Promise2(function(resolve3, reject3) {
        var results = [];
        var remaining = 0;
        function resolver(index) {
          remaining++;
          return function(value) {
            results[index] = value;
            if (!--remaining) {
              resolve3(results);
            }
          };
        }
        for (var i = 0, promise; i < promises.length; i++) {
          promise = promises[i];
          if (promise && typeof promise.then === "function") {
            promise.then(resolver(i), reject3);
          } else {
            results[i] = promise;
          }
        }
        if (!remaining) {
          resolve3(results);
        }
      });
    };
    Promise2.race = function(promises) {
      if (!Array.isArray(promises)) {
        throw new TypeError("You must pass an array to Promise.race().");
      }
      return new Promise2(function(resolve3, reject3) {
        for (var i = 0, promise; i < promises.length; i++) {
          promise = promises[i];
          if (promise && typeof promise.then === "function") {
            promise.then(resolve3, reject3);
          } else {
            resolve3(promise);
          }
        }
      });
    };
    Promise2.resolve = function(value) {
      if (value && typeof value === "object" && value.constructor === Promise2) {
        return value;
      }
      return new Promise2(function(resolve3) {
        resolve3(value);
      });
    };
    Promise2.reject = function(reason) {
      return new Promise2(function(resolve3, reject3) {
        reject3(reason);
      });
    };
    module2.exports = Promise2;
  }
});

// ../node_modules/pinkie-promise/index.js
var require_pinkie_promise = __commonJS({
  "../node_modules/pinkie-promise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Promise === "function" ? Promise : require_pinkie();
  }
});

// ../node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "../node_modules/object-assign/index.js"(exports2, module2) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module2.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty2.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// ../node_modules/decompress-unzip/node_modules/get-stream/buffer-stream.js
var require_buffer_stream3 = __commonJS({
  "../node_modules/decompress-unzip/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    var PassThrough = require("stream").PassThrough;
    var objectAssign = require_object_assign();
    module2.exports = function(opts) {
      opts = objectAssign({}, opts);
      var array = opts.array;
      var encoding = opts.encoding;
      var buffer = encoding === "buffer";
      var objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      var len = 0;
      var ret = [];
      var stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", function(chunk) {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = function() {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = function() {
        return len;
      };
      return stream2;
    };
  }
});

// ../node_modules/decompress-unzip/node_modules/get-stream/index.js
var require_get_stream3 = __commonJS({
  "../node_modules/decompress-unzip/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var Promise2 = require_pinkie_promise();
    var objectAssign = require_object_assign();
    var bufferStream = require_buffer_stream3();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise2.reject(new Error("Expected a stream"));
      }
      opts = objectAssign({ maxBuffer: Infinity }, opts);
      var maxBuffer = opts.maxBuffer;
      var stream2;
      var clean;
      var p = new Promise2(function(resolve2, reject2) {
        stream2 = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream2);
        stream2.on("data", function() {
          if (stream2.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream2.once("error", error);
        stream2.on("end", resolve2);
        clean = function() {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream2);
          }
        };
        function error(err) {
          if (err) {
            err.bufferedData = stream2.getBufferedValue();
          }
          reject2(err);
        }
      });
      p.then(clean, clean);
      return p.then(function() {
        return stream2.getBufferedValue();
      });
    }
    module2.exports = getStream;
    module2.exports.buffer = function(stream2, opts) {
      return getStream(stream2, objectAssign({}, opts, { encoding: "buffer" }));
    };
    module2.exports.array = function(stream2, opts) {
      return getStream(stream2, objectAssign({}, opts, { array: true }));
    };
  }
});

// ../node_modules/decompress-unzip/node_modules/pify/index.js
var require_pify = __commonJS({
  "../node_modules/decompress-unzip/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = function(fn, P, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        return new P(function(resolve2, reject2) {
          args.push(function(err, result) {
            if (err) {
              reject2(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i2 = 1; i2 < arguments.length; i2++) {
                results[i2 - 1] = arguments[i2];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
          fn.apply(that, args);
        });
      };
    };
    var pify = module2.exports = function(obj, P, opts) {
      if (typeof P !== "function") {
        opts = P;
        P = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter = function(key) {
        var match = function(pattern) {
          return typeof pattern === "string" ? key === pattern : pattern.test(key);
        };
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x = obj[key];
        ret2[key] = typeof x === "function" && filter(key) ? processFn(x, P, opts) : x;
        return ret2;
      }, ret);
    };
    pify.all = pify;
  }
});

// ../node_modules/pend/index.js
var require_pend = __commonJS({
  "../node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// ../node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "../node_modules/fd-slicer/index.js"(exports2) {
    var fs = require("fs");
    var util = require("util");
    var stream2 = require("stream");
    var Readable2 = stream2.Readable;
    var Writable = stream2.Writable;
    var PassThrough = stream2.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable2);
    function ReadStream(context, options) {
      options = options || {};
      Readable2.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// ../node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "../node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// ../node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "../node_modules/yauzl/index.js"(exports2) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform2 = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE2(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE2(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE2(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE2(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE2(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE2(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform2);
    function AssertByteCountStream(byteCount) {
      Transform2.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream2 = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream2.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream2.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream2.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream2.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE2(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// ../node_modules/decompress-unzip/index.js
var require_decompress_unzip = __commonJS({
  "../node_modules/decompress-unzip/index.js"(exports2, module2) {
    "use strict";
    var fileType2 = require_file_type5();
    var getStream = require_get_stream3();
    var pify = require_pify();
    var yauzl = require_yauzl();
    var getType = (entry, mode) => {
      const IFMT = 61440;
      const IFDIR = 16384;
      const IFLNK = 40960;
      const madeBy = entry.versionMadeBy >> 8;
      if ((mode & IFMT) === IFLNK) {
        return "symlink";
      }
      if ((mode & IFMT) === IFDIR || madeBy === 0 && entry.externalFileAttributes === 16) {
        return "directory";
      }
      return "file";
    };
    var extractEntry = (entry, zip) => {
      const file = {
        mode: entry.externalFileAttributes >> 16 & 65535,
        mtime: entry.getLastModDate(),
        path: entry.fileName
      };
      file.type = getType(entry, file.mode);
      if (file.mode === 0 && file.type === "directory") {
        file.mode = 493;
      }
      if (file.mode === 0) {
        file.mode = 420;
      }
      return pify(zip.openReadStream.bind(zip))(entry).then(getStream.buffer).then((buf) => {
        file.data = buf;
        if (file.type === "symlink") {
          file.linkname = buf.toString();
        }
        return file;
      }).catch((err) => {
        zip.close();
        throw err;
      });
    };
    var extractFile = (zip) => new Promise((resolve2, reject2) => {
      const files = [];
      zip.readEntry();
      zip.on("entry", (entry) => {
        extractEntry(entry, zip).catch(reject2).then((file) => {
          files.push(file);
          zip.readEntry();
        });
      });
      zip.on("error", reject2);
      zip.on("end", () => resolve2(files));
    });
    module2.exports = () => (buf) => {
      if (!Buffer.isBuffer(buf)) {
        return Promise.reject(new TypeError(`Expected a Buffer, got ${typeof buf}`));
      }
      if (!fileType2(buf) || fileType2(buf).ext !== "zip") {
        return Promise.resolve([]);
      }
      return pify(yauzl.fromBuffer)(buf, { lazyEntries: true }).then(extractFile);
    };
  }
});

// ../node_modules/decompress/node_modules/make-dir/node_modules/pify/index.js
var require_pify2 = __commonJS({
  "../node_modules/decompress/node_modules/make-dir/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn, opts) => function() {
      const P = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return new P((resolve2, reject2) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i = 1; i < arguments.length; i++) {
                results[i - 1] = arguments[i];
              }
              if (err) {
                results.unshift(err);
                reject2(results);
              } else {
                resolve2(results);
              }
            } else if (err) {
              reject2(err);
            } else {
              resolve2(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i = 0; i < arguments.length; i++) {
                results[i] = arguments[i];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module2.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x = obj[key];
        ret[key] = typeof x === "function" && filter(key) ? processFn(x, opts) : x;
      }
      return ret;
    };
  }
});

// ../node_modules/decompress/node_modules/make-dir/index.js
var require_make_dir2 = __commonJS({
  "../node_modules/decompress/node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var pify = require_pify2();
    var defaults = {
      mode: 511 & ~process.umask(),
      fs
    };
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const err = new Error(`Path contains invalid characters: ${pth}`);
          err.code = "EINVAL";
          throw err;
        }
      }
    };
    module2.exports = (input, opts) => Promise.resolve().then(() => {
      checkPath(input);
      opts = Object.assign({}, defaults, opts);
      const mkdir = pify(opts.fs.mkdir);
      const stat = pify(opts.fs.stat);
      const make = (pth) => {
        return mkdir(pth, opts.mode).then(() => pth).catch((err) => {
          if (err.code === "ENOENT") {
            if (err.message.includes("null bytes") || path.dirname(pth) === pth) {
              throw err;
            }
            return make(path.dirname(pth)).then(() => make(pth));
          }
          return stat(pth).then((stats) => stats.isDirectory() ? pth : Promise.reject()).catch(() => {
            throw err;
          });
        });
      };
      return make(path.resolve(input));
    });
    module2.exports.sync = (input, opts) => {
      checkPath(input);
      opts = Object.assign({}, defaults, opts);
      const make = (pth) => {
        try {
          opts.fs.mkdirSync(pth, opts.mode);
        } catch (err) {
          if (err.code === "ENOENT") {
            if (err.message.includes("null bytes") || path.dirname(pth) === pth) {
              throw err;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!opts.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_2) {
            throw err;
          }
        }
        return pth;
      };
      return make(path.resolve(input));
    };
  }
});

// ../node_modules/decompress/node_modules/pify/index.js
var require_pify3 = __commonJS({
  "../node_modules/decompress/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = function(fn, P, opts) {
      return function() {
        var that = this;
        var args = new Array(arguments.length);
        for (var i = 0; i < arguments.length; i++) {
          args[i] = arguments[i];
        }
        return new P(function(resolve2, reject2) {
          args.push(function(err, result) {
            if (err) {
              reject2(err);
            } else if (opts.multiArgs) {
              var results = new Array(arguments.length - 1);
              for (var i2 = 1; i2 < arguments.length; i2++) {
                results[i2 - 1] = arguments[i2];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
          fn.apply(that, args);
        });
      };
    };
    var pify = module2.exports = function(obj, P, opts) {
      if (typeof P !== "function") {
        opts = P;
        P = Promise;
      }
      opts = opts || {};
      opts.exclude = opts.exclude || [/.+Sync$/];
      var filter = function(key) {
        var match = function(pattern) {
          return typeof pattern === "string" ? key === pattern : pattern.test(key);
        };
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      var ret = typeof obj === "function" ? function() {
        if (opts.excludeMain) {
          return obj.apply(this, arguments);
        }
        return processFn(obj, P, opts).apply(this, arguments);
      } : {};
      return Object.keys(obj).reduce(function(ret2, key) {
        var x = obj[key];
        ret2[key] = typeof x === "function" && filter(key) ? processFn(x, P, opts) : x;
        return ret2;
      }, ret);
    };
    pify.all = pify;
  }
});

// ../node_modules/is-natural-number/index.js
var require_is_natural_number = __commonJS({
  "../node_modules/is-natural-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isNaturalNumber(val, option) {
      if (option) {
        if (typeof option !== "object") {
          throw new TypeError(String(option) + " is not an object. Expected an object that has boolean `includeZero` property.");
        }
        if ("includeZero" in option) {
          if (typeof option.includeZero !== "boolean") {
            throw new TypeError(String(option.includeZero) + " is neither true nor false. `includeZero` option must be a Boolean value.");
          }
          if (option.includeZero && val === 0) {
            return true;
          }
        }
      }
      return Number.isSafeInteger(val) && val >= 1;
    };
  }
});

// ../node_modules/strip-dirs/index.js
var require_strip_dirs = __commonJS({
  "../node_modules/strip-dirs/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var util = require("util");
    var isNaturalNumber = require_is_natural_number();
    module2.exports = function stripDirs(pathStr, count, option) {
      if (typeof pathStr !== "string") {
        throw new TypeError(util.inspect(pathStr) + " is not a string. First argument to strip-dirs must be a path string.");
      }
      if (path.posix.isAbsolute(pathStr) || path.win32.isAbsolute(pathStr)) {
        throw new Error(`${pathStr} is an absolute path. strip-dirs requires a relative path.`);
      }
      if (!isNaturalNumber(count, { includeZero: true })) {
        throw new Error("The Second argument of strip-dirs must be a natural number or 0, but received " + util.inspect(count) + ".");
      }
      if (option) {
        if (typeof option !== "object") {
          throw new TypeError(util.inspect(option) + " is not an object. Expected an object with a boolean `disallowOverflow` property.");
        }
        if (Array.isArray(option)) {
          throw new TypeError(util.inspect(option) + " is an array. Expected an object with a boolean `disallowOverflow` property.");
        }
        if ("disallowOverflow" in option && typeof option.disallowOverflow !== "boolean") {
          throw new TypeError(util.inspect(option.disallowOverflow) + " is neither true nor false. `disallowOverflow` option must be a Boolean value.");
        }
      } else {
        option = { disallowOverflow: false };
      }
      const pathComponents = path.normalize(pathStr).split(path.sep);
      if (pathComponents.length > 1 && pathComponents[0] === ".") {
        pathComponents.shift();
      }
      if (count > pathComponents.length - 1) {
        if (option.disallowOverflow) {
          throw new RangeError("Cannot strip more directories than there are.");
        }
        count = pathComponents.length - 1;
      }
      return path.join.apply(null, pathComponents.slice(count));
    };
  }
});

// ../node_modules/decompress/index.js
var require_decompress = __commonJS({
  "../node_modules/decompress/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require_graceful_fs();
    var decompressTar = require_decompress_tar();
    var decompressTarbz2 = require_decompress_tarbz2();
    var decompressTargz = require_decompress_targz();
    var decompressUnzip = require_decompress_unzip();
    var makeDir = require_make_dir2();
    var pify = require_pify3();
    var stripDirs = require_strip_dirs();
    var fsP = pify(fs);
    var runPlugins = (input, opts) => {
      if (opts.plugins.length === 0) {
        return Promise.resolve([]);
      }
      return Promise.all(opts.plugins.map((x) => x(input, opts))).then((files) => files.reduce((a, b) => a.concat(b)));
    };
    var safeMakeDir = (dir, realOutputPath) => {
      return fsP.realpath(dir).catch((_2) => {
        const parent = path.dirname(dir);
        return safeMakeDir(parent, realOutputPath);
      }).then((realParentPath) => {
        if (realParentPath.indexOf(realOutputPath) !== 0) {
          throw new Error("Refusing to create a directory outside the output path.");
        }
        return makeDir(dir).then(fsP.realpath);
      });
    };
    var preventWritingThroughSymlink = (destination, realOutputPath) => {
      return fsP.readlink(destination).catch((_2) => {
        return null;
      }).then((symlinkPointsTo) => {
        if (symlinkPointsTo) {
          throw new Error("Refusing to write into a symlink");
        }
        return realOutputPath;
      });
    };
    var extractFile = (input, output, opts) => runPlugins(input, opts).then((files) => {
      if (opts.strip > 0) {
        files = files.map((x) => {
          x.path = stripDirs(x.path, opts.strip);
          return x;
        }).filter((x) => x.path !== ".");
      }
      if (typeof opts.filter === "function") {
        files = files.filter(opts.filter);
      }
      if (typeof opts.map === "function") {
        files = files.map(opts.map);
      }
      if (!output) {
        return files;
      }
      return Promise.all(files.map((x) => {
        const dest = path.join(output, x.path);
        const mode = x.mode & ~process.umask();
        const now = new Date();
        if (x.type === "directory") {
          return makeDir(output).then((outputPath) => fsP.realpath(outputPath)).then((realOutputPath) => safeMakeDir(dest, realOutputPath)).then(() => fsP.utimes(dest, now, x.mtime)).then(() => x);
        }
        return makeDir(output).then((outputPath) => fsP.realpath(outputPath)).then((realOutputPath) => {
          return safeMakeDir(path.dirname(dest), realOutputPath).then(() => realOutputPath);
        }).then((realOutputPath) => {
          if (x.type === "file") {
            return preventWritingThroughSymlink(dest, realOutputPath);
          }
          return realOutputPath;
        }).then((realOutputPath) => {
          return fsP.realpath(path.dirname(dest)).then((realDestinationDir) => {
            if (realDestinationDir.indexOf(realOutputPath) !== 0) {
              throw new Error("Refusing to write outside output directory: " + realDestinationDir);
            }
          });
        }).then(() => {
          if (x.type === "link") {
            return fsP.link(x.linkname, dest);
          }
          if (x.type === "symlink" && process.platform === "win32") {
            return fsP.link(x.linkname, dest);
          }
          if (x.type === "symlink") {
            return fsP.symlink(x.linkname, dest);
          }
          return fsP.writeFile(dest, x.data, { mode });
        }).then(() => x.type === "file" && fsP.utimes(dest, now, x.mtime)).then(() => x);
      }));
    });
    module2.exports = (input, output, opts) => {
      if (typeof input !== "string" && !Buffer.isBuffer(input)) {
        return Promise.reject(new TypeError("Input file required"));
      }
      if (typeof output === "object") {
        opts = output;
        output = null;
      }
      opts = Object.assign({ plugins: [
        decompressTar(),
        decompressTarbz2(),
        decompressTargz(),
        decompressUnzip()
      ] }, opts);
      const read = typeof input === "string" ? fsP.readFile(input) : Promise.resolve(input);
      return read.then((buf) => extractFile(buf, output, opts));
    };
  }
});

// ../node_modules/trim-repeated/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp2 = __commonJS({
  "../node_modules/trim-repeated/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// ../node_modules/trim-repeated/index.js
var require_trim_repeated = __commonJS({
  "../node_modules/trim-repeated/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp2();
    module2.exports = function(str, target) {
      if (typeof str !== "string" || typeof target !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(new RegExp("(?:" + escapeStringRegexp(target) + "){2,}", "g"), target);
    };
  }
});

// ../node_modules/filename-reserved-regex/index.js
var require_filename_reserved_regex = __commonJS({
  "../node_modules/filename-reserved-regex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = () => /[<>:"\/\\|?*\x00-\x1F]/g;
    module2.exports.windowsNames = () => /^(con|prn|aux|nul|com[0-9]|lpt[0-9])$/i;
  }
});

// ../node_modules/strip-outer/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp3 = __commonJS({
  "../node_modules/strip-outer/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    module2.exports = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
  }
});

// ../node_modules/strip-outer/index.js
var require_strip_outer = __commonJS({
  "../node_modules/strip-outer/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp3();
    module2.exports = function(str, sub) {
      if (typeof str !== "string" || typeof sub !== "string") {
        throw new TypeError();
      }
      sub = escapeStringRegexp(sub);
      return str.replace(new RegExp("^" + sub + "|" + sub + "$", "g"), "");
    };
  }
});

// ../node_modules/filenamify/index.js
var require_filenamify = __commonJS({
  "../node_modules/filenamify/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var trimRepeated = require_trim_repeated();
    var filenameReservedRegex = require_filename_reserved_regex();
    var stripOuter = require_strip_outer();
    var MAX_FILENAME_LENGTH = 100;
    var reControlChars = /[\u0000-\u001f\u0080-\u009f]/g;
    var reRelativePath = /^\.+/;
    var filenamify = (string, options = {}) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      const replacement = options.replacement === void 0 ? "!" : options.replacement;
      if (filenameReservedRegex().test(replacement) && reControlChars.test(replacement)) {
        throw new Error("Replacement string cannot contain reserved filename characters");
      }
      string = string.replace(filenameReservedRegex(), replacement);
      string = string.replace(reControlChars, replacement);
      string = string.replace(reRelativePath, replacement);
      if (replacement.length > 0) {
        string = trimRepeated(string, replacement);
        string = string.length > 1 ? stripOuter(string, replacement) : string;
      }
      string = filenameReservedRegex.windowsNames().test(string) ? string + replacement : string;
      string = string.slice(0, MAX_FILENAME_LENGTH);
      return string;
    };
    filenamify.path = (filePath, options) => {
      filePath = path.resolve(filePath);
      return path.join(path.dirname(filePath), filenamify(path.basename(filePath), options));
    };
    module2.exports = filenamify;
    module2.exports.default = filenamify;
  }
});

// ../node_modules/strict-uri-encode/index.js
var require_strict_uri_encode = __commonJS({
  "../node_modules/strict-uri-encode/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(str) {
      return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
      });
    };
  }
});

// ../node_modules/decode-uri-component/index.js
var require_decode_uri_component = __commonJS({
  "../node_modules/decode-uri-component/index.js"(exports2, module2) {
    "use strict";
    var token = "%[a-f0-9]{2}";
    var singleMatcher = new RegExp(token, "gi");
    var multiMatcher = new RegExp("(" + token + ")+", "gi");
    function decodeComponents(components, split) {
      try {
        return decodeURIComponent(components.join(""));
      } catch (err) {
      }
      if (components.length === 1) {
        return components;
      }
      split = split || 1;
      var left = components.slice(0, split);
      var right = components.slice(split);
      return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
    }
    function decode(input) {
      try {
        return decodeURIComponent(input);
      } catch (err) {
        var tokens = input.match(singleMatcher);
        for (var i = 1; i < tokens.length; i++) {
          input = decodeComponents(tokens, i).join("");
          tokens = input.match(singleMatcher);
        }
        return input;
      }
    }
    function customDecodeURIComponent(input) {
      var replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
      };
      var match = multiMatcher.exec(input);
      while (match) {
        try {
          replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
          var result = decode(match[0]);
          if (result !== match[0]) {
            replaceMap[match[0]] = result;
          }
        }
        match = multiMatcher.exec(input);
      }
      replaceMap["%C2"] = "\uFFFD";
      var entries = Object.keys(replaceMap);
      for (var i = 0; i < entries.length; i++) {
        var key = entries[i];
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
      }
      return input;
    }
    module2.exports = function(encodedURI) {
      if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
      }
      try {
        encodedURI = encodedURI.replace(/\+/g, " ");
        return decodeURIComponent(encodedURI);
      } catch (err) {
        return customDecodeURIComponent(encodedURI);
      }
    };
  }
});

// ../node_modules/query-string/index.js
var require_query_string = __commonJS({
  "../node_modules/query-string/index.js"(exports2) {
    "use strict";
    var strictUriEncode = require_strict_uri_encode();
    var objectAssign = require_object_assign();
    var decodeComponent = require_decode_uri_component();
    function encoderForArrayFormat(opts) {
      switch (opts.arrayFormat) {
        case "index":
          return function(key, value, index) {
            return value === null ? [
              encode(key, opts),
              "[",
              index,
              "]"
            ].join("") : [
              encode(key, opts),
              "[",
              encode(index, opts),
              "]=",
              encode(value, opts)
            ].join("");
          };
        case "bracket":
          return function(key, value) {
            return value === null ? encode(key, opts) : [
              encode(key, opts),
              "[]=",
              encode(value, opts)
            ].join("");
          };
        default:
          return function(key, value) {
            return value === null ? encode(key, opts) : [
              encode(key, opts),
              "=",
              encode(value, opts)
            ].join("");
          };
      }
    }
    function parserForArrayFormat(opts) {
      var result;
      switch (opts.arrayFormat) {
        case "index":
          return function(key, value, accumulator) {
            result = /\[(\d*)\]$/.exec(key);
            key = key.replace(/\[\d*\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            }
            if (accumulator[key] === void 0) {
              accumulator[key] = {};
            }
            accumulator[key][result[1]] = value;
          };
        case "bracket":
          return function(key, value, accumulator) {
            result = /(\[\])$/.exec(key);
            key = key.replace(/\[\]$/, "");
            if (!result) {
              accumulator[key] = value;
              return;
            } else if (accumulator[key] === void 0) {
              accumulator[key] = [value];
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
        default:
          return function(key, value, accumulator) {
            if (accumulator[key] === void 0) {
              accumulator[key] = value;
              return;
            }
            accumulator[key] = [].concat(accumulator[key], value);
          };
      }
    }
    function encode(value, opts) {
      if (opts.encode) {
        return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
      }
      return value;
    }
    function keysSorter(input) {
      if (Array.isArray(input)) {
        return input.sort();
      } else if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort(function(a, b) {
          return Number(a) - Number(b);
        }).map(function(key) {
          return input[key];
        });
      }
      return input;
    }
    function extract(str) {
      var queryStart = str.indexOf("?");
      if (queryStart === -1) {
        return "";
      }
      return str.slice(queryStart + 1);
    }
    function parse(str, opts) {
      opts = objectAssign({ arrayFormat: "none" }, opts);
      var formatter = parserForArrayFormat(opts);
      var ret = Object.create(null);
      if (typeof str !== "string") {
        return ret;
      }
      str = str.trim().replace(/^[?#&]/, "");
      if (!str) {
        return ret;
      }
      str.split("&").forEach(function(param) {
        var parts = param.replace(/\+/g, " ").split("=");
        var key = parts.shift();
        var val = parts.length > 0 ? parts.join("=") : void 0;
        val = val === void 0 ? null : decodeComponent(val);
        formatter(decodeComponent(key), val, ret);
      });
      return Object.keys(ret).sort().reduce(function(result, key) {
        var val = ret[key];
        if (Boolean(val) && typeof val === "object" && !Array.isArray(val)) {
          result[key] = keysSorter(val);
        } else {
          result[key] = val;
        }
        return result;
      }, Object.create(null));
    }
    exports2.extract = extract;
    exports2.parse = parse;
    exports2.stringify = function(obj, opts) {
      var defaults = {
        encode: true,
        strict: true,
        arrayFormat: "none"
      };
      opts = objectAssign(defaults, opts);
      if (opts.sort === false) {
        opts.sort = function() {
        };
      }
      var formatter = encoderForArrayFormat(opts);
      return obj ? Object.keys(obj).sort(opts.sort).map(function(key) {
        var val = obj[key];
        if (val === void 0) {
          return "";
        }
        if (val === null) {
          return encode(key, opts);
        }
        if (Array.isArray(val)) {
          var result = [];
          val.slice().forEach(function(val2) {
            if (val2 === void 0) {
              return;
            }
            result.push(formatter(key, val2, result.length));
          });
          return result.join("&");
        }
        return encode(key, opts) + "=" + encode(val, opts);
      }).filter(function(x) {
        return x.length > 0;
      }).join("&") : "";
    };
    exports2.parseUrl = function(str, opts) {
      return {
        url: str.split("?")[0] || "",
        query: parse(extract(str), opts)
      };
    };
  }
});

// ../node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "../node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    var toString = Object.prototype.toString;
    module2.exports = function(x) {
      var prototype;
      return toString.call(x) === "[object Object]" && (prototype = Object.getPrototypeOf(x), prototype === null || prototype === Object.getPrototypeOf({}));
    };
  }
});

// ../node_modules/sort-keys/index.js
var require_sort_keys = __commonJS({
  "../node_modules/sort-keys/index.js"(exports2, module2) {
    "use strict";
    var isPlainObj = require_is_plain_obj();
    module2.exports = (obj, opts) => {
      if (!isPlainObj(obj)) {
        throw new TypeError("Expected a plain object");
      }
      opts = opts || {};
      if (typeof opts === "function") {
        throw new TypeError("Specify the compare function as an option instead");
      }
      const deep = opts.deep;
      const seenInput = [];
      const seenOutput = [];
      const sortKeys = (x) => {
        const seenIndex = seenInput.indexOf(x);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const ret = {};
        const keys = Object.keys(x).sort(opts.compare);
        seenInput.push(x);
        seenOutput.push(ret);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const val = x[key];
          if (deep && Array.isArray(val)) {
            const retArr = [];
            for (let j = 0; j < val.length; j++) {
              retArr[j] = isPlainObj(val[j]) ? sortKeys(val[j]) : val[j];
            }
            ret[key] = retArr;
            continue;
          }
          ret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;
        }
        return ret;
      };
      return sortKeys(obj);
    };
  }
});

// ../node_modules/normalize-url/index.js
var require_normalize_url2 = __commonJS({
  "../node_modules/normalize-url/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var punycode = require("punycode");
    var queryString = require_query_string();
    var prependHttp = require_prepend_http();
    var sortKeys = require_sort_keys();
    var DEFAULT_PORTS = {
      "http:": 80,
      "https:": 443,
      "ftp:": 21
    };
    var slashedProtocol = {
      http: true,
      https: true,
      ftp: true,
      gopher: true,
      file: true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function testParameter(name, filters) {
      return filters.some((filter) => filter instanceof RegExp ? filter.test(name) : filter === name);
    }
    module2.exports = (str, opts) => {
      opts = Object.assign({
        normalizeProtocol: true,
        normalizeHttps: false,
        stripFragment: true,
        stripWWW: true,
        removeQueryParameters: [/^utm_\w+/i],
        removeTrailingSlash: true,
        removeDirectoryIndex: false,
        sortQueryParameters: true
      }, opts);
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      const hasRelativeProtocol = str.startsWith("//");
      str = prependHttp(str.trim()).replace(/^\/\//, "http://");
      const urlObj = url.parse(str);
      if (opts.normalizeHttps && urlObj.protocol === "https:") {
        urlObj.protocol = "http:";
      }
      if (!urlObj.hostname && !urlObj.pathname) {
        throw new Error("Invalid URL");
      }
      delete urlObj.host;
      delete urlObj.query;
      if (opts.stripFragment) {
        delete urlObj.hash;
      }
      const port = DEFAULT_PORTS[urlObj.protocol];
      if (Number(urlObj.port) === port) {
        delete urlObj.port;
      }
      if (urlObj.pathname) {
        urlObj.pathname = urlObj.pathname.replace(/\/{2,}/g, "/");
      }
      if (urlObj.pathname) {
        urlObj.pathname = decodeURI(urlObj.pathname);
      }
      if (opts.removeDirectoryIndex === true) {
        opts.removeDirectoryIndex = [/^index\.[a-z]+$/];
      }
      if (Array.isArray(opts.removeDirectoryIndex) && opts.removeDirectoryIndex.length > 0) {
        let pathComponents = urlObj.pathname.split("/");
        const lastComponent = pathComponents[pathComponents.length - 1];
        if (testParameter(lastComponent, opts.removeDirectoryIndex)) {
          pathComponents = pathComponents.slice(0, pathComponents.length - 1);
          urlObj.pathname = pathComponents.slice(1).join("/") + "/";
        }
      }
      if (slashedProtocol[urlObj.protocol]) {
        const domain = urlObj.protocol + "//" + urlObj.hostname;
        const relative = url.resolve(domain, urlObj.pathname);
        urlObj.pathname = relative.replace(domain, "");
      }
      if (urlObj.hostname) {
        urlObj.hostname = punycode.toUnicode(urlObj.hostname).toLowerCase();
        urlObj.hostname = urlObj.hostname.replace(/\.$/, "");
        if (opts.stripWWW) {
          urlObj.hostname = urlObj.hostname.replace(/^www\./, "");
        }
      }
      if (urlObj.search === "?") {
        delete urlObj.search;
      }
      const queryParameters = queryString.parse(urlObj.search);
      if (Array.isArray(opts.removeQueryParameters)) {
        for (const key in queryParameters) {
          if (testParameter(key, opts.removeQueryParameters)) {
            delete queryParameters[key];
          }
        }
      }
      if (opts.sortQueryParameters) {
        urlObj.search = queryString.stringify(sortKeys(queryParameters));
      }
      if (urlObj.search !== null) {
        urlObj.search = decodeURIComponent(urlObj.search);
      }
      str = url.format(urlObj);
      if (opts.removeTrailingSlash || urlObj.pathname === "/") {
        str = str.replace(/\/$/, "");
      }
      if (hasRelativeProtocol && !opts.normalizeProtocol) {
        str = str.replace(/^http:\/\//, "//");
      }
      return str;
    };
  }
});

// ../node_modules/cacheable-request/node_modules/get-stream/buffer-stream.js
var require_buffer_stream4 = __commonJS({
  "../node_modules/cacheable-request/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    module2.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = () => len;
      return stream2;
    };
  }
});

// ../node_modules/cacheable-request/node_modules/get-stream/index.js
var require_get_stream4 = __commonJS({
  "../node_modules/cacheable-request/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var bufferStream = require_buffer_stream4();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream2;
      let clean;
      const p = new Promise((resolve2, reject2) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream2.getBufferedValue();
          }
          reject2(err);
        };
        stream2 = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream2);
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream2.once("error", error);
        stream2.on("end", resolve2);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream2);
          }
        };
      });
      p.then(clean, clean);
      return p.then(() => stream2.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, opts) => getStream(stream2, Object.assign({}, opts, { encoding: "buffer" }));
    module2.exports.array = (stream2, opts) => getStream(stream2, Object.assign({}, opts, { array: true }));
  }
});

// ../node_modules/http-cache-semantics/node4/index.js
var require_node4 = __commonJS({
  "../node_modules/http-cache-semantics/node4/index.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var statusCodeCacheableByDefault = [200, 203, 204, 206, 300, 301, 404, 405, 410, 414, 501];
    var understoodStatuses = [200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501];
    var hopByHopHeaders = { "connection": true, "keep-alive": true, "proxy-authenticate": true, "proxy-authorization": true, "te": true, "trailer": true, "transfer-encoding": true, "upgrade": true };
    var excludedFromRevalidationUpdate = {
      "content-length": true,
      "content-encoding": true,
      "transfer-encoding": true,
      "content-range": true
    };
    function parseCacheControl(header) {
      var cc = {};
      if (!header)
        return cc;
      var parts = header.trim().split(/\s*,\s*/);
      for (var _iterator = parts, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator](); ; ) {
        var _ref;
        if (_isArray) {
          if (_i >= _iterator.length)
            break;
          _ref = _iterator[_i++];
        } else {
          _i = _iterator.next();
          if (_i.done)
            break;
          _ref = _i.value;
        }
        var part = _ref;
        var _part$split = part.split(/\s*=\s*/, 2), k = _part$split[0], v = _part$split[1];
        cc[k] = v === void 0 ? true : v.replace(/^"|"$/g, "");
      }
      return cc;
    }
    function formatCacheControl(cc) {
      var parts = [];
      for (var k in cc) {
        var v = cc[k];
        parts.push(v === true ? k : k + "=" + v);
      }
      if (!parts.length) {
        return void 0;
      }
      return parts.join(", ");
    }
    module2.exports = function() {
      function CachePolicy(req, res) {
        var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, shared = _ref2.shared, cacheHeuristic = _ref2.cacheHeuristic, immutableMinTimeToLive = _ref2.immutableMinTimeToLive, ignoreCargoCult = _ref2.ignoreCargoCult, _fromObject = _ref2._fromObject;
        _classCallCheck(this, CachePolicy);
        if (_fromObject) {
          this._fromObject(_fromObject);
          return;
        }
        if (!res || !res.headers) {
          throw Error("Response headers missing");
        }
        this._assertRequestHasHeaders(req);
        this._responseTime = this.now();
        this._isShared = shared !== false;
        this._cacheHeuristic = cacheHeuristic !== void 0 ? cacheHeuristic : 0.1;
        this._immutableMinTtl = immutableMinTimeToLive !== void 0 ? immutableMinTimeToLive : 24 * 3600 * 1e3;
        this._status = "status" in res ? res.status : 200;
        this._resHeaders = res.headers;
        this._rescc = parseCacheControl(res.headers["cache-control"]);
        this._method = "method" in req ? req.method : "GET";
        this._url = req.url;
        this._host = req.headers.host;
        this._noAuthorization = !req.headers.authorization;
        this._reqHeaders = res.headers.vary ? req.headers : null;
        this._reqcc = parseCacheControl(req.headers["cache-control"]);
        if (ignoreCargoCult && "pre-check" in this._rescc && "post-check" in this._rescc) {
          delete this._rescc["pre-check"];
          delete this._rescc["post-check"];
          delete this._rescc["no-cache"];
          delete this._rescc["no-store"];
          delete this._rescc["must-revalidate"];
          this._resHeaders = Object.assign({}, this._resHeaders, { "cache-control": formatCacheControl(this._rescc) });
          delete this._resHeaders.expires;
          delete this._resHeaders.pragma;
        }
        if (!res.headers["cache-control"] && /no-cache/.test(res.headers.pragma)) {
          this._rescc["no-cache"] = true;
        }
      }
      CachePolicy.prototype.now = function now() {
        return Date.now();
      };
      CachePolicy.prototype.storable = function storable() {
        return !!(!this._reqcc["no-store"] && (this._method === "GET" || this._method === "HEAD" || this._method === "POST" && this._hasExplicitExpiration()) && understoodStatuses.indexOf(this._status) !== -1 && !this._rescc["no-store"] && (!this._isShared || !this._rescc.private) && (!this._isShared || this._noAuthorization || this._allowsStoringAuthenticated()) && (this._resHeaders.expires || this._rescc.public || this._rescc["max-age"] || this._rescc["s-maxage"] || statusCodeCacheableByDefault.indexOf(this._status) !== -1));
      };
      CachePolicy.prototype._hasExplicitExpiration = function _hasExplicitExpiration() {
        return this._isShared && this._rescc["s-maxage"] || this._rescc["max-age"] || this._resHeaders.expires;
      };
      CachePolicy.prototype._assertRequestHasHeaders = function _assertRequestHasHeaders(req) {
        if (!req || !req.headers) {
          throw Error("Request headers missing");
        }
      };
      CachePolicy.prototype.satisfiesWithoutRevalidation = function satisfiesWithoutRevalidation(req) {
        this._assertRequestHasHeaders(req);
        var requestCC = parseCacheControl(req.headers["cache-control"]);
        if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
          return false;
        }
        if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
          return false;
        }
        if (requestCC["min-fresh"] && this.timeToLive() < 1e3 * requestCC["min-fresh"]) {
          return false;
        }
        if (this.stale()) {
          var allowsStale = requestCC["max-stale"] && !this._rescc["must-revalidate"] && (requestCC["max-stale"] === true || requestCC["max-stale"] > this.age() - this.maxAge());
          if (!allowsStale) {
            return false;
          }
        }
        return this._requestMatches(req, false);
      };
      CachePolicy.prototype._requestMatches = function _requestMatches(req, allowHeadMethod) {
        return (!this._url || this._url === req.url) && this._host === req.headers.host && (!req.method || this._method === req.method || allowHeadMethod && req.method === "HEAD") && this._varyMatches(req);
      };
      CachePolicy.prototype._allowsStoringAuthenticated = function _allowsStoringAuthenticated() {
        return this._rescc["must-revalidate"] || this._rescc.public || this._rescc["s-maxage"];
      };
      CachePolicy.prototype._varyMatches = function _varyMatches(req) {
        if (!this._resHeaders.vary) {
          return true;
        }
        if (this._resHeaders.vary === "*") {
          return false;
        }
        var fields = this._resHeaders.vary.trim().toLowerCase().split(/\s*,\s*/);
        for (var _iterator2 = fields, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator](); ; ) {
          var _ref3;
          if (_isArray2) {
            if (_i2 >= _iterator2.length)
              break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done)
              break;
            _ref3 = _i2.value;
          }
          var name = _ref3;
          if (req.headers[name] !== this._reqHeaders[name])
            return false;
        }
        return true;
      };
      CachePolicy.prototype._copyWithoutHopByHopHeaders = function _copyWithoutHopByHopHeaders(inHeaders) {
        var headers = {};
        for (var name in inHeaders) {
          if (hopByHopHeaders[name])
            continue;
          headers[name] = inHeaders[name];
        }
        if (inHeaders.connection) {
          var tokens = inHeaders.connection.trim().split(/\s*,\s*/);
          for (var _iterator3 = tokens, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator](); ; ) {
            var _ref4;
            if (_isArray3) {
              if (_i3 >= _iterator3.length)
                break;
              _ref4 = _iterator3[_i3++];
            } else {
              _i3 = _iterator3.next();
              if (_i3.done)
                break;
              _ref4 = _i3.value;
            }
            var _name = _ref4;
            delete headers[_name];
          }
        }
        if (headers.warning) {
          var warnings = headers.warning.split(/,/).filter(function(warning) {
            return !/^\s*1[0-9][0-9]/.test(warning);
          });
          if (!warnings.length) {
            delete headers.warning;
          } else {
            headers.warning = warnings.join(",").trim();
          }
        }
        return headers;
      };
      CachePolicy.prototype.responseHeaders = function responseHeaders() {
        var headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
        var age = this.age();
        if (age > 3600 * 24 && !this._hasExplicitExpiration() && this.maxAge() > 3600 * 24) {
          headers.warning = (headers.warning ? `${headers.warning}, ` : "") + '113 - "rfc7234 5.5.4"';
        }
        headers.age = `${Math.round(age)}`;
        return headers;
      };
      CachePolicy.prototype.date = function date() {
        var dateValue = Date.parse(this._resHeaders.date);
        var maxClockDrift = 8 * 3600 * 1e3;
        if (Number.isNaN(dateValue) || dateValue < this._responseTime - maxClockDrift || dateValue > this._responseTime + maxClockDrift) {
          return this._responseTime;
        }
        return dateValue;
      };
      CachePolicy.prototype.age = function age() {
        var age2 = Math.max(0, (this._responseTime - this.date()) / 1e3);
        if (this._resHeaders.age) {
          var ageValue = this._ageValue();
          if (ageValue > age2)
            age2 = ageValue;
        }
        var residentTime = (this.now() - this._responseTime) / 1e3;
        return age2 + residentTime;
      };
      CachePolicy.prototype._ageValue = function _ageValue() {
        var ageValue = parseInt(this._resHeaders.age);
        return isFinite(ageValue) ? ageValue : 0;
      };
      CachePolicy.prototype.maxAge = function maxAge() {
        if (!this.storable() || this._rescc["no-cache"]) {
          return 0;
        }
        if (this._isShared && this._resHeaders["set-cookie"] && !this._rescc.public && !this._rescc.immutable) {
          return 0;
        }
        if (this._resHeaders.vary === "*") {
          return 0;
        }
        if (this._isShared) {
          if (this._rescc["proxy-revalidate"]) {
            return 0;
          }
          if (this._rescc["s-maxage"]) {
            return parseInt(this._rescc["s-maxage"], 10);
          }
        }
        if (this._rescc["max-age"]) {
          return parseInt(this._rescc["max-age"], 10);
        }
        var defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;
        var dateValue = this.date();
        if (this._resHeaders.expires) {
          var expires = Date.parse(this._resHeaders.expires);
          if (Number.isNaN(expires) || expires < dateValue) {
            return 0;
          }
          return Math.max(defaultMinTtl, (expires - dateValue) / 1e3);
        }
        if (this._resHeaders["last-modified"]) {
          var lastModified = Date.parse(this._resHeaders["last-modified"]);
          if (isFinite(lastModified) && dateValue > lastModified) {
            return Math.max(defaultMinTtl, (dateValue - lastModified) / 1e3 * this._cacheHeuristic);
          }
        }
        return defaultMinTtl;
      };
      CachePolicy.prototype.timeToLive = function timeToLive() {
        return Math.max(0, this.maxAge() - this.age()) * 1e3;
      };
      CachePolicy.prototype.stale = function stale() {
        return this.maxAge() <= this.age();
      };
      CachePolicy.fromObject = function fromObject(obj) {
        return new this(void 0, void 0, { _fromObject: obj });
      };
      CachePolicy.prototype._fromObject = function _fromObject(obj) {
        if (this._responseTime)
          throw Error("Reinitialized");
        if (!obj || obj.v !== 1)
          throw Error("Invalid serialization");
        this._responseTime = obj.t;
        this._isShared = obj.sh;
        this._cacheHeuristic = obj.ch;
        this._immutableMinTtl = obj.imm !== void 0 ? obj.imm : 24 * 3600 * 1e3;
        this._status = obj.st;
        this._resHeaders = obj.resh;
        this._rescc = obj.rescc;
        this._method = obj.m;
        this._url = obj.u;
        this._host = obj.h;
        this._noAuthorization = obj.a;
        this._reqHeaders = obj.reqh;
        this._reqcc = obj.reqcc;
      };
      CachePolicy.prototype.toObject = function toObject() {
        return {
          v: 1,
          t: this._responseTime,
          sh: this._isShared,
          ch: this._cacheHeuristic,
          imm: this._immutableMinTtl,
          st: this._status,
          resh: this._resHeaders,
          rescc: this._rescc,
          m: this._method,
          u: this._url,
          h: this._host,
          a: this._noAuthorization,
          reqh: this._reqHeaders,
          reqcc: this._reqcc
        };
      };
      CachePolicy.prototype.revalidationHeaders = function revalidationHeaders(incomingReq) {
        this._assertRequestHasHeaders(incomingReq);
        var headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
        delete headers["if-range"];
        if (!this._requestMatches(incomingReq, true) || !this.storable()) {
          delete headers["if-none-match"];
          delete headers["if-modified-since"];
          return headers;
        }
        if (this._resHeaders.etag) {
          headers["if-none-match"] = headers["if-none-match"] ? `${headers["if-none-match"]}, ${this._resHeaders.etag}` : this._resHeaders.etag;
        }
        var forbidsWeakValidators = headers["accept-ranges"] || headers["if-match"] || headers["if-unmodified-since"] || this._method && this._method != "GET";
        if (forbidsWeakValidators) {
          delete headers["if-modified-since"];
          if (headers["if-none-match"]) {
            var etags = headers["if-none-match"].split(/,/).filter(function(etag) {
              return !/^\s*W\//.test(etag);
            });
            if (!etags.length) {
              delete headers["if-none-match"];
            } else {
              headers["if-none-match"] = etags.join(",").trim();
            }
          }
        } else if (this._resHeaders["last-modified"] && !headers["if-modified-since"]) {
          headers["if-modified-since"] = this._resHeaders["last-modified"];
        }
        return headers;
      };
      CachePolicy.prototype.revalidatedPolicy = function revalidatedPolicy(request, response) {
        this._assertRequestHasHeaders(request);
        if (!response || !response.headers) {
          throw Error("Response headers missing");
        }
        var matches = false;
        if (response.status !== void 0 && response.status != 304) {
          matches = false;
        } else if (response.headers.etag && !/^\s*W\//.test(response.headers.etag)) {
          matches = this._resHeaders.etag && this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag;
        } else if (this._resHeaders.etag && response.headers.etag) {
          matches = this._resHeaders.etag.replace(/^\s*W\//, "") === response.headers.etag.replace(/^\s*W\//, "");
        } else if (this._resHeaders["last-modified"]) {
          matches = this._resHeaders["last-modified"] === response.headers["last-modified"];
        } else {
          if (!this._resHeaders.etag && !this._resHeaders["last-modified"] && !response.headers.etag && !response.headers["last-modified"]) {
            matches = true;
          }
        }
        if (!matches) {
          return {
            policy: new this.constructor(request, response),
            modified: true
          };
        }
        var headers = {};
        for (var k in this._resHeaders) {
          headers[k] = k in response.headers && !excludedFromRevalidationUpdate[k] ? response.headers[k] : this._resHeaders[k];
        }
        var newResponse = Object.assign({}, response, {
          status: this._status,
          method: this._method,
          headers
        });
        return {
          policy: new this.constructor(request, newResponse),
          modified: false
        };
      };
      return CachePolicy;
    }();
  }
});

// ../node_modules/cacheable-request/node_modules/lowercase-keys/index.js
var require_lowercase_keys3 = __commonJS({
  "../node_modules/cacheable-request/node_modules/lowercase-keys/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(obj) {
      var ret = {};
      var keys = Object.keys(Object(obj));
      for (var i = 0; i < keys.length; i++) {
        ret[keys[i].toLowerCase()] = obj[keys[i]];
      }
      return ret;
    };
  }
});

// ../node_modules/cacheable-request/src/index.js
var require_src6 = __commonJS({
  "../node_modules/cacheable-request/src/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var urlLib = require("url");
    var normalizeUrl = require_normalize_url2();
    var getStream = require_get_stream4();
    var CachePolicy = require_node4();
    var Response = require_src2();
    var lowercaseKeys = require_lowercase_keys3();
    var cloneResponse = require_src3();
    var Keyv = require_src4();
    var CacheableRequest = class {
      constructor(request, cacheAdapter) {
        if (typeof request !== "function") {
          throw new TypeError("Parameter `request` must be a function");
        }
        this.cache = new Keyv({
          uri: typeof cacheAdapter === "string" && cacheAdapter,
          store: typeof cacheAdapter !== "string" && cacheAdapter,
          namespace: "cacheable-request"
        });
        return this.createCacheableRequest(request);
      }
      createCacheableRequest(request) {
        return (opts, cb) => {
          if (typeof opts === "string") {
            opts = urlLib.parse(opts);
          }
          opts = Object.assign({
            headers: {},
            method: "GET",
            cache: true,
            strictTtl: false,
            automaticFailover: false
          }, opts);
          opts.headers = lowercaseKeys(opts.headers);
          const ee = new EventEmitter();
          const url = normalizeUrl(urlLib.format(opts));
          const key = `${opts.method}:${url}`;
          let revalidate = false;
          let madeRequest = false;
          const makeRequest = (opts2) => {
            madeRequest = true;
            const handler = (response) => {
              if (revalidate) {
                const revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts2, response);
                if (!revalidatedPolicy.modified) {
                  const headers = revalidatedPolicy.policy.responseHeaders();
                  response = new Response(response.statusCode, headers, revalidate.body, revalidate.url);
                  response.cachePolicy = revalidatedPolicy.policy;
                  response.fromCache = true;
                }
              }
              if (!response.fromCache) {
                response.cachePolicy = new CachePolicy(opts2, response);
                response.fromCache = false;
              }
              let clonedResponse;
              if (opts2.cache && response.cachePolicy.storable()) {
                clonedResponse = cloneResponse(response);
                getStream.buffer(response).then((body) => {
                  const value = {
                    cachePolicy: response.cachePolicy.toObject(),
                    url: response.url,
                    statusCode: response.fromCache ? revalidate.statusCode : response.statusCode,
                    body
                  };
                  const ttl = opts2.strictTtl ? response.cachePolicy.timeToLive() : void 0;
                  return this.cache.set(key, value, ttl);
                }).catch((err) => ee.emit("error", new CacheableRequest.CacheError(err)));
              } else if (opts2.cache && revalidate) {
                this.cache.delete(key).catch((err) => ee.emit("error", new CacheableRequest.CacheError(err)));
              }
              ee.emit("response", clonedResponse || response);
              if (typeof cb === "function") {
                cb(clonedResponse || response);
              }
            };
            try {
              const req = request(opts2, handler);
              ee.emit("request", req);
            } catch (err) {
              ee.emit("error", new CacheableRequest.RequestError(err));
            }
          };
          const get = (opts2) => Promise.resolve().then(() => opts2.cache ? this.cache.get(key) : void 0).then((cacheEntry) => {
            if (typeof cacheEntry === "undefined") {
              return makeRequest(opts2);
            }
            const policy = CachePolicy.fromObject(cacheEntry.cachePolicy);
            if (policy.satisfiesWithoutRevalidation(opts2)) {
              const headers = policy.responseHeaders();
              const response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);
              response.cachePolicy = policy;
              response.fromCache = true;
              ee.emit("response", response);
              if (typeof cb === "function") {
                cb(response);
              }
            } else {
              revalidate = cacheEntry;
              opts2.headers = policy.revalidationHeaders(opts2);
              makeRequest(opts2);
            }
          });
          this.cache.on("error", (err) => ee.emit("error", new CacheableRequest.CacheError(err)));
          get(opts).catch((err) => {
            if (opts.automaticFailover && !madeRequest) {
              makeRequest(opts);
            }
            ee.emit("error", new CacheableRequest.CacheError(err));
          });
          return ee;
        };
      }
    };
    CacheableRequest.RequestError = class extends Error {
      constructor(err) {
        super(err.message);
        this.name = "RequestError";
        Object.assign(this, err);
      }
    };
    CacheableRequest.CacheError = class extends Error {
      constructor(err) {
        super(err.message);
        this.name = "CacheError";
        Object.assign(this, err);
      }
    };
    module2.exports = CacheableRequest;
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream4 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList2 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream4();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy3();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex3();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex3();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream2, cb) {
      var er = new Error("write after end");
      stream2.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream2.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream2.emit("error", err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable3();
    var Writable = require_stream_writable3();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../node_modules/from2/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder3 = __commonJS({
  "../node_modules/from2/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream4();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList2();
    var destroyImpl = require_destroy3();
    var StringDecoder;
    util.inherits(Readable2, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex3();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder3().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex3();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream2.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream2.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            stream2.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream2.emit("data", chunk);
        stream2.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder3().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream2);
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream2);
        else
          emitReadable_(stream2);
      }
    }
    function emitReadable_(stream2) {
      debug("emit readable");
      stream2.emit("readable");
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream2.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var Duplex = require_stream_duplex3();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream2._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream2.push(null);
    }
  }
});

// ../node_modules/from2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform3();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/from2/node_modules/readable-stream/readable.js
var require_readable3 = __commonJS({
  "../node_modules/from2/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable3();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable3();
      exports2.Duplex = require_stream_duplex3();
      exports2.Transform = require_stream_transform3();
      exports2.PassThrough = require_stream_passthrough3();
    }
  }
});

// ../node_modules/from2/index.js
var require_from22 = __commonJS({
  "../node_modules/from2/index.js"(exports2, module2) {
    var Readable2 = require_readable3().Readable;
    var inherits = require_inherits();
    module2.exports = from2;
    from2.ctor = ctor;
    from2.obj = obj;
    var Proto = ctor();
    function toFunction(list) {
      list = list.slice();
      return function(_2, cb) {
        var err = null;
        var item = list.length ? list.shift() : null;
        if (item instanceof Error) {
          err = item;
          item = null;
        }
        cb(err, item);
      };
    }
    function from2(opts, read) {
      if (typeof opts !== "object" || Array.isArray(opts)) {
        read = opts;
        opts = {};
      }
      var rs = new Proto(opts);
      rs._from = Array.isArray(read) ? toFunction(read) : read || noop;
      return rs;
    }
    function ctor(opts, read) {
      if (typeof opts === "function") {
        read = opts;
        opts = {};
      }
      opts = defaults(opts);
      inherits(Class, Readable2);
      function Class(override) {
        if (!(this instanceof Class))
          return new Class(override);
        this._reading = false;
        this._callback = check;
        this.destroyed = false;
        Readable2.call(this, override || opts);
        var self2 = this;
        var hwm = this._readableState.highWaterMark;
        function check(err, data) {
          if (self2.destroyed)
            return;
          if (err)
            return self2.destroy(err);
          if (data === null)
            return self2.push(null);
          self2._reading = false;
          if (self2.push(data))
            self2._read(hwm);
        }
      }
      Class.prototype._from = read || noop;
      Class.prototype._read = function(size) {
        if (this._reading || this.destroyed)
          return;
        this._reading = true;
        this._from(size, this._callback);
      };
      Class.prototype.destroy = function(err) {
        if (this.destroyed)
          return;
        this.destroyed = true;
        var self2 = this;
        process.nextTick(function() {
          if (err)
            self2.emit("error", err);
          self2.emit("close");
        });
      };
      return Class;
    }
    function obj(opts, read) {
      if (typeof opts === "function" || Array.isArray(opts)) {
        read = opts;
        opts = {};
      }
      opts = defaults(opts);
      opts.objectMode = true;
      opts.highWaterMark = 16;
      return from2(opts, read);
    }
    function noop() {
    }
    function defaults(opts) {
      opts = opts || {};
      return opts;
    }
  }
});

// ../node_modules/p-is-promise/index.js
var require_p_is_promise = __commonJS({
  "../node_modules/p-is-promise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (x) => x instanceof Promise || x !== null && typeof x === "object" && typeof x.then === "function" && typeof x.catch === "function";
  }
});

// ../node_modules/into-stream/index.js
var require_into_stream = __commonJS({
  "../node_modules/into-stream/index.js"(exports2, module2) {
    "use strict";
    var from = require_from22();
    var pIsPromise = require_p_is_promise();
    module2.exports = (x) => {
      if (Array.isArray(x)) {
        x = x.slice();
      }
      let promise;
      let iterator;
      prepare(x);
      function prepare(value) {
        x = value;
        promise = pIsPromise(x) ? x : null;
        const shouldIterate = !promise && x[Symbol.iterator] && typeof x !== "string" && !Buffer.isBuffer(x);
        iterator = shouldIterate ? x[Symbol.iterator]() : null;
      }
      return from(function reader(size, cb) {
        if (promise) {
          promise.then(prepare).then(() => reader.call(this, size, cb), cb);
          return;
        }
        if (iterator) {
          const obj = iterator.next();
          setImmediate(cb, null, obj.done ? null : obj.value);
          return;
        }
        if (x.length === 0) {
          setImmediate(cb, null, null);
          return;
        }
        const chunk = x.slice(0, size);
        x = x.slice(size);
        setImmediate(cb, null, chunk);
      });
    };
    module2.exports.obj = (x) => {
      if (Array.isArray(x)) {
        x = x.slice();
      }
      let promise;
      let iterator;
      prepare(x);
      function prepare(value) {
        x = value;
        promise = pIsPromise(x) ? x : null;
        iterator = !promise && x[Symbol.iterator] ? x[Symbol.iterator]() : null;
      }
      return from.obj(function reader(size, cb) {
        if (promise) {
          promise.then(prepare).then(() => reader.call(this, size, cb), cb);
          return;
        }
        if (iterator) {
          const obj = iterator.next();
          setImmediate(cb, null, obj.done ? null : obj.value);
          return;
        }
        this.push(x);
        setImmediate(cb, null, null);
      });
    };
  }
});

// ../node_modules/@sindresorhus/is/dist/index.js
var require_dist3 = __commonJS({
  "../node_modules/@sindresorhus/is/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util = require("util");
    var toString = Object.prototype.toString;
    var isOfType = (type) => (value) => typeof value === type;
    var getObjectType = (value) => {
      const objectName = toString.call(value).slice(8, -1);
      if (objectName) {
        return objectName;
      }
      return null;
    };
    var isObjectOfType = (typeName) => (value) => {
      return getObjectType(value) === typeName;
    };
    function is(value) {
      if (value === null) {
        return "null";
      }
      if (value === true || value === false) {
        return "boolean";
      }
      const type = typeof value;
      if (type === "undefined") {
        return "undefined";
      }
      if (type === "string") {
        return "string";
      }
      if (type === "number") {
        return "number";
      }
      if (type === "symbol") {
        return "symbol";
      }
      if (is.function_(value)) {
        return "Function";
      }
      if (Array.isArray(value)) {
        return "Array";
      }
      if (Buffer.isBuffer(value)) {
        return "Buffer";
      }
      const tagType = getObjectType(value);
      if (tagType) {
        return tagType;
      }
      if (value instanceof String || value instanceof Boolean || value instanceof Number) {
        throw new TypeError("Please don't use object wrappers for primitive types");
      }
      return "Object";
    }
    (function(is2) {
      const isObject = (value) => typeof value === "object";
      is2.undefined = isOfType("undefined");
      is2.string = isOfType("string");
      is2.number = isOfType("number");
      is2.function_ = isOfType("function");
      is2.null_ = (value) => value === null;
      is2.class_ = (value) => is2.function_(value) && value.toString().startsWith("class ");
      is2.boolean = (value) => value === true || value === false;
      is2.symbol = isOfType("symbol");
      is2.array = Array.isArray;
      is2.buffer = Buffer.isBuffer;
      is2.nullOrUndefined = (value) => is2.null_(value) || is2.undefined(value);
      is2.object = (value) => !is2.nullOrUndefined(value) && (is2.function_(value) || isObject(value));
      is2.iterable = (value) => !is2.nullOrUndefined(value) && is2.function_(value[Symbol.iterator]);
      is2.generator = (value) => is2.iterable(value) && is2.function_(value.next) && is2.function_(value.throw);
      is2.nativePromise = isObjectOfType("Promise");
      const hasPromiseAPI = (value) => !is2.null_(value) && isObject(value) && is2.function_(value.then) && is2.function_(value.catch);
      is2.promise = (value) => is2.nativePromise(value) || hasPromiseAPI(value);
      const isFunctionOfType = (type) => (value) => is2.function_(value) && is2.function_(value.constructor) && value.constructor.name === type;
      is2.generatorFunction = isFunctionOfType("GeneratorFunction");
      is2.asyncFunction = isFunctionOfType("AsyncFunction");
      is2.boundFunction = (value) => is2.function_(value) && !value.hasOwnProperty("prototype");
      is2.regExp = isObjectOfType("RegExp");
      is2.date = isObjectOfType("Date");
      is2.error = isObjectOfType("Error");
      is2.map = isObjectOfType("Map");
      is2.set = isObjectOfType("Set");
      is2.weakMap = isObjectOfType("WeakMap");
      is2.weakSet = isObjectOfType("WeakSet");
      is2.int8Array = isObjectOfType("Int8Array");
      is2.uint8Array = isObjectOfType("Uint8Array");
      is2.uint8ClampedArray = isObjectOfType("Uint8ClampedArray");
      is2.int16Array = isObjectOfType("Int16Array");
      is2.uint16Array = isObjectOfType("Uint16Array");
      is2.int32Array = isObjectOfType("Int32Array");
      is2.uint32Array = isObjectOfType("Uint32Array");
      is2.float32Array = isObjectOfType("Float32Array");
      is2.float64Array = isObjectOfType("Float64Array");
      is2.arrayBuffer = isObjectOfType("ArrayBuffer");
      is2.sharedArrayBuffer = isObjectOfType("SharedArrayBuffer");
      is2.dataView = isObjectOfType("DataView");
      is2.directInstanceOf = (instance, klass) => is2.object(instance) && is2.object(klass) && Object.getPrototypeOf(instance) === klass.prototype;
      is2.truthy = (value) => Boolean(value);
      is2.falsy = (value) => !value;
      is2.nan = (value) => Number.isNaN(value);
      const primitiveTypes = new Set([
        "undefined",
        "string",
        "number",
        "boolean",
        "symbol"
      ]);
      is2.primitive = (value) => is2.null_(value) || primitiveTypes.has(typeof value);
      is2.integer = (value) => Number.isInteger(value);
      is2.safeInteger = (value) => Number.isSafeInteger(value);
      is2.plainObject = (value) => {
        let prototype;
        return getObjectType(value) === "Object" && (prototype = Object.getPrototypeOf(value), prototype === null || prototype === Object.getPrototypeOf({}));
      };
      const typedArrayTypes = new Set([
        "Int8Array",
        "Uint8Array",
        "Uint8ClampedArray",
        "Int16Array",
        "Uint16Array",
        "Int32Array",
        "Uint32Array",
        "Float32Array",
        "Float64Array"
      ]);
      is2.typedArray = (value) => {
        const objectType = getObjectType(value);
        if (objectType === null) {
          return false;
        }
        return typedArrayTypes.has(objectType);
      };
      const isValidLength = (value) => is2.safeInteger(value) && value > -1;
      is2.arrayLike = (value) => !is2.nullOrUndefined(value) && !is2.function_(value) && isValidLength(value.length);
      is2.inRange = (value, range) => {
        if (is2.number(range)) {
          return value >= Math.min(0, range) && value <= Math.max(range, 0);
        }
        if (is2.array(range) && range.length === 2) {
          return value >= Math.min.apply(null, range) && value <= Math.max.apply(null, range);
        }
        throw new TypeError(`Invalid range: ${util.inspect(range)}`);
      };
      const NODE_TYPE_ELEMENT = 1;
      const DOM_PROPERTIES_TO_CHECK = [
        "innerHTML",
        "ownerDocument",
        "style",
        "attributes",
        "nodeValue"
      ];
      is2.domElement = (value) => is2.object(value) && value.nodeType === NODE_TYPE_ELEMENT && is2.string(value.nodeName) && !is2.plainObject(value) && DOM_PROPERTIES_TO_CHECK.every((property) => property in value);
      is2.nodeStream = (value) => !is2.nullOrUndefined(value) && isObject(value) && is2.function_(value.pipe);
      is2.infinite = (value) => value === Infinity || value === -Infinity;
      const isAbsoluteMod2 = (value) => (rem) => is2.integer(rem) && Math.abs(rem % 2) === value;
      is2.even = isAbsoluteMod2(0);
      is2.odd = isAbsoluteMod2(1);
      const isWhiteSpaceString = (value) => is2.string(value) && /\S/.test(value) === false;
      const isEmptyStringOrArray = (value) => (is2.string(value) || is2.array(value)) && value.length === 0;
      const isEmptyObject = (value) => !is2.map(value) && !is2.set(value) && is2.object(value) && Object.keys(value).length === 0;
      const isEmptyMapOrSet = (value) => (is2.map(value) || is2.set(value)) && value.size === 0;
      is2.empty = (value) => is2.falsy(value) || isEmptyStringOrArray(value) || isEmptyObject(value) || isEmptyMapOrSet(value);
      is2.emptyOrWhitespace = (value) => is2.empty(value) || isWhiteSpaceString(value);
      const predicateOnArray = (method, predicate, args) => {
        const values = Array.prototype.slice.call(args, 1);
        if (is2.function_(predicate) === false) {
          throw new TypeError(`Invalid predicate: ${util.inspect(predicate)}`);
        }
        if (values.length === 0) {
          throw new TypeError("Invalid number of values");
        }
        return method.call(values, predicate);
      };
      function any(predicate) {
        return predicateOnArray(Array.prototype.some, predicate, arguments);
      }
      is2.any = any;
      function all(predicate) {
        return predicateOnArray(Array.prototype.every, predicate, arguments);
      }
      is2.all = all;
    })(is || (is = {}));
    Object.defineProperties(is, {
      class: {
        value: is.class_
      },
      function: {
        value: is.function_
      },
      null: {
        value: is.null_
      }
    });
    exports2.default = is;
    module2.exports = is;
    module2.exports.default = is;
  }
});

// ../node_modules/got/node_modules/get-stream/buffer-stream.js
var require_buffer_stream5 = __commonJS({
  "../node_modules/got/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    module2.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = () => len;
      return stream2;
    };
  }
});

// ../node_modules/got/node_modules/get-stream/index.js
var require_get_stream5 = __commonJS({
  "../node_modules/got/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var bufferStream = require_buffer_stream5();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream2;
      let clean;
      const p = new Promise((resolve2, reject2) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream2.getBufferedValue();
          }
          reject2(err);
        };
        stream2 = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream2);
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream2.once("error", error);
        stream2.on("end", resolve2);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream2);
          }
        };
      });
      p.then(clean, clean);
      return p.then(() => stream2.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, opts) => getStream(stream2, Object.assign({}, opts, { encoding: "buffer" }));
    module2.exports.array = (stream2, opts) => getStream(stream2, Object.assign({}, opts, { array: true }));
  }
});

// ../node_modules/timed-out/index.js
var require_timed_out2 = __commonJS({
  "../node_modules/timed-out/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(req, time) {
      if (req.timeoutTimer) {
        return req;
      }
      var delays = isNaN(time) ? time : { socket: time, connect: time };
      var host = req._headers ? " to " + req._headers.host : "";
      if (delays.connect !== void 0) {
        req.timeoutTimer = setTimeout(function timeoutHandler() {
          req.abort();
          var e = new Error("Connection timed out on request" + host);
          e.code = "ETIMEDOUT";
          req.emit("error", e);
        }, delays.connect);
      }
      req.on("socket", function assign(socket) {
        if (!(socket.connecting || socket._connecting)) {
          connect();
          return;
        }
        socket.once("connect", connect);
      });
      function clear() {
        if (req.timeoutTimer) {
          clearTimeout(req.timeoutTimer);
          req.timeoutTimer = null;
        }
      }
      function connect() {
        clear();
        if (delays.socket !== void 0) {
          req.setTimeout(delays.socket, function socketTimeoutHandler() {
            req.abort();
            var e = new Error("Socket timed out on request" + host);
            e.code = "ESOCKETTIMEDOUT";
            req.emit("error", e);
          });
        }
      }
      return req.on("error", clear);
    };
  }
});

// ../node_modules/url-to-options/index.js
var require_url_to_options2 = __commonJS({
  "../node_modules/url-to-options/index.js"(exports2, module2) {
    "use strict";
    function urlToOptions(url) {
      var options = {
        protocol: url.protocol,
        hostname: url.hostname,
        hash: url.hash,
        search: url.search,
        pathname: url.pathname,
        path: `${url.pathname}${url.search}`,
        href: url.href
      };
      if (url.port !== "") {
        options.port = Number(url.port);
      }
      if (url.username || url.password) {
        options.auth = `${url.username}:${url.password}`;
      }
      return options;
    }
    module2.exports = urlToOptions;
  }
});

// ../node_modules/got/node_modules/is-retry-allowed/index.js
var require_is_retry_allowed = __commonJS({
  "../node_modules/got/node_modules/is-retry-allowed/index.js"(exports2, module2) {
    "use strict";
    var WHITELIST = [
      "ETIMEDOUT",
      "ECONNRESET",
      "EADDRINUSE",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "EPIPE",
      "EHOSTUNREACH",
      "EAI_AGAIN"
    ];
    var BLACKLIST = [
      "ENOTFOUND",
      "ENETUNREACH",
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED"
    ];
    module2.exports = function(err) {
      if (!err || !err.code) {
        return true;
      }
      if (WHITELIST.indexOf(err.code) !== -1) {
        return true;
      }
      if (BLACKLIST.indexOf(err.code) !== -1) {
        return false;
      }
      return true;
    };
  }
});

// ../node_modules/has-symbol-support-x/index.js
var require_has_symbol_support_x = __commonJS({
  "../node_modules/has-symbol-support-x/index.js"(exports2, module2) {
    "use strict";
    module2.exports = typeof Symbol === "function" && typeof Symbol("") === "symbol";
  }
});

// ../node_modules/has-to-string-tag-x/index.js
var require_has_to_string_tag_x = __commonJS({
  "../node_modules/has-to-string-tag-x/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_has_symbol_support_x() && typeof Symbol.toStringTag === "symbol";
  }
});

// ../node_modules/is-object/index.js
var require_is_object2 = __commonJS({
  "../node_modules/is-object/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function isObject(x) {
      return typeof x === "object" && x !== null;
    };
  }
});

// ../node_modules/isurl/index.js
var require_isurl = __commonJS({
  "../node_modules/isurl/index.js"(exports2, module2) {
    "use strict";
    var hasToStringTag = require_has_to_string_tag_x();
    var isObject = require_is_object2();
    var toString = Object.prototype.toString;
    var urlClass = "[object URL]";
    var hash = "hash";
    var host = "host";
    var hostname = "hostname";
    var href = "href";
    var password = "password";
    var pathname = "pathname";
    var port = "port";
    var protocol = "protocol";
    var search = "search";
    var username = "username";
    var isURL = (url, supportIncomplete) => {
      if (!isObject(url))
        return false;
      if (!hasToStringTag && toString.call(url) === urlClass)
        return true;
      if (!(href in url))
        return false;
      if (!(protocol in url))
        return false;
      if (!(username in url))
        return false;
      if (!(password in url))
        return false;
      if (!(hostname in url))
        return false;
      if (!(port in url))
        return false;
      if (!(host in url))
        return false;
      if (!(pathname in url))
        return false;
      if (!(search in url))
        return false;
      if (!(hash in url))
        return false;
      if (supportIncomplete !== true) {
        if (!isObject(url.searchParams))
          return false;
      }
      return true;
    };
    isURL.lenient = (url) => {
      return isURL(url, true);
    };
    module2.exports = isURL;
  }
});

// ../node_modules/p-cancelable/index.js
var require_p_cancelable2 = __commonJS({
  "../node_modules/p-cancelable/index.js"(exports2, module2) {
    "use strict";
    var CancelError = class extends Error {
      constructor() {
        super("Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class {
      static fn(userFn) {
        return function() {
          const args = [].slice.apply(arguments);
          return new PCancelable((resolve2, reject2, onCancel) => {
            args.push(onCancel);
            userFn.apply(null, args).then(resolve2, reject2);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._promise = new Promise((resolve2, reject2) => {
          this._reject = reject2;
          return executor((value) => {
            this._isPending = false;
            resolve2(value);
          }, (error) => {
            this._isPending = false;
            reject2(error);
          }, (handler) => {
            this._cancelHandlers.push(handler);
          });
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel() {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (err) {
            this._reject(err);
          }
        }
        this._isCanceled = true;
        this._reject(new CancelError());
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.CancelError = CancelError;
  }
});

// ../node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "../node_modules/p-finally/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then((val) => new Promise((resolve2) => {
        resolve2(onFinally());
      }).then(() => val), (err) => new Promise((resolve2) => {
        resolve2(onFinally());
      }).then(() => {
        throw err;
      }));
    };
  }
});

// ../node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "../node_modules/p-timeout/index.js"(exports2, module2) {
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    module2.exports = (promise, ms, fallback) => new Promise((resolve2, reject2) => {
      if (typeof ms !== "number" || ms < 0) {
        throw new TypeError("Expected `ms` to be a positive number");
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve2(fallback());
          } catch (err2) {
            reject2(err2);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${ms} milliseconds`;
        const err = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject2(err);
      }, ms);
      pFinally(promise.then(resolve2, reject2), () => {
        clearTimeout(timer);
      });
    });
    module2.exports.TimeoutError = TimeoutError;
  }
});

// ../node_modules/got/node_modules/pify/index.js
var require_pify4 = __commonJS({
  "../node_modules/got/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn, opts) => function() {
      const P = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return new P((resolve2, reject2) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i = 1; i < arguments.length; i++) {
                results[i - 1] = arguments[i];
              }
              if (err) {
                results.unshift(err);
                reject2(results);
              } else {
                resolve2(results);
              }
            } else if (err) {
              reject2(err);
            } else {
              resolve2(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i = 0; i < arguments.length; i++) {
                results[i] = arguments[i];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module2.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x = obj[key];
        ret[key] = typeof x === "function" && filter(key) ? processFn(x, opts) : x;
      }
      return ret;
    };
  }
});

// ../node_modules/got/package.json
var require_package4 = __commonJS({
  "../node_modules/got/package.json"(exports2, module2) {
    module2.exports = {
      name: "got",
      version: "8.3.2",
      description: "Simplified HTTP requests",
      license: "MIT",
      repository: "sindresorhus/got",
      maintainers: [
        {
          name: "Sindre Sorhus",
          email: "sindresorhus@gmail.com",
          url: "sindresorhus.com"
        },
        {
          name: "Vsevolod Strukchinsky",
          email: "floatdrop@gmail.com",
          url: "github.com/floatdrop"
        },
        {
          name: "Alexander Tesfamichael",
          email: "alex.tesfamichael@gmail.com",
          url: "alextes.me"
        }
      ],
      engines: {
        node: ">=4"
      },
      scripts: {
        test: "xo && nyc ava",
        coveralls: "nyc report --reporter=text-lcov | coveralls"
      },
      files: [
        "index.js",
        "errors.js"
      ],
      keywords: [
        "http",
        "https",
        "get",
        "got",
        "url",
        "uri",
        "request",
        "util",
        "utility",
        "simple",
        "curl",
        "wget",
        "fetch",
        "net",
        "network",
        "electron"
      ],
      dependencies: {
        "@sindresorhus/is": "^0.7.0",
        "cacheable-request": "^2.1.1",
        "decompress-response": "^3.3.0",
        duplexer3: "^0.1.4",
        "get-stream": "^3.0.0",
        "into-stream": "^3.1.0",
        "is-retry-allowed": "^1.1.0",
        isurl: "^1.0.0-alpha5",
        "lowercase-keys": "^1.0.0",
        "mimic-response": "^1.0.0",
        "p-cancelable": "^0.4.0",
        "p-timeout": "^2.0.1",
        pify: "^3.0.0",
        "safe-buffer": "^5.1.1",
        "timed-out": "^4.0.1",
        "url-parse-lax": "^3.0.0",
        "url-to-options": "^1.0.1"
      },
      devDependencies: {
        ava: "^0.25.0",
        coveralls: "^3.0.0",
        "form-data": "^2.1.1",
        "get-port": "^3.0.0",
        nyc: "^11.0.2",
        "p-event": "^1.3.0",
        pem: "^1.4.4",
        proxyquire: "^1.8.0",
        sinon: "^4.0.0",
        "slow-stream": "0.0.4",
        tempfile: "^2.0.0",
        tempy: "^0.2.1",
        "universal-url": "1.0.0-alpha",
        xo: "^0.20.0"
      },
      ava: {
        concurrency: 4
      },
      browser: {
        "decompress-response": false,
        electron: false
      }
    };
  }
});

// ../node_modules/got/errors.js
var require_errors4 = __commonJS({
  "../node_modules/got/errors.js"(exports2, module2) {
    "use strict";
    var urlLib = require("url");
    var http = require("http");
    var PCancelable = require_p_cancelable2();
    var is = require_dist3();
    var GotError = class extends Error {
      constructor(message, error, opts) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = "GotError";
        if (!is.undefined(error.code)) {
          this.code = error.code;
        }
        Object.assign(this, {
          host: opts.host,
          hostname: opts.hostname,
          method: opts.method,
          path: opts.path,
          protocol: opts.protocol,
          url: opts.href
        });
      }
    };
    module2.exports.GotError = GotError;
    module2.exports.CacheError = class extends GotError {
      constructor(error, opts) {
        super(error.message, error, opts);
        this.name = "CacheError";
      }
    };
    module2.exports.RequestError = class extends GotError {
      constructor(error, opts) {
        super(error.message, error, opts);
        this.name = "RequestError";
      }
    };
    module2.exports.ReadError = class extends GotError {
      constructor(error, opts) {
        super(error.message, error, opts);
        this.name = "ReadError";
      }
    };
    module2.exports.ParseError = class extends GotError {
      constructor(error, statusCode, opts, data) {
        super(`${error.message} in "${urlLib.format(opts)}": 
${data.slice(0, 77)}...`, error, opts);
        this.name = "ParseError";
        this.statusCode = statusCode;
        this.statusMessage = http.STATUS_CODES[this.statusCode];
      }
    };
    module2.exports.HTTPError = class extends GotError {
      constructor(statusCode, statusMessage, headers, opts) {
        if (statusMessage) {
          statusMessage = statusMessage.replace(/\r?\n/g, " ").trim();
        } else {
          statusMessage = http.STATUS_CODES[statusCode];
        }
        super(`Response code ${statusCode} (${statusMessage})`, {}, opts);
        this.name = "HTTPError";
        this.statusCode = statusCode;
        this.statusMessage = statusMessage;
        this.headers = headers;
      }
    };
    module2.exports.MaxRedirectsError = class extends GotError {
      constructor(statusCode, redirectUrls, opts) {
        super("Redirected 10 times. Aborting.", {}, opts);
        this.name = "MaxRedirectsError";
        this.statusCode = statusCode;
        this.statusMessage = http.STATUS_CODES[this.statusCode];
        this.redirectUrls = redirectUrls;
      }
    };
    module2.exports.UnsupportedProtocolError = class extends GotError {
      constructor(opts) {
        super(`Unsupported protocol "${opts.protocol}"`, {}, opts);
        this.name = "UnsupportedProtocolError";
      }
    };
    module2.exports.CancelError = PCancelable.CancelError;
  }
});

// ../node_modules/got/index.js
var require_got = __commonJS({
  "../node_modules/got/index.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var PassThrough = require("stream").PassThrough;
    var Transform2 = require("stream").Transform;
    var urlLib = require("url");
    var fs = require("fs");
    var querystring = require("querystring");
    var CacheableRequest = require_src6();
    var duplexer3 = require_duplexer3();
    var intoStream = require_into_stream();
    var is = require_dist3();
    var getStream = require_get_stream5();
    var timedOut = require_timed_out2();
    var urlParseLax = require_url_parse_lax();
    var urlToOptions = require_url_to_options2();
    var lowercaseKeys = require_lowercase_keys();
    var decompressResponse = require_decompress_response();
    var mimicResponse = require_mimic_response();
    var isRetryAllowed = require_is_retry_allowed();
    var isURL = require_isurl();
    var PCancelable = require_p_cancelable2();
    var pTimeout = require_p_timeout();
    var pify = require_pify4();
    var Buffer2 = require_safe_buffer2().Buffer;
    var pkg = require_package4();
    var errors = require_errors4();
    var getMethodRedirectCodes = new Set([300, 301, 302, 303, 304, 305, 307, 308]);
    var allMethodRedirectCodes = new Set([300, 303, 307, 308]);
    var isFormData = (body) => is.nodeStream(body) && is.function(body.getBoundary);
    var getBodySize = (opts) => {
      const body = opts.body;
      if (opts.headers["content-length"]) {
        return Number(opts.headers["content-length"]);
      }
      if (!body && !opts.stream) {
        return 0;
      }
      if (is.string(body)) {
        return Buffer2.byteLength(body);
      }
      if (isFormData(body)) {
        return pify(body.getLength.bind(body))();
      }
      if (body instanceof fs.ReadStream) {
        return pify(fs.stat)(body.path).then((stat) => stat.size);
      }
      if (is.nodeStream(body) && is.buffer(body._buffer)) {
        return body._buffer.length;
      }
      return null;
    };
    function requestAsEventEmitter(opts) {
      opts = opts || {};
      const ee = new EventEmitter();
      const requestUrl = opts.href || urlLib.resolve(urlLib.format(opts), opts.path);
      const redirects = [];
      const agents = is.object(opts.agent) ? opts.agent : null;
      let retryCount = 0;
      let redirectUrl;
      let uploadBodySize;
      let uploaded = 0;
      const get = (opts2) => {
        if (opts2.protocol !== "http:" && opts2.protocol !== "https:") {
          ee.emit("error", new got.UnsupportedProtocolError(opts2));
          return;
        }
        let fn = opts2.protocol === "https:" ? https : http;
        if (agents) {
          const protocolName = opts2.protocol === "https:" ? "https" : "http";
          opts2.agent = agents[protocolName] || opts2.agent;
        }
        if (opts2.useElectronNet && process.versions.electron) {
          const electron = require("electron");
          fn = electron.net || electron.remote.net;
        }
        let progressInterval;
        const cacheableRequest = new CacheableRequest(fn.request, opts2.cache);
        const cacheReq = cacheableRequest(opts2, (res) => {
          clearInterval(progressInterval);
          ee.emit("uploadProgress", {
            percent: 1,
            transferred: uploaded,
            total: uploadBodySize
          });
          const statusCode = res.statusCode;
          res.url = redirectUrl || requestUrl;
          res.requestUrl = requestUrl;
          const followRedirect = opts2.followRedirect && "location" in res.headers;
          const redirectGet = followRedirect && getMethodRedirectCodes.has(statusCode);
          const redirectAll = followRedirect && allMethodRedirectCodes.has(statusCode);
          if (redirectAll || redirectGet && (opts2.method === "GET" || opts2.method === "HEAD")) {
            res.resume();
            if (statusCode === 303) {
              opts2.method = "GET";
            }
            if (redirects.length >= 10) {
              ee.emit("error", new got.MaxRedirectsError(statusCode, redirects, opts2), null, res);
              return;
            }
            const bufferString = Buffer2.from(res.headers.location, "binary").toString();
            redirectUrl = urlLib.resolve(urlLib.format(opts2), bufferString);
            redirects.push(redirectUrl);
            const redirectOpts = Object.assign({}, opts2, urlLib.parse(redirectUrl));
            ee.emit("redirect", res, redirectOpts);
            get(redirectOpts);
            return;
          }
          setImmediate(() => {
            try {
              getResponse(res, opts2, ee, redirects);
            } catch (e) {
              ee.emit("error", e);
            }
          });
        });
        cacheReq.on("error", (err) => {
          if (err instanceof CacheableRequest.RequestError) {
            ee.emit("error", new got.RequestError(err, opts2));
          } else {
            ee.emit("error", new got.CacheError(err, opts2));
          }
        });
        cacheReq.once("request", (req) => {
          let aborted = false;
          req.once("abort", (_2) => {
            aborted = true;
          });
          req.once("error", (err) => {
            clearInterval(progressInterval);
            if (aborted) {
              return;
            }
            const backoff = opts2.retries(++retryCount, err);
            if (backoff) {
              setTimeout(get, backoff, opts2);
              return;
            }
            ee.emit("error", new got.RequestError(err, opts2));
          });
          ee.once("request", (req2) => {
            ee.emit("uploadProgress", {
              percent: 0,
              transferred: 0,
              total: uploadBodySize
            });
            const socket = req2.connection;
            if (socket) {
              const isConnecting = socket.connecting === void 0 ? socket._connecting : socket.connecting;
              const onSocketConnect = () => {
                const uploadEventFrequency = 150;
                progressInterval = setInterval(() => {
                  if (socket.destroyed) {
                    clearInterval(progressInterval);
                    return;
                  }
                  const lastUploaded = uploaded;
                  const headersSize = req2._header ? Buffer2.byteLength(req2._header) : 0;
                  uploaded = socket.bytesWritten - headersSize;
                  if (uploadBodySize && uploaded > uploadBodySize) {
                    uploaded = uploadBodySize;
                  }
                  if (uploaded === lastUploaded || uploaded === uploadBodySize) {
                    return;
                  }
                  ee.emit("uploadProgress", {
                    percent: uploadBodySize ? uploaded / uploadBodySize : 0,
                    transferred: uploaded,
                    total: uploadBodySize
                  });
                }, uploadEventFrequency);
              };
              if (isConnecting) {
                socket.once("connect", onSocketConnect);
              } else {
                onSocketConnect();
              }
            }
          });
          if (opts2.gotTimeout) {
            clearInterval(progressInterval);
            timedOut(req, opts2.gotTimeout);
          }
          setImmediate(() => {
            ee.emit("request", req);
          });
        });
      };
      setImmediate(() => {
        Promise.resolve(getBodySize(opts)).then((size) => {
          uploadBodySize = size;
          if (is.undefined(opts.headers["content-length"]) && is.undefined(opts.headers["transfer-encoding"]) && isFormData(opts.body)) {
            opts.headers["content-length"] = size;
          }
          get(opts);
        }).catch((err) => {
          ee.emit("error", err);
        });
      });
      return ee;
    }
    function getResponse(res, opts, ee, redirects) {
      const downloadBodySize = Number(res.headers["content-length"]) || null;
      let downloaded = 0;
      const progressStream = new Transform2({
        transform(chunk, encoding, callback) {
          downloaded += chunk.length;
          const percent = downloadBodySize ? downloaded / downloadBodySize : 0;
          if (percent < 1) {
            ee.emit("downloadProgress", {
              percent,
              transferred: downloaded,
              total: downloadBodySize
            });
          }
          callback(null, chunk);
        },
        flush(callback) {
          ee.emit("downloadProgress", {
            percent: 1,
            transferred: downloaded,
            total: downloadBodySize
          });
          callback();
        }
      });
      mimicResponse(res, progressStream);
      progressStream.redirectUrls = redirects;
      const response = opts.decompress === true && is.function(decompressResponse) && opts.method !== "HEAD" ? decompressResponse(progressStream) : progressStream;
      if (!opts.decompress && ["gzip", "deflate"].indexOf(res.headers["content-encoding"]) !== -1) {
        opts.encoding = null;
      }
      ee.emit("response", response);
      ee.emit("downloadProgress", {
        percent: 0,
        transferred: 0,
        total: downloadBodySize
      });
      res.pipe(progressStream);
    }
    function asPromise(opts) {
      const timeoutFn = (requestPromise) => opts.gotTimeout && opts.gotTimeout.request ? pTimeout(requestPromise, opts.gotTimeout.request, new got.RequestError({ message: "Request timed out", code: "ETIMEDOUT" }, opts)) : requestPromise;
      const proxy = new EventEmitter();
      const cancelable = new PCancelable((resolve2, reject2, onCancel) => {
        const ee = requestAsEventEmitter(opts);
        let cancelOnRequest = false;
        onCancel(() => {
          cancelOnRequest = true;
        });
        ee.on("request", (req) => {
          if (cancelOnRequest) {
            req.abort();
          }
          onCancel(() => {
            req.abort();
          });
          if (is.nodeStream(opts.body)) {
            opts.body.pipe(req);
            opts.body = void 0;
            return;
          }
          req.end(opts.body);
        });
        ee.on("response", (res) => {
          const stream2 = is.null(opts.encoding) ? getStream.buffer(res) : getStream(res, opts);
          stream2.catch((err) => reject2(new got.ReadError(err, opts))).then((data) => {
            const statusCode = res.statusCode;
            const limitStatusCode = opts.followRedirect ? 299 : 399;
            res.body = data;
            if (opts.json && res.body) {
              try {
                res.body = JSON.parse(res.body);
              } catch (err) {
                if (statusCode >= 200 && statusCode < 300) {
                  throw new got.ParseError(err, statusCode, opts, data);
                }
              }
            }
            if (opts.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > limitStatusCode)) {
              throw new got.HTTPError(statusCode, res.statusMessage, res.headers, opts);
            }
            resolve2(res);
          }).catch((err) => {
            Object.defineProperty(err, "response", { value: res });
            reject2(err);
          });
        });
        ee.once("error", reject2);
        ee.on("redirect", proxy.emit.bind(proxy, "redirect"));
        ee.on("uploadProgress", proxy.emit.bind(proxy, "uploadProgress"));
        ee.on("downloadProgress", proxy.emit.bind(proxy, "downloadProgress"));
      });
      Object.defineProperty(cancelable, "canceled", {
        get() {
          return cancelable.isCanceled;
        }
      });
      const promise = timeoutFn(cancelable);
      promise.cancel = cancelable.cancel.bind(cancelable);
      promise.on = (name, fn) => {
        proxy.on(name, fn);
        return promise;
      };
      return promise;
    }
    function asStream(opts) {
      opts.stream = true;
      const input = new PassThrough();
      const output = new PassThrough();
      const proxy = duplexer3(input, output);
      let timeout;
      if (opts.gotTimeout && opts.gotTimeout.request) {
        timeout = setTimeout(() => {
          proxy.emit("error", new got.RequestError({ message: "Request timed out", code: "ETIMEDOUT" }, opts));
        }, opts.gotTimeout.request);
      }
      if (opts.json) {
        throw new Error("Got can not be used as a stream when the `json` option is used");
      }
      if (opts.body) {
        proxy.write = () => {
          throw new Error("Got's stream is not writable when the `body` option is used");
        };
      }
      const ee = requestAsEventEmitter(opts);
      ee.on("request", (req) => {
        proxy.emit("request", req);
        if (is.nodeStream(opts.body)) {
          opts.body.pipe(req);
          return;
        }
        if (opts.body) {
          req.end(opts.body);
          return;
        }
        if (opts.method === "POST" || opts.method === "PUT" || opts.method === "PATCH") {
          input.pipe(req);
          return;
        }
        req.end();
      });
      ee.on("response", (res) => {
        clearTimeout(timeout);
        const statusCode = res.statusCode;
        res.on("error", (err) => {
          proxy.emit("error", new got.ReadError(err, opts));
        });
        res.pipe(output);
        if (opts.throwHttpErrors && statusCode !== 304 && (statusCode < 200 || statusCode > 299)) {
          proxy.emit("error", new got.HTTPError(statusCode, res.statusMessage, res.headers, opts), null, res);
          return;
        }
        proxy.emit("response", res);
      });
      ee.on("error", proxy.emit.bind(proxy, "error"));
      ee.on("redirect", proxy.emit.bind(proxy, "redirect"));
      ee.on("uploadProgress", proxy.emit.bind(proxy, "uploadProgress"));
      ee.on("downloadProgress", proxy.emit.bind(proxy, "downloadProgress"));
      return proxy;
    }
    function normalizeArguments(url, opts) {
      if (!is.string(url) && !is.object(url)) {
        throw new TypeError(`Parameter \`url\` must be a string or object, not ${is(url)}`);
      } else if (is.string(url)) {
        url = url.replace(/^unix:/, "http://$&");
        try {
          decodeURI(url);
        } catch (err) {
          throw new Error("Parameter `url` must contain valid UTF-8 character sequences");
        }
        url = urlParseLax(url);
        if (url.auth) {
          throw new Error("Basic authentication must be done with the `auth` option");
        }
      } else if (isURL.lenient(url)) {
        url = urlToOptions(url);
      }
      opts = Object.assign({
        path: "",
        retries: 2,
        cache: false,
        decompress: true,
        useElectronNet: false,
        throwHttpErrors: true
      }, url, {
        protocol: url.protocol || "http:"
      }, opts);
      const headers = lowercaseKeys(opts.headers);
      for (const key of Object.keys(headers)) {
        if (is.nullOrUndefined(headers[key])) {
          delete headers[key];
        }
      }
      opts.headers = Object.assign({
        "user-agent": `${pkg.name}/${pkg.version} (https://github.com/sindresorhus/got)`
      }, headers);
      if (opts.decompress && is.undefined(opts.headers["accept-encoding"])) {
        opts.headers["accept-encoding"] = "gzip, deflate";
      }
      const query = opts.query;
      if (query) {
        if (!is.string(query)) {
          opts.query = querystring.stringify(query);
        }
        opts.path = `${opts.path.split("?")[0]}?${opts.query}`;
        delete opts.query;
      }
      if (opts.json && is.undefined(opts.headers.accept)) {
        opts.headers.accept = "application/json";
      }
      const body = opts.body;
      if (is.nullOrUndefined(body)) {
        opts.method = (opts.method || "GET").toUpperCase();
      } else {
        const headers2 = opts.headers;
        if (!is.nodeStream(body) && !is.string(body) && !is.buffer(body) && !(opts.form || opts.json)) {
          throw new TypeError("The `body` option must be a stream.Readable, string, Buffer or plain Object");
        }
        const canBodyBeStringified = is.plainObject(body) || is.array(body);
        if ((opts.form || opts.json) && !canBodyBeStringified) {
          throw new TypeError("The `body` option must be a plain Object or Array when the `form` or `json` option is used");
        }
        if (isFormData(body)) {
          headers2["content-type"] = headers2["content-type"] || `multipart/form-data; boundary=${body.getBoundary()}`;
        } else if (opts.form && canBodyBeStringified) {
          headers2["content-type"] = headers2["content-type"] || "application/x-www-form-urlencoded";
          opts.body = querystring.stringify(body);
        } else if (opts.json && canBodyBeStringified) {
          headers2["content-type"] = headers2["content-type"] || "application/json";
          opts.body = JSON.stringify(body);
        }
        if (is.undefined(headers2["content-length"]) && is.undefined(headers2["transfer-encoding"]) && !is.nodeStream(body)) {
          const length = is.string(opts.body) ? Buffer2.byteLength(opts.body) : opts.body.length;
          headers2["content-length"] = length;
        }
        if (is.buffer(body)) {
          opts.body = intoStream(body);
          opts.body._buffer = body;
        }
        opts.method = (opts.method || "POST").toUpperCase();
      }
      if (opts.hostname === "unix") {
        const matches = /(.+?):(.+)/.exec(opts.path);
        if (matches) {
          opts.socketPath = matches[1];
          opts.path = matches[2];
          opts.host = null;
        }
      }
      if (!is.function(opts.retries)) {
        const retries = opts.retries;
        opts.retries = (iter, err) => {
          if (iter > retries || !isRetryAllowed(err)) {
            return 0;
          }
          const noise = Math.random() * 100;
          return (1 << iter) * 1e3 + noise;
        };
      }
      if (is.undefined(opts.followRedirect)) {
        opts.followRedirect = true;
      }
      if (opts.timeout) {
        if (is.number(opts.timeout)) {
          opts.gotTimeout = { request: opts.timeout };
        } else {
          opts.gotTimeout = opts.timeout;
        }
        delete opts.timeout;
      }
      return opts;
    }
    function got(url, opts) {
      try {
        const normalizedArgs = normalizeArguments(url, opts);
        if (normalizedArgs.stream) {
          return asStream(normalizedArgs);
        }
        return asPromise(normalizedArgs);
      } catch (err) {
        return Promise.reject(err);
      }
    }
    got.stream = (url, opts) => asStream(normalizeArguments(url, opts));
    var methods = [
      "get",
      "post",
      "put",
      "patch",
      "head",
      "delete"
    ];
    for (const method of methods) {
      got[method] = (url, opts) => got(url, Object.assign({}, opts, { method }));
      got.stream[method] = (url, opts) => got.stream(url, Object.assign({}, opts, { method }));
    }
    Object.assign(got, errors);
    module2.exports = got;
  }
});

// ../node_modules/pify/index.js
var require_pify5 = __commonJS({
  "../node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn, options) => function(...args) {
      const P = options.promiseModule;
      return new P((resolve2, reject2) => {
        if (options.multiArgs) {
          args.push((...result) => {
            if (options.errorFirst) {
              if (result[0]) {
                reject2(result);
              } else {
                result.shift();
                resolve2(result);
              }
            } else {
              resolve2(result);
            }
          });
        } else if (options.errorFirst) {
          args.push((error, result) => {
            if (error) {
              reject2(error);
            } else {
              resolve2(result);
            }
          });
        } else {
          args.push(resolve2);
        }
        fn.apply(this, args);
      });
    };
    module2.exports = (input, options) => {
      options = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, options);
      const objType = typeof input;
      if (!(input !== null && (objType === "object" || objType === "function"))) {
        throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${input === null ? "null" : objType}\``);
      }
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return options.include ? options.include.some(match) : !options.exclude.some(match);
      };
      let ret;
      if (objType === "function") {
        ret = function(...args) {
          return options.excludeMain ? input(...args) : processFn(input, options).apply(this, args);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(input));
      }
      for (const key in input) {
        const property = input[key];
        ret[key] = typeof property === "function" && filter(key) ? processFn(property, options) : property;
      }
      return ret;
    };
  }
});

// ../node_modules/make-dir/index.js
var require_make_dir3 = __commonJS({
  "../node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var pify = require_pify5();
    var semver = require_semver();
    var defaults = {
      mode: 511 & ~process.umask(),
      fs
    };
    var useNativeRecursiveOption = semver.satisfies(process.version, ">=10.12.0");
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
    var permissionError = (pth) => {
      const error = new Error(`operation not permitted, mkdir '${pth}'`);
      error.code = "EPERM";
      error.errno = -4048;
      error.path = pth;
      error.syscall = "mkdir";
      return error;
    };
    var makeDir = (input, options) => Promise.resolve().then(() => {
      checkPath(input);
      options = Object.assign({}, defaults, options);
      const mkdir = pify(options.fs.mkdir);
      const stat = pify(options.fs.stat);
      if (useNativeRecursiveOption && options.fs.mkdir === fs.mkdir) {
        const pth = path.resolve(input);
        return mkdir(pth, {
          mode: options.mode,
          recursive: true
        }).then(() => pth);
      }
      const make = (pth) => {
        return mkdir(pth, options.mode).then(() => pth).catch((error) => {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            return make(path.dirname(pth)).then(() => make(pth));
          }
          return stat(pth).then((stats) => stats.isDirectory() ? pth : Promise.reject()).catch(() => {
            throw error;
          });
        });
      };
      return make(path.resolve(input));
    });
    module2.exports = makeDir;
    module2.exports.default = makeDir;
    module2.exports.sync = (input, options) => {
      checkPath(input);
      options = Object.assign({}, defaults, options);
      if (useNativeRecursiveOption && options.fs.mkdirSync === fs.mkdirSync) {
        const pth = path.resolve(input);
        fs.mkdirSync(pth, {
          mode: options.mode,
          recursive: true
        });
        return pth;
      }
      const make = (pth) => {
        try {
          options.fs.mkdirSync(pth, options.mode);
        } catch (error) {
          if (error.code === "EPERM") {
            throw error;
          }
          if (error.code === "ENOENT") {
            if (path.dirname(pth) === pth) {
              throw permissionError(pth);
            }
            if (error.message.includes("null bytes")) {
              throw error;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!options.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_2) {
            throw error;
          }
        }
        return pth;
      };
      return make(path.resolve(input));
    };
  }
});

// ../node_modules/p-event/index.js
var require_p_event = __commonJS({
  "../node_modules/p-event/index.js"(exports2, module2) {
    "use strict";
    var pTimeout = require_p_timeout();
    var symbolAsyncIterator = Symbol.asyncIterator || "@@asyncIterator";
    var normalizeEmitter = (emitter) => {
      const addListener = emitter.on || emitter.addListener || emitter.addEventListener;
      const removeListener = emitter.off || emitter.removeListener || emitter.removeEventListener;
      if (!addListener || !removeListener) {
        throw new TypeError("Emitter is not compatible");
      }
      return {
        addListener: addListener.bind(emitter),
        removeListener: removeListener.bind(emitter)
      };
    };
    var normalizeEvents = (event) => Array.isArray(event) ? event : [event];
    var multiple = (emitter, event, options) => {
      let cancel;
      const ret = new Promise((resolve2, reject2) => {
        options = Object.assign({
          rejectionEvents: ["error"],
          multiArgs: false,
          resolveImmediately: false
        }, options);
        if (!(options.count >= 0 && (options.count === Infinity || Number.isInteger(options.count)))) {
          throw new TypeError("The `count` option should be at least 0 or more");
        }
        const events = normalizeEvents(event);
        const items = [];
        const { addListener, removeListener } = normalizeEmitter(emitter);
        const onItem = (...args) => {
          const value = options.multiArgs ? args : args[0];
          if (options.filter && !options.filter(value)) {
            return;
          }
          items.push(value);
          if (options.count === items.length) {
            cancel();
            resolve2(items);
          }
        };
        const rejectHandler = (error) => {
          cancel();
          reject2(error);
        };
        cancel = () => {
          for (const event2 of events) {
            removeListener(event2, onItem);
          }
          for (const rejectionEvent of options.rejectionEvents) {
            removeListener(rejectionEvent, rejectHandler);
          }
        };
        for (const event2 of events) {
          addListener(event2, onItem);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          addListener(rejectionEvent, rejectHandler);
        }
        if (options.resolveImmediately) {
          resolve2(items);
        }
      });
      ret.cancel = cancel;
      if (typeof options.timeout === "number") {
        const timeout = pTimeout(ret, options.timeout);
        timeout.cancel = cancel;
        return timeout;
      }
      return ret;
    };
    module2.exports = (emitter, event, options) => {
      if (typeof options === "function") {
        options = { filter: options };
      }
      options = Object.assign({}, options, {
        count: 1,
        resolveImmediately: false
      });
      const arrayPromise = multiple(emitter, event, options);
      const promise = arrayPromise.then((array) => array[0]);
      promise.cancel = arrayPromise.cancel;
      return promise;
    };
    module2.exports.multiple = multiple;
    module2.exports.iterator = (emitter, event, options) => {
      if (typeof options === "function") {
        options = { filter: options };
      }
      const events = normalizeEvents(event);
      options = Object.assign({
        rejectionEvents: ["error"],
        resolutionEvents: [],
        limit: Infinity,
        multiArgs: false
      }, options);
      const { limit } = options;
      const isValidLimit = limit >= 0 && (limit === Infinity || Number.isInteger(limit));
      if (!isValidLimit) {
        throw new TypeError("The `limit` option should be a non-negative integer or Infinity");
      }
      if (limit === 0) {
        return {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return Promise.resolve({ done: true, value: void 0 });
          }
        };
      }
      let isLimitReached = false;
      const { addListener, removeListener } = normalizeEmitter(emitter);
      let done = false;
      let error;
      let hasPendingError = false;
      const nextQueue = [];
      const valueQueue = [];
      let eventCount = 0;
      const valueHandler = (...args) => {
        eventCount++;
        isLimitReached = eventCount === limit;
        const value = options.multiArgs ? args : args[0];
        if (nextQueue.length > 0) {
          const { resolve: resolve2 } = nextQueue.shift();
          resolve2({ done: false, value });
          if (isLimitReached) {
            cancel();
          }
          return;
        }
        valueQueue.push(value);
        if (isLimitReached) {
          cancel();
        }
      };
      const cancel = () => {
        done = true;
        for (const event2 of events) {
          removeListener(event2, valueHandler);
        }
        for (const rejectionEvent of options.rejectionEvents) {
          removeListener(rejectionEvent, rejectHandler);
        }
        for (const resolutionEvent of options.resolutionEvents) {
          removeListener(resolutionEvent, resolveHandler);
        }
        while (nextQueue.length > 0) {
          const { resolve: resolve2 } = nextQueue.shift();
          resolve2({ done: true, value: void 0 });
        }
      };
      const rejectHandler = (...args) => {
        error = options.multiArgs ? args : args[0];
        if (nextQueue.length > 0) {
          const { reject: reject2 } = nextQueue.shift();
          reject2(error);
        } else {
          hasPendingError = true;
        }
        cancel();
      };
      const resolveHandler = (...args) => {
        const value = options.multiArgs ? args : args[0];
        if (options.filter && !options.filter(value)) {
          return;
        }
        if (nextQueue.length > 0) {
          const { resolve: resolve2 } = nextQueue.shift();
          resolve2({ done: true, value });
        } else {
          valueQueue.push(value);
        }
        cancel();
      };
      for (const event2 of events) {
        addListener(event2, valueHandler);
      }
      for (const rejectionEvent of options.rejectionEvents) {
        addListener(rejectionEvent, rejectHandler);
      }
      for (const resolutionEvent of options.resolutionEvents) {
        addListener(resolutionEvent, resolveHandler);
      }
      return {
        [symbolAsyncIterator]() {
          return this;
        },
        next() {
          if (valueQueue.length > 0) {
            const value = valueQueue.shift();
            return Promise.resolve({ done: done && valueQueue.length === 0 && !isLimitReached, value });
          }
          if (hasPendingError) {
            hasPendingError = false;
            return Promise.reject(error);
          }
          if (done) {
            return Promise.resolve({ done: true, value: void 0 });
          }
          return new Promise((resolve2, reject2) => nextQueue.push({ resolve: resolve2, reject: reject2 }));
        },
        return(value) {
          cancel();
          return Promise.resolve({ done, value });
        }
      };
    };
  }
});

// ../node_modules/file-type/util.js
var require_util4 = __commonJS({
  "../node_modules/file-type/util.js"(exports2) {
    "use strict";
    exports2.stringToBytes = (string) => [...string].map((character) => character.charCodeAt(0));
    var uint8ArrayUtf8ByteString2 = (array, start, end) => {
      return String.fromCharCode(...array.slice(start, end));
    };
    exports2.readUInt64LE = (buffer, offset = 0) => {
      let n = buffer[offset];
      let mul = 1;
      let i = 0;
      while (++i < 8) {
        mul *= 256;
        n += buffer[offset + i] * mul;
      }
      return n;
    };
    exports2.tarHeaderChecksumMatches = (buffer) => {
      if (buffer.length < 512) {
        return false;
      }
      const MASK_8TH_BIT = 128;
      let sum = 256;
      let signedBitSum = 0;
      for (let i = 0; i < 148; i++) {
        const byte = buffer[i];
        sum += byte;
        signedBitSum += byte & MASK_8TH_BIT;
      }
      for (let i = 156; i < 512; i++) {
        const byte = buffer[i];
        sum += byte;
        signedBitSum += byte & MASK_8TH_BIT;
      }
      const readSum = parseInt(uint8ArrayUtf8ByteString2(buffer, 148, 154), 8);
      return readSum === sum || readSum === sum - (signedBitSum << 1);
    };
    exports2.uint8ArrayUtf8ByteString = uint8ArrayUtf8ByteString2;
  }
});

// ../node_modules/file-type/index.js
var require_file_type6 = __commonJS({
  "../node_modules/file-type/index.js"(exports, module) {
    "use strict";
    var { stringToBytes, readUInt64LE, tarHeaderChecksumMatches, uint8ArrayUtf8ByteString } = require_util4();
    var xpiZipFilename = stringToBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes = stringToBytes("[Content_Types].xml");
    var oxmlRels = stringToBytes("_rels/.rels");
    var fileType = (input) => {
      if (!(input instanceof Uint8Array || input instanceof ArrayBuffer || Buffer.isBuffer(input))) {
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof input}\``);
      }
      const buffer = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buffer && buffer.length > 1)) {
        return;
      }
      const check = (header, options) => {
        options = Object.assign({
          offset: 0
        }, options);
        for (let i = 0; i < header.length; i++) {
          if (options.mask) {
            if (header[i] !== (options.mask[i] & buffer[i + options.offset])) {
              return false;
            }
          } else if (header[i] !== buffer[i + options.offset]) {
            return false;
          }
        }
        return true;
      };
      const checkString = (header, options) => check(stringToBytes(header), options);
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 82, 79, 8, 0, 0, 0, 24])) {
        return {
          ext: "orf",
          mime: "image/x-olympus-orf"
        };
      }
      if (check([73, 73, 42, 0, 16, 251, 134, 1])) {
        return {
          ext: "arw",
          mime: "image/x-sony-arw"
        };
      }
      if (check([73, 73, 42, 0, 8, 0, 0, 0, 45])) {
        return {
          ext: "dng",
          mime: "image/x-adobe-dng"
        };
      }
      if (check([73, 73, 42, 0, 48, 61, 114, 1, 28])) {
        return {
          ext: "nef",
          mime: "image/x-nikon-nef"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        }
        const findNextZipHeaderIndex = (arr, startAt = 0) => arr.findIndex((el, i, arr2) => i >= startAt && arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
        let zipHeaderIndex = 0;
        let oxmlFound = false;
        let type;
        do {
          const offset = zipHeaderIndex + 30;
          if (!oxmlFound) {
            oxmlFound = check(oxmlContentTypes, { offset }) || check(oxmlRels, { offset });
          }
          if (!type) {
            if (checkString("word/", { offset })) {
              type = {
                ext: "docx",
                mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
              };
            } else if (checkString("ppt/", { offset })) {
              type = {
                ext: "pptx",
                mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
              };
            } else if (checkString("xl/", { offset })) {
              type = {
                ext: "xlsx",
                mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
              };
            }
          }
          if (oxmlFound && type) {
            return type;
          }
          zipHeaderIndex = findNextZipHeaderIndex(buffer, offset);
        } while (zipHeaderIndex >= 0);
        if (type) {
          return type;
        }
      }
      if (check([80, 75]) && (buffer[2] === 3 || buffer[2] === 5 || buffer[2] === 7) && (buffer[3] === 4 || buffer[3] === 6 || buffer[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([48, 48, 48, 48, 48, 48], { offset: 148, mask: [248, 248, 248, 248, 248, 248] }) && tarHeaderChecksumMatches(buffer)) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buffer[6] === 0 || buffer[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([102, 114, 101, 101], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([109, 111, 111, 118], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([102, 116, 121, 112], { offset: 4 }) && (buffer[8] & 96) !== 0 && (buffer[9] & 96) !== 0 && (buffer[10] & 96) !== 0 && (buffer[11] & 96) !== 0) {
        const brandMajor = uint8ArrayUtf8ByteString(buffer, 8, 12);
        switch (brandMajor) {
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt  ":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V ":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P ":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B ":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A ":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V ":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P ":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A ":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B ":
            return { ext: "f4b", mime: "audio/mp4" };
          default:
            if (brandMajor.startsWith("3g")) {
              if (brandMajor.startsWith("3g2")) {
                return { ext: "3g2", mime: "video/3gpp2" };
              }
              return { ext: "3gp", mime: "video/3gpp" };
            }
            return { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buffer.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/vnd.avi"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/vnd.wave"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        let offset = 30;
        do {
          const objectSize = readUInt64LE(buffer, offset + 16);
          if (check([145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101], { offset })) {
            if (check([64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wma",
                mime: "audio/x-ms-wma"
              };
            }
            if (check([192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43], { offset: offset + 24 })) {
              return {
                ext: "wmv",
                mime: "video/x-ms-asf"
              };
            }
            break;
          }
          offset += objectSize;
        } while (offset + 24 <= buffer.length);
        return {
          ext: "asf",
          mime: "application/vnd.ms-asf"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      for (let start = 0; start < 2 && start < buffer.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || check([255, 226], { offset: start, mask: [255, 230] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 228], { offset: start, mask: [255, 230] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 248], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 240], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (check([127, 70, 76, 65, 67], { offset: 28 })) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([77, 65, 67, 32])) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([119, 118, 112, 107])) {
        return {
          ext: "wv",
          mime: "audio/wavpack"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buffer[0] === 67 || buffer[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/vnd.ms-fontobject"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (check([106, 112, 50, 32], { offset: 20 })) {
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        }
        if (check([106, 112, 120, 32], { offset: 20 })) {
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        }
        if (check([106, 112, 109, 32], { offset: 20 })) {
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        }
        if (check([109, 106, 112, 50], { offset: 20 })) {
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        }
      }
      if (check([70, 79, 82, 77])) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      if (check([68, 73, 67, 77], { offset: 128 })) {
        return {
          ext: "dcm",
          mime: "application/dicom"
        };
      }
      if (check([77, 80, 43])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([77, 80, 67, 75])) {
        return {
          ext: "mpc",
          mime: "audio/x-musepack"
        };
      }
      if (check([66, 69, 71, 73, 78, 58])) {
        return {
          ext: "ics",
          mime: "text/calendar"
        };
      }
      if (check([103, 108, 84, 70, 2, 0, 0, 0])) {
        return {
          ext: "glb",
          mime: "model/gltf-binary"
        };
      }
      if (check([212, 195, 178, 161]) || check([161, 178, 195, 212])) {
        return {
          ext: "pcap",
          mime: "application/vnd.tcpdump.pcap"
        };
      }
      if (check([68, 83, 68, 32])) {
        return {
          ext: "dsf",
          mime: "audio/x-dsf"
        };
      }
      if (check([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70])) {
        return {
          ext: "lnk",
          mime: "application/x.ms.shortcut"
        };
      }
      if (check([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0])) {
        return {
          ext: "alias",
          mime: "application/x.apple.alias"
        };
      }
      if (checkString("Creative Voice File")) {
        return {
          ext: "voc",
          mime: "audio/x-voc"
        };
      }
      if (check([11, 119])) {
        return {
          ext: "ac3",
          mime: "audio/vnd.dolby.dd-raw"
        };
      }
    };
    module.exports = fileType;
    Object.defineProperty(fileType, "minimumBytes", { value: 4100 });
    fileType.stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.once("readable", () => {
        const pass = new stream.PassThrough();
        const chunk = readableStream.read(module.exports.minimumBytes) || readableStream.read();
        try {
          pass.fileType = fileType(chunk);
        } catch (error) {
          reject(error);
        }
        readableStream.unshift(chunk);
        if (stream.pipeline) {
          resolve(stream.pipeline(readableStream, pass, () => {
          }));
        } else {
          resolve(readableStream.pipe(pass));
        }
      });
    });
  }
});

// ../node_modules/mime-db/db.json
var require_db = __commonJS({
  "../node_modules/mime-db/db.json"(exports2, module2) {
    module2.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana"
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana"
      },
      "image/avcs": {
        source: "iana"
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// ../node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "../node_modules/mime-db/index.js"(exports2, module2) {
    module2.exports = require_db();
  }
});

// ../node_modules/ext-list/index.js
var require_ext_list = __commonJS({
  "../node_modules/ext-list/index.js"(exports2, module2) {
    "use strict";
    var mimeDb = require_mime_db();
    module2.exports = function() {
      var ret = {};
      Object.keys(mimeDb).forEach(function(x) {
        var val = mimeDb[x];
        if (val.extensions && val.extensions.length > 0) {
          val.extensions.forEach(function(y) {
            ret[y] = x;
          });
        }
      });
      return ret;
    };
  }
});

// ../node_modules/sort-keys-length/node_modules/sort-keys/index.js
var require_sort_keys2 = __commonJS({
  "../node_modules/sort-keys-length/node_modules/sort-keys/index.js"(exports2, module2) {
    "use strict";
    var isPlainObj = require_is_plain_obj();
    module2.exports = function(obj, opts) {
      if (!isPlainObj(obj)) {
        throw new TypeError("Expected a plain object");
      }
      opts = opts || {};
      if (typeof opts === "function") {
        opts = { compare: opts };
      }
      var deep = opts.deep;
      var seenInput = [];
      var seenOutput = [];
      var sortKeys = function(x) {
        var seenIndex = seenInput.indexOf(x);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        var ret = {};
        var keys = Object.keys(x).sort(opts.compare);
        seenInput.push(x);
        seenOutput.push(ret);
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var val = x[key];
          ret[key] = deep && isPlainObj(val) ? sortKeys(val) : val;
        }
        return ret;
      };
      return sortKeys(obj);
    };
  }
});

// ../node_modules/sort-keys-length/index.js
var require_sort_keys_length = __commonJS({
  "../node_modules/sort-keys-length/index.js"(exports2, module2) {
    "use strict";
    var sortKeys = require_sort_keys2();
    module2.exports.desc = function(obj) {
      return sortKeys(obj, function(a, b) {
        return b.length - a.length;
      });
    };
    module2.exports.asc = function(obj) {
      return sortKeys(obj, function(a, b) {
        return a.length - b.length;
      });
    };
  }
});

// ../node_modules/ext-name/index.js
var require_ext_name = __commonJS({
  "../node_modules/ext-name/index.js"(exports2, module2) {
    "use strict";
    var extList = require_ext_list();
    var sortKeysLength = require_sort_keys_length();
    module2.exports = (str) => {
      const obj = sortKeysLength.desc(extList());
      const exts = Object.keys(obj).filter((x) => str.endsWith(x));
      if (exts.length === 0) {
        return [];
      }
      return exts.map((x) => ({
        ext: x,
        mime: obj[x]
      }));
    };
    module2.exports.mime = (str) => {
      const obj = sortKeysLength.desc(extList());
      const exts = Object.keys(obj).filter((x) => obj[x] === str);
      if (exts.length === 0) {
        return [];
      }
      return exts.map((x) => ({
        ext: x,
        mime: obj[x]
      }));
    };
  }
});

// ../node_modules/download/index.js
var require_download = __commonJS({
  "../node_modules/download/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var { URL: URL2 } = require("url");
    var contentDisposition = require_content_disposition();
    var archiveType = require_archive_type();
    var decompress = require_decompress();
    var filenamify = require_filenamify();
    var getStream = require_get_stream2();
    var got = require_got();
    var makeDir = require_make_dir3();
    var pify = require_pify5();
    var pEvent = require_p_event();
    var fileType2 = require_file_type6();
    var extName = require_ext_name();
    var fsP = pify(fs);
    var filenameFromPath = (res) => path.basename(new URL2(res.requestUrl).pathname);
    var getExtFromMime = (res) => {
      const header = res.headers["content-type"];
      if (!header) {
        return null;
      }
      const exts = extName.mime(header);
      if (exts.length !== 1) {
        return null;
      }
      return exts[0].ext;
    };
    var getFilename = (res, data) => {
      const header = res.headers["content-disposition"];
      if (header) {
        const parsed = contentDisposition.parse(header);
        if (parsed.parameters && parsed.parameters.filename) {
          return parsed.parameters.filename;
        }
      }
      let filename = filenameFromPath(res);
      if (!path.extname(filename)) {
        const ext = (fileType2(data) || {}).ext || getExtFromMime(res);
        if (ext) {
          filename = `${filename}.${ext}`;
        }
      }
      return filename;
    };
    module2.exports = (uri, output, opts) => {
      if (typeof output === "object") {
        opts = output;
        output = null;
      }
      opts = Object.assign({
        encoding: null,
        rejectUnauthorized: process.env.npm_config_strict_ssl !== "false"
      }, opts);
      const stream2 = got.stream(uri, opts);
      const promise = pEvent(stream2, "response").then((res) => {
        const encoding = opts.encoding === null ? "buffer" : opts.encoding;
        return Promise.all([getStream(stream2, { encoding }), res]);
      }).then((result) => {
        const [data, res] = result;
        if (!output) {
          return opts.extract && archiveType(data) ? decompress(data, opts) : data;
        }
        const filename = opts.filename || filenamify(getFilename(res, data));
        const outputFilepath = path.join(output, filename);
        if (opts.extract && archiveType(data)) {
          return decompress(data, path.dirname(outputFilepath), opts);
        }
        return makeDir(path.dirname(outputFilepath)).then(() => fsP.writeFile(outputFilepath, data)).then(() => data);
      });
      stream2.then = promise.then.bind(promise);
      stream2.catch = promise.catch.bind(promise);
      return stream2;
    };
  }
});

// ../node_modules/parse-packagejson-name/index.js
var require_parse_packagejson_name = __commonJS({
  "../node_modules/parse-packagejson-name/index.js"(exports2, module2) {
    var nameRegExp = /^(?:@([^/]+)\/)?(([^\.]+)(?:\.(.*))?)$/;
    module2.exports = function parsePackageJsonName(name) {
      var returnObject = {
        scope: null,
        fullName: "",
        projectName: "",
        moduleName: ""
      };
      var match = (typeof name === "object" ? name.name || "" : name || "").match(nameRegExp);
      if (match) {
        returnObject.scope = match[1] || null;
        returnObject.fullName = match[2] || match[0];
        returnObject.projectName = match[3] === match[2] ? null : match[3];
        returnObject.moduleName = match[4] || match[2] || null;
      }
      return returnObject;
    };
  }
});

// ../node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "../node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// ../node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "../node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// ../node_modules/fast-glob/out/utils/fs.js
var require_fs2 = __commonJS({
  "../node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "../node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// ../node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "../node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// ../node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "../node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// ../node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "../node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// ../node_modules/braces/lib/utils.js
var require_utils4 = __commonJS({
  "../node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// ../node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// ../node_modules/is-number/index.js
var require_is_number = __commonJS({
  "../node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// ../node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "../node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = __spreadValues({ relaxZeros: true }, options);
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// ../node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "../node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, __spreadValues({ wrap: false }, options));
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, __spreadValues({ wrap: false }, options));
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = __spreadValues({}, options);
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// ../node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "../node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils4();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, __spreadProps(__spreadValues({}, options), { wrap: false, toRegex: true }));
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// ../node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "../node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils4();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// ../node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "../node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// ../node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "../node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// ../node_modules/braces/index.js
var require_braces = __commonJS({
  "../node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// ../node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS({
  "../node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = __spreadProps(__spreadValues({}, POSIX_CHARS), {
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    });
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// ../node_modules/picomatch/lib/utils.js
var require_utils5 = __commonJS({
  "../node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// ../node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "../node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils5();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants3();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// ../node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "../node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var utils = require_utils5();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = __spreadValues({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = __spreadProps(__spreadValues({}, EXTGLOB_CHARS[value2]), { conditions: 1, inner: "" });
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            output = token.close = `)${rest})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = __spreadValues({}, options);
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// ../node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "../node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse3();
    var utils = require_utils5();
    var constants = require_constants3();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = __spreadProps(__spreadValues({}, options), { ignore: null, onMatch: null, onResult: null });
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, __spreadProps(__spreadValues({}, options), { fastpaths: false }));
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// ../node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "../node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// ../node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "../node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils5();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = new Set();
      let keep = new Set();
      let items = new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), __spreadProps(__spreadValues({}, options), { onResult }), true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = micromatch(list, patterns, __spreadProps(__spreadValues({}, options), { onResult }));
      for (let item of items) {
        if (!matches.includes(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, __spreadProps(__spreadValues({}, options), { contains: true }));
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), __spreadProps(__spreadValues({}, options), { capture: true }));
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, __spreadProps(__spreadValues({}, options), { expand: true }));
    };
    module2.exports = micromatch;
  }
});

// ../node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "../node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[.*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\(.*\|.*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\(.*\)/;
    var BRACE_EXPANSIONS_SYMBOLS_RE = /{.*(?:,|\.\.).*}/;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && BRACE_EXPANSIONS_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  }
});

// ../node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "../node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream2) {
          function onend() {
            stream2.removeListener("merge2UnpipeEnd", onend);
            stream2.removeListener("end", onend);
            if (doPipeError) {
              stream2.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream2._readableState.endEmitted) {
            return next();
          }
          stream2.on("merge2UnpipeEnd", onend);
          stream2.on("end", onend);
          if (doPipeError) {
            stream2.on("error", onerror);
          }
          stream2.pipe(mergedStream, { end: false });
          stream2.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream2) {
        stream2.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// ../node_modules/fast-glob/out/utils/stream.js
var require_stream5 = __commonJS({
  "../node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream2) => {
        stream2.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream2) => stream2.emit("close"));
    }
  }
});

// ../node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "../node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// ../node_modules/fast-glob/out/utils/index.js
var require_utils6 = __commonJS({
  "../node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs = require_fs2();
    exports2.fs = fs;
    var path = require_path();
    exports2.path = path;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream2 = require_stream5();
    exports2.stream = stream2;
    var string = require_string();
    exports2.string = string;
  }
});

// ../node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "../node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils6();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// ../node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "../node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path, settings, callback) {
      settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "../node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read(path, settings) {
      const lstat = settings.fs.lstatSync(path);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read;
  }
});

// ../node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs3 = __commonJS({
  "../node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "../node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require_fs3();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// ../node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "../node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "../node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// ../node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "../node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// ../node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs4 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils7 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs = require_fs4();
    exports2.fs = fs;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils7();
    var common = require_common();
    function read(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// ../node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils7();
    var common = require_common();
    function read(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs5 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var fs = require_fs5();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// ../node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "../node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "../node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// ../node_modules/fastq/queue.js
var require_queue = __commonJS({
  "../node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve2, reject2) {
          pushCb(value, function(err, result) {
            if (err) {
              reject2(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve2, reject2) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject2(err);
              return;
            }
            resolve2(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve2) {
          queue.drain = function() {
            previousDrain();
            resolve2();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// ../node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// ../node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// ../node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// ../node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// ../node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream6 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// ../node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// ../node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// ../node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// ../node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "../node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream6();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// ../node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "../node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var utils = require_utils6();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// ../node_modules/fast-glob/out/readers/stream.js
var require_stream7 = __commonJS({
  "../node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream2 = new stream_1.PassThrough({ objectMode: true });
        stream2._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream2.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream2.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream2.write(i);
        }
        return stream2;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve2, reject2) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve2(stats) : reject2(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// ../node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "../node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils6();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// ../node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "../node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// ../node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "../node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils6();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// ../node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "../node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils6();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe);
      }
    };
    exports2.default = EntryFilter;
  }
});

// ../node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "../node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils6();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// ../node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "../node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils6();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// ../node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "../node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// ../node_modules/fast-glob/out/providers/async.js
var require_async5 = __commonJS({
  "../node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream7();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve2, reject2) => {
          const stream2 = this.api(root, task, options);
          stream2.once("error", reject2);
          stream2.on("data", (entry) => entries.push(options.transform(entry)));
          stream2.once("end", () => resolve2(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// ../node_modules/fast-glob/out/providers/stream.js
var require_stream8 = __commonJS({
  "../node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream7();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// ../node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "../node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// ../node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "../node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// ../node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "../node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      lstatSync: fs.lstatSync,
      stat: fs.stat,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// ../node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "../node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var async_1 = require_async5();
    var stream_1 = require_stream8();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils6();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream2(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream2;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = [].concat(source);
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = [].concat(source);
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// ../node_modules/debounce/index.js
var require_debounce = __commonJS({
  "../node_modules/debounce/index.js"(exports2, module2) {
    function debounce(func, wait, immediate) {
      var timeout, args, context, timestamp, result;
      if (wait == null)
        wait = 100;
      function later() {
        var last = Date.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            context = args = null;
          }
        }
      }
      ;
      var debounced = function() {
        context = this;
        args = arguments;
        timestamp = Date.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
      debounced.clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
      };
      debounced.flush = function() {
        if (timeout) {
          result = func.apply(context, args);
          context = args = null;
          clearTimeout(timeout);
          timeout = null;
        }
      };
      return debounced;
    }
    debounce.debounce = debounce;
    module2.exports = debounce;
  }
});

// ../node_modules/is-git-url/index.js
var require_is_git_url = __commonJS({
  "../node_modules/is-git-url/index.js"(exports2, module2) {
    module2.exports = function isGitUrl(str) {
      var regex = /(?:git|ssh|https?|git@[-\w.]+):(\/\/)?(.*?)(\.git)(\/?|\#[-\d\w._]+?)$/;
      return regex.test(str);
    };
  }
});

// ../node_modules/proto-list/proto-list.js
var require_proto_list = __commonJS({
  "../node_modules/proto-list/proto-list.js"(exports2, module2) {
    module2.exports = ProtoList;
    function setProto(obj, proto) {
      if (typeof Object.setPrototypeOf === "function")
        return Object.setPrototypeOf(obj, proto);
      else
        obj.__proto__ = proto;
    }
    function ProtoList() {
      this.list = [];
      var root = null;
      Object.defineProperty(this, "root", {
        get: function() {
          return root;
        },
        set: function(r) {
          root = r;
          if (this.list.length) {
            setProto(this.list[this.list.length - 1], r);
          }
        },
        enumerable: true,
        configurable: true
      });
    }
    ProtoList.prototype = {
      get length() {
        return this.list.length;
      },
      get keys() {
        var k = [];
        for (var i in this.list[0])
          k.push(i);
        return k;
      },
      get snapshot() {
        var o = {};
        this.keys.forEach(function(k) {
          o[k] = this.get(k);
        }, this);
        return o;
      },
      get store() {
        return this.list[0];
      },
      push: function(obj) {
        if (typeof obj !== "object")
          obj = { valueOf: obj };
        if (this.list.length >= 1) {
          setProto(this.list[this.list.length - 1], obj);
        }
        setProto(obj, this.root);
        return this.list.push(obj);
      },
      pop: function() {
        if (this.list.length >= 2) {
          setProto(this.list[this.list.length - 2], this.root);
        }
        return this.list.pop();
      },
      unshift: function(obj) {
        setProto(obj, this.list[0] || this.root);
        return this.list.unshift(obj);
      },
      shift: function() {
        if (this.list.length === 1) {
          setProto(this.list[0], this.root);
        }
        return this.list.shift();
      },
      get: function(key) {
        return this.list[0][key];
      },
      set: function(key, val, save) {
        if (!this.length)
          this.push({});
        if (save && this.list[0].hasOwnProperty(key))
          this.push({});
        return this.list[0][key] = val;
      },
      forEach: function(fn, thisp) {
        for (var key in this.list[0])
          fn.call(thisp, key, this.list[0][key]);
      },
      slice: function() {
        return this.list.slice.apply(this.list, arguments);
      },
      splice: function() {
        var ret = this.list.splice.apply(this.list, arguments);
        for (var i = 0, l = this.list.length; i < l; i++) {
          setProto(this.list[i], this.list[i + 1] || this.root);
        }
        return ret;
      }
    };
  }
});

// ../node_modules/config-chain/node_modules/ini/ini.js
var require_ini3 = __commonJS({
  "../node_modules/config-chain/node_modules/ini/ini.js"(exports2) {
    exports2.parse = exports2.decode = decode;
    exports2.stringify = exports2.encode = encode;
    exports2.safe = safe;
    exports2.unsafe = unsafe;
    var eol = typeof process !== "undefined" && process.platform === "win32" ? "\r\n" : "\n";
    function encode(obj, opt) {
      var children = [];
      var out = "";
      if (typeof opt === "string") {
        opt = {
          section: opt,
          whitespace: false
        };
      } else {
        opt = opt || {};
        opt.whitespace = opt.whitespace === true;
      }
      var separator = opt.whitespace ? " = " : "=";
      Object.keys(obj).forEach(function(k, _2, __) {
        var val = obj[k];
        if (val && Array.isArray(val)) {
          val.forEach(function(item) {
            out += safe(k + "[]") + separator + safe(item) + "\n";
          });
        } else if (val && typeof val === "object")
          children.push(k);
        else
          out += safe(k) + separator + safe(val) + eol;
      });
      if (opt.section && out.length)
        out = "[" + safe(opt.section) + "]" + eol + out;
      children.forEach(function(k, _2, __) {
        var nk = dotSplit(k).join("\\.");
        var section = (opt.section ? opt.section + "." : "") + nk;
        var child = encode(obj[k], {
          section,
          whitespace: opt.whitespace
        });
        if (out.length && child.length)
          out += eol;
        out += child;
      });
      return out;
    }
    function dotSplit(str) {
      return str.replace(/\1/g, "LITERAL\\1LITERAL").replace(/\\\./g, "").split(/\./).map(function(part) {
        return part.replace(/\1/g, "\\.").replace(/\2LITERAL\\1LITERAL\2/g, "");
      });
    }
    function decode(str) {
      var out = {};
      var p = out;
      var section = null;
      var re = /^\[([^\]]*)\]$|^([^=]+)(=(.*))?$/i;
      var lines = str.split(/[\r\n]+/g);
      lines.forEach(function(line, _2, __) {
        if (!line || line.match(/^\s*[;#]/))
          return;
        var match = line.match(re);
        if (!match)
          return;
        if (match[1] !== void 0) {
          section = unsafe(match[1]);
          if (section === "__proto__") {
            p = {};
            return;
          }
          p = out[section] = out[section] || {};
          return;
        }
        var key = unsafe(match[2]);
        if (key === "__proto__")
          return;
        var value = match[3] ? unsafe(match[4]) : true;
        switch (value) {
          case "true":
          case "false":
          case "null":
            value = JSON.parse(value);
        }
        if (key.length > 2 && key.slice(-2) === "[]") {
          key = key.substring(0, key.length - 2);
          if (key === "__proto__")
            return;
          if (!p[key])
            p[key] = [];
          else if (!Array.isArray(p[key]))
            p[key] = [p[key]];
        }
        if (Array.isArray(p[key]))
          p[key].push(value);
        else
          p[key] = value;
      });
      Object.keys(out).filter(function(k, _2, __) {
        if (!out[k] || typeof out[k] !== "object" || Array.isArray(out[k]))
          return false;
        var parts = dotSplit(k);
        var p2 = out;
        var l = parts.pop();
        var nl = l.replace(/\\\./g, ".");
        parts.forEach(function(part, _3, __2) {
          if (part === "__proto__")
            return;
          if (!p2[part] || typeof p2[part] !== "object")
            p2[part] = {};
          p2 = p2[part];
        });
        if (p2 === out && nl === l)
          return false;
        p2[nl] = out[k];
        return true;
      }).forEach(function(del, _2, __) {
        delete out[del];
      });
      return out;
    }
    function isQuoted(val) {
      return val.charAt(0) === '"' && val.slice(-1) === '"' || val.charAt(0) === "'" && val.slice(-1) === "'";
    }
    function safe(val) {
      return typeof val !== "string" || val.match(/[=\r\n]/) || val.match(/^\[/) || val.length > 1 && isQuoted(val) || val !== val.trim() ? JSON.stringify(val) : val.replace(/;/g, "\\;").replace(/#/g, "\\#");
    }
    function unsafe(val, doUnesc) {
      val = (val || "").trim();
      if (isQuoted(val)) {
        if (val.charAt(0) === "'")
          val = val.substr(1, val.length - 2);
        try {
          val = JSON.parse(val);
        } catch (_2) {
        }
      } else {
        var esc = false;
        var unesc = "";
        for (var i = 0, l = val.length; i < l; i++) {
          var c = val.charAt(i);
          if (esc) {
            if ("\\;#".indexOf(c) !== -1)
              unesc += c;
            else
              unesc += "\\" + c;
            esc = false;
          } else if (";#".indexOf(c) !== -1)
            break;
          else if (c === "\\")
            esc = true;
          else
            unesc += c;
        }
        if (esc)
          unesc += "\\";
        return unesc.trim();
      }
      return val;
    }
  }
});

// ../node_modules/config-chain/index.js
var require_config_chain = __commonJS({
  "../node_modules/config-chain/index.js"(exports2, module2) {
    var ProtoList = require_proto_list();
    var path = require("path");
    var fs = require("fs");
    var ini = require_ini3();
    var EE = require("events").EventEmitter;
    var url = require("url");
    var http = require("http");
    var exports2 = module2.exports = function() {
      var args = [].slice.call(arguments), conf = new ConfigChain();
      while (args.length) {
        var a = args.shift();
        if (a)
          conf.push(typeof a === "string" ? json(a) : a);
      }
      return conf;
    };
    var find = exports2.find = function() {
      var rel = path.join.apply(null, [].slice.call(arguments));
      function find2(start, rel2) {
        var file = path.join(start, rel2);
        try {
          fs.statSync(file);
          return file;
        } catch (err) {
          if (path.dirname(start) !== start)
            return find2(path.dirname(start), rel2);
        }
      }
      return find2(__dirname, rel);
    };
    var parse = exports2.parse = function(content, file, type) {
      content = "" + content;
      if (!type) {
        try {
          return JSON.parse(content);
        } catch (er) {
          return ini.parse(content);
        }
      } else if (type === "json") {
        if (this.emit) {
          try {
            return JSON.parse(content);
          } catch (er) {
            this.emit("error", er);
          }
        } else {
          return JSON.parse(content);
        }
      } else {
        return ini.parse(content);
      }
    };
    var json = exports2.json = function() {
      var args = [].slice.call(arguments).filter(function(arg) {
        return arg != null;
      });
      var file = path.join.apply(null, args);
      var content;
      try {
        content = fs.readFileSync(file, "utf-8");
      } catch (err) {
        return;
      }
      return parse(content, file, "json");
    };
    var env = exports2.env = function(prefix, env2) {
      env2 = env2 || process.env;
      var obj = {};
      var l = prefix.length;
      for (var k in env2) {
        if (k.indexOf(prefix) === 0)
          obj[k.substring(l)] = env2[k];
      }
      return obj;
    };
    exports2.ConfigChain = ConfigChain;
    function ConfigChain() {
      EE.apply(this);
      ProtoList.apply(this, arguments);
      this._awaiting = 0;
      this._saving = 0;
      this.sources = {};
    }
    var extras = {
      constructor: { value: ConfigChain }
    };
    Object.keys(EE.prototype).forEach(function(k) {
      extras[k] = Object.getOwnPropertyDescriptor(EE.prototype, k);
    });
    ConfigChain.prototype = Object.create(ProtoList.prototype, extras);
    ConfigChain.prototype.del = function(key, where) {
      if (where) {
        var target = this.sources[where];
        target = target && target.data;
        if (!target) {
          return this.emit("error", new Error("not found " + where));
        }
        delete target[key];
      } else {
        for (var i = 0, l = this.list.length; i < l; i++) {
          delete this.list[i][key];
        }
      }
      return this;
    };
    ConfigChain.prototype.set = function(key, value, where) {
      var target;
      if (where) {
        target = this.sources[where];
        target = target && target.data;
        if (!target) {
          return this.emit("error", new Error("not found " + where));
        }
      } else {
        target = this.list[0];
        if (!target) {
          return this.emit("error", new Error("cannot set, no confs!"));
        }
      }
      target[key] = value;
      return this;
    };
    ConfigChain.prototype.get = function(key, where) {
      if (where) {
        where = this.sources[where];
        if (where)
          where = where.data;
        if (where && Object.hasOwnProperty.call(where, key))
          return where[key];
        return void 0;
      }
      return this.list[0][key];
    };
    ConfigChain.prototype.save = function(where, type, cb) {
      if (typeof type === "function")
        cb = type, type = null;
      var target = this.sources[where];
      if (!target || !(target.path || target.source) || !target.data) {
        return this.emit("error", new Error("bad save target: " + where));
      }
      if (target.source) {
        var pref = target.prefix || "";
        Object.keys(target.data).forEach(function(k) {
          target.source[pref + k] = target.data[k];
        });
        return this;
      }
      var type = type || target.type;
      var data = target.data;
      if (target.type === "json") {
        data = JSON.stringify(data);
      } else {
        data = ini.stringify(data);
      }
      this._saving++;
      fs.writeFile(target.path, data, "utf8", function(er) {
        this._saving--;
        if (er) {
          if (cb)
            return cb(er);
          else
            return this.emit("error", er);
        }
        if (this._saving === 0) {
          if (cb)
            cb();
          this.emit("save");
        }
      }.bind(this));
      return this;
    };
    ConfigChain.prototype.addFile = function(file, type, name) {
      name = name || file;
      var marker = { __source__: name };
      this.sources[name] = { path: file, type };
      this.push(marker);
      this._await();
      fs.readFile(file, "utf8", function(er, data) {
        if (er)
          this.emit("error", er);
        this.addString(data, file, type, marker);
      }.bind(this));
      return this;
    };
    ConfigChain.prototype.addEnv = function(prefix, env2, name) {
      name = name || "env";
      var data = exports2.env(prefix, env2);
      this.sources[name] = { data, source: env2, prefix };
      return this.add(data, name);
    };
    ConfigChain.prototype.addUrl = function(req, type, name) {
      this._await();
      var href = url.format(req);
      name = name || href;
      var marker = { __source__: name };
      this.sources[name] = { href, type };
      this.push(marker);
      http.request(req, function(res) {
        var c = [];
        var ct = res.headers["content-type"];
        if (!type) {
          type = ct.indexOf("json") !== -1 ? "json" : ct.indexOf("ini") !== -1 ? "ini" : href.match(/\.json$/) ? "json" : href.match(/\.ini$/) ? "ini" : null;
          marker.type = type;
        }
        res.on("data", c.push.bind(c)).on("end", function() {
          this.addString(Buffer.concat(c), href, type, marker);
        }.bind(this)).on("error", this.emit.bind(this, "error"));
      }.bind(this)).on("error", this.emit.bind(this, "error")).end();
      return this;
    };
    ConfigChain.prototype.addString = function(data, file, type, marker) {
      data = this.parse(data, file, type);
      this.add(data, marker);
      return this;
    };
    ConfigChain.prototype.add = function(data, marker) {
      if (marker && typeof marker === "object") {
        var i = this.list.indexOf(marker);
        if (i === -1) {
          return this.emit("error", new Error("bad marker"));
        }
        this.splice(i, 1, data);
        marker = marker.__source__;
        this.sources[marker] = this.sources[marker] || {};
        this.sources[marker].data = data;
        this._resolve();
      } else {
        if (typeof marker === "string") {
          this.sources[marker] = this.sources[marker] || {};
          this.sources[marker].data = data;
        }
        this._await();
        this.push(data);
        process.nextTick(this._resolve.bind(this));
      }
      return this;
    };
    ConfigChain.prototype.parse = exports2.parse;
    ConfigChain.prototype._await = function() {
      this._awaiting++;
    };
    ConfigChain.prototype._resolve = function() {
      this._awaiting--;
      if (this._awaiting === 0)
        this.emit("load", this);
    };
  }
});

// ../node_modules/npm-conf/lib/types.js
var require_types = __commonJS({
  "../node_modules/npm-conf/lib/types.js"(exports2) {
    "use strict";
    var path = require("path");
    var Stream = require("stream").Stream;
    var url = require("url");
    var Umask = () => {
    };
    var getLocalAddresses = () => [];
    var semver = () => {
    };
    exports2.types = {
      access: [null, "restricted", "public"],
      "allow-same-version": Boolean,
      "always-auth": Boolean,
      also: [null, "dev", "development"],
      "auth-type": ["legacy", "sso", "saml", "oauth"],
      "bin-links": Boolean,
      browser: [null, String],
      ca: [null, String, Array],
      cafile: path,
      cache: path,
      "cache-lock-stale": Number,
      "cache-lock-retries": Number,
      "cache-lock-wait": Number,
      "cache-max": Number,
      "cache-min": Number,
      cert: [null, String],
      color: ["always", Boolean],
      depth: Number,
      description: Boolean,
      dev: Boolean,
      "dry-run": Boolean,
      editor: String,
      "engine-strict": Boolean,
      force: Boolean,
      "fetch-retries": Number,
      "fetch-retry-factor": Number,
      "fetch-retry-mintimeout": Number,
      "fetch-retry-maxtimeout": Number,
      git: String,
      "git-tag-version": Boolean,
      global: Boolean,
      globalconfig: path,
      "global-style": Boolean,
      group: [Number, String],
      "https-proxy": [null, url],
      "user-agent": String,
      "ham-it-up": Boolean,
      "heading": String,
      "if-present": Boolean,
      "ignore-prepublish": Boolean,
      "ignore-scripts": Boolean,
      "init-module": path,
      "init-author-name": String,
      "init-author-email": String,
      "init-author-url": ["", url],
      "init-license": String,
      "init-version": semver,
      json: Boolean,
      key: [null, String],
      "legacy-bundling": Boolean,
      link: Boolean,
      "local-address": getLocalAddresses(),
      loglevel: ["silent", "error", "warn", "notice", "http", "timing", "info", "verbose", "silly"],
      logstream: Stream,
      "logs-max": Number,
      long: Boolean,
      maxsockets: Number,
      message: String,
      "metrics-registry": [null, String],
      "node-version": [null, semver],
      offline: Boolean,
      "onload-script": [null, String],
      only: [null, "dev", "development", "prod", "production"],
      optional: Boolean,
      "package-lock": Boolean,
      parseable: Boolean,
      "prefer-offline": Boolean,
      "prefer-online": Boolean,
      prefix: path,
      production: Boolean,
      progress: Boolean,
      "proprietary-attribs": Boolean,
      proxy: [null, false, url],
      "rebuild-bundle": Boolean,
      registry: [null, url],
      rollback: Boolean,
      save: Boolean,
      "save-bundle": Boolean,
      "save-dev": Boolean,
      "save-exact": Boolean,
      "save-optional": Boolean,
      "save-prefix": String,
      "save-prod": Boolean,
      scope: String,
      "script-shell": [null, String],
      "scripts-prepend-node-path": [false, true, "auto", "warn-only"],
      searchopts: String,
      searchexclude: [null, String],
      searchlimit: Number,
      searchstaleness: Number,
      "send-metrics": Boolean,
      shell: String,
      shrinkwrap: Boolean,
      "sign-git-tag": Boolean,
      "sso-poll-frequency": Number,
      "sso-type": [null, "oauth", "saml"],
      "strict-ssl": Boolean,
      tag: String,
      timing: Boolean,
      tmp: path,
      unicode: Boolean,
      "unsafe-perm": Boolean,
      usage: Boolean,
      user: [Number, String],
      userconfig: path,
      umask: Umask,
      version: Boolean,
      "tag-version-prefix": String,
      versions: Boolean,
      viewer: String,
      _exit: Boolean
    };
  }
});

// ../node_modules/npm-conf/lib/util.js
var require_util5 = __commonJS({
  "../node_modules/npm-conf/lib/util.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var types = require_types();
    var envReplace = (str) => {
      if (typeof str !== "string" || !str) {
        return str;
      }
      const regex = /(\\*)\$\{([^}]+)\}/g;
      return str.replace(regex, (orig, esc, name) => {
        esc = esc.length > 0 && esc.length % 2;
        if (esc) {
          return orig;
        }
        if (process.env[name] === void 0) {
          throw new Error(`Failed to replace env in config: ${orig}`);
        }
        return process.env[name];
      });
    };
    var parseField = (field, key) => {
      if (typeof field !== "string") {
        return field;
      }
      const typeList = [].concat(types[key]);
      const isPath = typeList.indexOf(path) !== -1;
      const isBool = typeList.indexOf(Boolean) !== -1;
      const isString = typeList.indexOf(String) !== -1;
      const isNumber = typeList.indexOf(Number) !== -1;
      field = `${field}`.trim();
      if (/^".*"$/.test(field)) {
        try {
          field = JSON.parse(field);
        } catch (err) {
          throw new Error(`Failed parsing JSON config key ${key}: ${field}`);
        }
      }
      if (isBool && !isString && field === "") {
        return true;
      }
      switch (field) {
        case "true": {
          return true;
        }
        case "false": {
          return false;
        }
        case "null": {
          return null;
        }
        case "undefined": {
          return void 0;
        }
      }
      field = envReplace(field);
      if (isPath) {
        const regex = process.platform === "win32" ? /^~(\/|\\)/ : /^~\//;
        if (regex.test(field) && process.env.HOME) {
          field = path.resolve(process.env.HOME, field.substr(2));
        }
        field = path.resolve(field);
      }
      if (isNumber && !field.isNan()) {
        field = Number(field);
      }
      return field;
    };
    var findPrefix = (name) => {
      name = path.resolve(name);
      let walkedUp = false;
      while (path.basename(name) === "node_modules") {
        name = path.dirname(name);
        walkedUp = true;
      }
      if (walkedUp) {
        return name;
      }
      const find = (name2, original) => {
        const regex = /^[a-zA-Z]:(\\|\/)?$/;
        if (name2 === "/" || process.platform === "win32" && regex.test(name2)) {
          return original;
        }
        try {
          const files = fs.readdirSync(name2);
          if (files.indexOf("node_modules") !== -1 || files.indexOf("package.json") !== -1) {
            return name2;
          }
          const dirname = path.dirname(name2);
          if (dirname === name2) {
            return original;
          }
          return find(dirname, original);
        } catch (err) {
          if (name2 === original) {
            if (err.code === "ENOENT") {
              return original;
            }
            throw err;
          }
          return original;
        }
      };
      return find(name, name);
    };
    exports2.envReplace = envReplace;
    exports2.findPrefix = findPrefix;
    exports2.parseField = parseField;
  }
});

// ../node_modules/npm-conf/lib/conf.js
var require_conf = __commonJS({
  "../node_modules/npm-conf/lib/conf.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var ConfigChain = require_config_chain().ConfigChain;
    var util = require_util5();
    var Conf = class extends ConfigChain {
      constructor(base) {
        super(base);
        this.root = base;
      }
      add(data, marker) {
        try {
          for (const x of Object.keys(data)) {
            data[x] = util.parseField(data[x], x);
          }
        } catch (err) {
          throw err;
        }
        return super.add(data, marker);
      }
      addFile(file, name) {
        name = name || file;
        const marker = { __source__: name };
        this.sources[name] = { path: file, type: "ini" };
        this.push(marker);
        this._await();
        try {
          const contents = fs.readFileSync(file, "utf8");
          this.addString(contents, file, "ini", marker);
        } catch (err) {
          this.add({}, marker);
        }
        return this;
      }
      addEnv(env) {
        env = env || process.env;
        const conf = {};
        Object.keys(env).filter((x) => /^npm_config_/i.test(x)).forEach((x) => {
          if (!env[x]) {
            return;
          }
          const p = x.toLowerCase().replace(/^npm_config_/, "").replace(/(?!^)_/g, "-");
          conf[p] = env[x];
        });
        return super.addEnv("", conf, "env");
      }
      loadPrefix() {
        const cli = this.list[0];
        Object.defineProperty(this, "prefix", {
          enumerable: true,
          set: (prefix) => {
            const g = this.get("global");
            this[g ? "globalPrefix" : "localPrefix"] = prefix;
          },
          get: () => {
            const g = this.get("global");
            return g ? this.globalPrefix : this.localPrefix;
          }
        });
        Object.defineProperty(this, "globalPrefix", {
          enumerable: true,
          set: (prefix) => {
            this.set("prefix", prefix);
          },
          get: () => {
            return path.resolve(this.get("prefix"));
          }
        });
        let p;
        Object.defineProperty(this, "localPrefix", {
          enumerable: true,
          set: (prefix) => {
            p = prefix;
          },
          get: () => {
            return p;
          }
        });
        if (Object.prototype.hasOwnProperty.call(cli, "prefix")) {
          p = path.resolve(cli.prefix);
        } else {
          try {
            const prefix = util.findPrefix(process.cwd());
            p = prefix;
          } catch (err) {
            throw err;
          }
        }
        return p;
      }
      loadCAFile(file) {
        if (!file) {
          return;
        }
        try {
          const contents = fs.readFileSync(file, "utf8");
          const delim = "-----END CERTIFICATE-----";
          const output = contents.split(delim).filter((x) => Boolean(x.trim())).map((x) => x.trimLeft() + delim);
          this.set("ca", output);
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
      loadUser() {
        const defConf = this.root;
        if (this.get("global")) {
          return;
        }
        if (process.env.SUDO_UID) {
          defConf.user = Number(process.env.SUDO_UID);
          return;
        }
        const prefix = path.resolve(this.get("prefix"));
        try {
          const stats = fs.statSync(prefix);
          defConf.user = stats.uid;
        } catch (err) {
          if (err.code === "ENOENT") {
            return;
          }
          throw err;
        }
      }
    };
    module2.exports = Conf;
  }
});

// ../node_modules/npm-conf/lib/defaults.js
var require_defaults = __commonJS({
  "../node_modules/npm-conf/lib/defaults.js"(exports2) {
    "use strict";
    var os = require("os");
    var path = require("path");
    var temp = os.tmpdir();
    var uidOrPid = process.getuid ? process.getuid() : process.pid;
    var hasUnicode = () => true;
    var isWindows = process.platform === "win32";
    var osenv = {
      editor: () => process.env.EDITOR || process.env.VISUAL || (isWindows ? "notepad.exe" : "vi"),
      shell: () => isWindows ? process.env.COMSPEC || "cmd.exe" : process.env.SHELL || "/bin/bash"
    };
    var umask = {
      fromString: () => process.umask()
    };
    var home = os.homedir();
    if (home) {
      process.env.HOME = home;
    } else {
      home = path.resolve(temp, "npm-" + uidOrPid);
    }
    var cacheExtra = process.platform === "win32" ? "npm-cache" : ".npm";
    var cacheRoot = process.platform === "win32" ? process.env.APPDATA : home;
    var cache = path.resolve(cacheRoot, cacheExtra);
    var defaults;
    var globalPrefix;
    Object.defineProperty(exports2, "defaults", {
      get: function() {
        if (defaults)
          return defaults;
        if (process.env.PREFIX) {
          globalPrefix = process.env.PREFIX;
        } else if (process.platform === "win32") {
          globalPrefix = path.dirname(process.execPath);
        } else {
          globalPrefix = path.dirname(path.dirname(process.execPath));
          if (process.env.DESTDIR) {
            globalPrefix = path.join(process.env.DESTDIR, globalPrefix);
          }
        }
        defaults = {
          access: null,
          "allow-same-version": false,
          "always-auth": false,
          also: null,
          "auth-type": "legacy",
          "bin-links": true,
          browser: null,
          ca: null,
          cafile: null,
          cache,
          "cache-lock-stale": 6e4,
          "cache-lock-retries": 10,
          "cache-lock-wait": 1e4,
          "cache-max": Infinity,
          "cache-min": 10,
          cert: null,
          color: true,
          depth: Infinity,
          description: true,
          dev: false,
          "dry-run": false,
          editor: osenv.editor(),
          "engine-strict": false,
          force: false,
          "fetch-retries": 2,
          "fetch-retry-factor": 10,
          "fetch-retry-mintimeout": 1e4,
          "fetch-retry-maxtimeout": 6e4,
          git: "git",
          "git-tag-version": true,
          global: false,
          globalconfig: path.resolve(globalPrefix, "etc", "npmrc"),
          "global-style": false,
          group: process.platform === "win32" ? 0 : process.env.SUDO_GID || process.getgid && process.getgid(),
          "ham-it-up": false,
          heading: "npm",
          "if-present": false,
          "ignore-prepublish": false,
          "ignore-scripts": false,
          "init-module": path.resolve(home, ".npm-init.js"),
          "init-author-name": "",
          "init-author-email": "",
          "init-author-url": "",
          "init-version": "1.0.0",
          "init-license": "ISC",
          json: false,
          key: null,
          "legacy-bundling": false,
          link: false,
          "local-address": void 0,
          loglevel: "notice",
          logstream: process.stderr,
          "logs-max": 10,
          long: false,
          maxsockets: 50,
          message: "%s",
          "metrics-registry": null,
          "node-version": process.version,
          "offline": false,
          "onload-script": false,
          only: null,
          optional: true,
          "package-lock": true,
          parseable: false,
          "prefer-offline": false,
          "prefer-online": false,
          prefix: globalPrefix,
          production: process.env.NODE_ENV === "production",
          "progress": !process.env.TRAVIS && !process.env.CI,
          "proprietary-attribs": true,
          proxy: null,
          "https-proxy": null,
          "user-agent": "npm/{npm-version} node/{node-version} {platform} {arch}",
          "rebuild-bundle": true,
          registry: "https://registry.npmjs.org/",
          rollback: true,
          save: true,
          "save-bundle": false,
          "save-dev": false,
          "save-exact": false,
          "save-optional": false,
          "save-prefix": "^",
          "save-prod": false,
          scope: "",
          "script-shell": null,
          "scripts-prepend-node-path": "warn-only",
          searchopts: "",
          searchexclude: null,
          searchlimit: 20,
          searchstaleness: 15 * 60,
          "send-metrics": false,
          shell: osenv.shell(),
          shrinkwrap: true,
          "sign-git-tag": false,
          "sso-poll-frequency": 500,
          "sso-type": "oauth",
          "strict-ssl": true,
          tag: "latest",
          "tag-version-prefix": "v",
          timing: false,
          tmp: temp,
          unicode: hasUnicode(),
          "unsafe-perm": process.platform === "win32" || process.platform === "cygwin" || !(process.getuid && process.setuid && process.getgid && process.setgid) || process.getuid() !== 0,
          usage: false,
          user: process.platform === "win32" ? 0 : "nobody",
          userconfig: path.resolve(home, ".npmrc"),
          umask: process.umask ? process.umask() : umask.fromString("022"),
          version: false,
          versions: false,
          viewer: process.platform === "win32" ? "browser" : "man",
          _exit: true
        };
        return defaults;
      }
    });
  }
});

// ../node_modules/npm-conf/index.js
var require_npm_conf = __commonJS({
  "../node_modules/npm-conf/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var Conf = require_conf();
    var defaults = require_defaults();
    module2.exports = (opts) => {
      const conf = new Conf(Object.assign({}, defaults.defaults));
      conf.add(Object.assign({}, opts), "cli");
      conf.addEnv();
      conf.loadPrefix();
      const projectConf = path.resolve(conf.localPrefix, ".npmrc");
      const userConf = conf.get("userconfig");
      if (!conf.get("global") && projectConf !== userConf) {
        conf.addFile(projectConf, "project");
      } else {
        conf.add({}, "project");
      }
      conf.addFile(conf.get("userconfig"), "user");
      if (conf.get("prefix")) {
        const etc = path.resolve(conf.get("prefix"), "etc");
        conf.root.globalconfig = path.resolve(etc, "npmrc");
        conf.root.globalignorefile = path.resolve(etc, "npmignore");
      }
      conf.addFile(conf.get("globalconfig"), "global");
      conf.loadUser();
      const caFile = conf.get("cafile");
      if (caFile) {
        conf.loadCAFile(caFile);
      }
      return conf;
    };
    module2.exports.defaults = Object.assign({}, defaults.defaults);
  }
});

// ../node_modules/get-proxy/index.js
var require_get_proxy = __commonJS({
  "../node_modules/get-proxy/index.js"(exports2, module2) {
    "use strict";
    var npmConf = require_npm_conf()();
    module2.exports = () => {
      return process.env.HTTPS_PROXY || process.env.https_proxy || process.env.HTTP_PROXY || process.env.http_proxy || npmConf.get("https-proxy") || npmConf.get("http-proxy") || npmConf.get("proxy") || null;
    };
  }
});

// ../node_modules/tunnel-agent/index.js
var require_tunnel_agent = __commonJS({
  "../node_modules/tunnel-agent/index.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    var Buffer2 = require_safe_buffer2().Buffer;
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port) {
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === host && pending.port === port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
      var self2 = this;
      if (typeof options === "string") {
        options = {
          host: options,
          port: arguments[2],
          path: arguments[3]
        };
      }
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push({ host: options.host, port: options.port, request: req });
        return;
      }
      self2.createConnection({ host: options.host, port: options.port, request: req });
    };
    TunnelingAgent.prototype.createConnection = function createConnection(pending) {
      var self2 = this;
      self2.createSocket(pending, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        pending.request.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, pending.host, pending.port);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false
      });
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + Buffer2.from(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode === 200) {
          assert.equal(head.length, 0);
          debug("tunneling connection has established");
          self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
          cb(socket);
        } else {
          debug("tunneling socket could not be established, statusCode=%d", res.statusCode);
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
        }
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1)
        return;
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createConnection(pending);
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var secureSocket = tls.connect(0, mergeOptions({}, self2.options, {
          servername: options.host,
          socket
        }));
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k = keys[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.debug = debug;
  }
});

// ../node_modules/caw/index.js
var require_caw = __commonJS({
  "../node_modules/caw/index.js"(exports2, module2) {
    "use strict";
    var url = require("url");
    var getProxy = require_get_proxy();
    var isurl = require_isurl();
    var tunnelAgent = require_tunnel_agent();
    var urlToOptions = require_url_to_options2();
    module2.exports = (proxy, opts) => {
      proxy = proxy || getProxy();
      opts = Object.assign({}, opts);
      if (typeof proxy === "object") {
        opts = proxy;
        proxy = getProxy();
      }
      if (!proxy) {
        return null;
      }
      proxy = isurl.lenient(proxy) ? urlToOptions(proxy) : url.parse(proxy);
      const uriProtocol = opts.protocol === "https" ? "https" : "http";
      const proxyProtocol = proxy.protocol === "https:" ? "Https" : "Http";
      const port = proxy.port || (proxyProtocol === "Https" ? 443 : 80);
      const method = `${uriProtocol}Over${proxyProtocol}`;
      delete opts.protocol;
      return tunnelAgent[method](Object.assign({
        proxy: {
          port,
          host: proxy.hostname,
          proxyAuth: proxy.auth
        }
      }, opts));
    };
  }
});

// ../node_modules/download-git-repo/node_modules/filenamify/index.js
var require_filenamify2 = __commonJS({
  "../node_modules/download-git-repo/node_modules/filenamify/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var trimRepeated = require_trim_repeated();
    var filenameReservedRegex = require_filename_reserved_regex();
    var stripOuter = require_strip_outer();
    var MAX_FILENAME_LENGTH = 100;
    var reControlChars = /[\u0000-\u001f\u0080-\u009f]/g;
    var reRelativePath = /^\.+/;
    var fn = (string, options) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      options = options || {};
      const replacement = options.replacement === void 0 ? "!" : options.replacement;
      if (filenameReservedRegex().test(replacement) && reControlChars.test(replacement)) {
        throw new Error("Replacement string cannot contain reserved filename characters");
      }
      string = string.replace(filenameReservedRegex(), replacement);
      string = string.replace(reControlChars, replacement);
      string = string.replace(reRelativePath, replacement);
      if (replacement.length > 0) {
        string = trimRepeated(string, replacement);
        string = string.length > 1 ? stripOuter(string, replacement) : string;
      }
      string = filenameReservedRegex.windowsNames().test(string) ? string + replacement : string;
      string = string.slice(0, MAX_FILENAME_LENGTH);
      return string;
    };
    fn.path = (pth, options) => {
      pth = path.resolve(pth);
      return path.join(path.dirname(pth), fn(path.basename(pth), options));
    };
    module2.exports = fn;
  }
});

// ../node_modules/download-git-repo/node_modules/get-stream/buffer-stream.js
var require_buffer_stream6 = __commonJS({
  "../node_modules/download-git-repo/node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var PassThrough = require("stream").PassThrough;
    module2.exports = (opts) => {
      opts = Object.assign({}, opts);
      const array = opts.array;
      let encoding = opts.encoding;
      const buffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || buffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (buffer) {
        encoding = null;
      }
      let len = 0;
      const ret = [];
      const stream2 = new PassThrough({ objectMode });
      if (encoding) {
        stream2.setEncoding(encoding);
      }
      stream2.on("data", (chunk) => {
        ret.push(chunk);
        if (objectMode) {
          len = ret.length;
        } else {
          len += chunk.length;
        }
      });
      stream2.getBufferedValue = () => {
        if (array) {
          return ret;
        }
        return buffer ? Buffer.concat(ret, len) : ret.join("");
      };
      stream2.getBufferedLength = () => len;
      return stream2;
    };
  }
});

// ../node_modules/download-git-repo/node_modules/get-stream/index.js
var require_get_stream6 = __commonJS({
  "../node_modules/download-git-repo/node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var bufferStream = require_buffer_stream6();
    function getStream(inputStream, opts) {
      if (!inputStream) {
        return Promise.reject(new Error("Expected a stream"));
      }
      opts = Object.assign({ maxBuffer: Infinity }, opts);
      const maxBuffer = opts.maxBuffer;
      let stream2;
      let clean;
      const p = new Promise((resolve2, reject2) => {
        const error = (err) => {
          if (err) {
            err.bufferedData = stream2.getBufferedValue();
          }
          reject2(err);
        };
        stream2 = bufferStream(opts);
        inputStream.once("error", error);
        inputStream.pipe(stream2);
        stream2.on("data", () => {
          if (stream2.getBufferedLength() > maxBuffer) {
            reject2(new Error("maxBuffer exceeded"));
          }
        });
        stream2.once("error", error);
        stream2.on("end", resolve2);
        clean = () => {
          if (inputStream.unpipe) {
            inputStream.unpipe(stream2);
          }
        };
      });
      p.then(clean, clean);
      return p.then(() => stream2.getBufferedValue());
    }
    module2.exports = getStream;
    module2.exports.buffer = (stream2, opts) => getStream(stream2, Object.assign({}, opts, { encoding: "buffer" }));
    module2.exports.array = (stream2, opts) => getStream(stream2, Object.assign({}, opts, { array: true }));
  }
});

// ../node_modules/download-git-repo/node_modules/pify/index.js
var require_pify6 = __commonJS({
  "../node_modules/download-git-repo/node_modules/pify/index.js"(exports2, module2) {
    "use strict";
    var processFn = (fn, opts) => function() {
      const P = opts.promiseModule;
      const args = new Array(arguments.length);
      for (let i = 0; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      return new P((resolve2, reject2) => {
        if (opts.errorFirst) {
          args.push(function(err, result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i = 1; i < arguments.length; i++) {
                results[i - 1] = arguments[i];
              }
              if (err) {
                results.unshift(err);
                reject2(results);
              } else {
                resolve2(results);
              }
            } else if (err) {
              reject2(err);
            } else {
              resolve2(result);
            }
          });
        } else {
          args.push(function(result) {
            if (opts.multiArgs) {
              const results = new Array(arguments.length - 1);
              for (let i = 0; i < arguments.length; i++) {
                results[i] = arguments[i];
              }
              resolve2(results);
            } else {
              resolve2(result);
            }
          });
        }
        fn.apply(this, args);
      });
    };
    module2.exports = (obj, opts) => {
      opts = Object.assign({
        exclude: [/.+(Sync|Stream)$/],
        errorFirst: true,
        promiseModule: Promise
      }, opts);
      const filter = (key) => {
        const match = (pattern) => typeof pattern === "string" ? key === pattern : pattern.test(key);
        return opts.include ? opts.include.some(match) : !opts.exclude.some(match);
      };
      let ret;
      if (typeof obj === "function") {
        ret = function() {
          if (opts.excludeMain) {
            return obj.apply(this, arguments);
          }
          return processFn(obj, opts).apply(this, arguments);
        };
      } else {
        ret = Object.create(Object.getPrototypeOf(obj));
      }
      for (const key in obj) {
        const x = obj[key];
        ret[key] = typeof x === "function" && filter(key) ? processFn(x, opts) : x;
      }
      return ret;
    };
  }
});

// ../node_modules/download-git-repo/node_modules/make-dir/index.js
var require_make_dir4 = __commonJS({
  "../node_modules/download-git-repo/node_modules/make-dir/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var pify = require_pify6();
    var defaults = {
      mode: 511 & ~process.umask(),
      fs
    };
    var checkPath = (pth) => {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const err = new Error(`Path contains invalid characters: ${pth}`);
          err.code = "EINVAL";
          throw err;
        }
      }
    };
    module2.exports = (input, opts) => Promise.resolve().then(() => {
      checkPath(input);
      opts = Object.assign({}, defaults, opts);
      const mkdir = pify(opts.fs.mkdir);
      const stat = pify(opts.fs.stat);
      const make = (pth) => {
        return mkdir(pth, opts.mode).then(() => pth).catch((err) => {
          if (err.code === "ENOENT") {
            if (err.message.includes("null bytes") || path.dirname(pth) === pth) {
              throw err;
            }
            return make(path.dirname(pth)).then(() => make(pth));
          }
          return stat(pth).then((stats) => stats.isDirectory() ? pth : Promise.reject()).catch(() => {
            throw err;
          });
        });
      };
      return make(path.resolve(input));
    });
    module2.exports.sync = (input, opts) => {
      checkPath(input);
      opts = Object.assign({}, defaults, opts);
      const make = (pth) => {
        try {
          opts.fs.mkdirSync(pth, opts.mode);
        } catch (err) {
          if (err.code === "ENOENT") {
            if (err.message.includes("null bytes") || path.dirname(pth) === pth) {
              throw err;
            }
            make(path.dirname(pth));
            return make(pth);
          }
          try {
            if (!opts.fs.statSync(pth).isDirectory()) {
              throw new Error("The path is not a directory");
            }
          } catch (_2) {
            throw err;
          }
        }
        return pth;
      };
      return make(path.resolve(input));
    };
  }
});

// ../node_modules/download-git-repo/node_modules/file-type/index.js
var require_file_type7 = __commonJS({
  "../node_modules/download-git-repo/node_modules/file-type/index.js"(exports2, module2) {
    "use strict";
    var toBytes = (s) => [...s].map((c) => c.charCodeAt(0));
    var xpiZipFilename2 = toBytes("META-INF/mozilla.rsa");
    var oxmlContentTypes2 = toBytes("[Content_Types].xml");
    var oxmlRels2 = toBytes("_rels/.rels");
    module2.exports = (input) => {
      const buf = input instanceof Uint8Array ? input : new Uint8Array(input);
      if (!(buf && buf.length > 1)) {
        return null;
      }
      const check = (header, options) => {
        options = Object.assign({
          offset: 0
        }, options);
        for (let i = 0; i < header.length; i++) {
          if (options.mask) {
            if (header[i] !== (options.mask[i] & buf[i + options.offset])) {
              return false;
            }
          } else if (header[i] !== buf[i + options.offset]) {
            return false;
          }
        }
        return true;
      };
      const checkString = (header, options) => check(toBytes(header), options);
      if (check([255, 216, 255])) {
        return {
          ext: "jpg",
          mime: "image/jpeg"
        };
      }
      if (check([137, 80, 78, 71, 13, 10, 26, 10])) {
        return {
          ext: "png",
          mime: "image/png"
        };
      }
      if (check([71, 73, 70])) {
        return {
          ext: "gif",
          mime: "image/gif"
        };
      }
      if (check([87, 69, 66, 80], { offset: 8 })) {
        return {
          ext: "webp",
          mime: "image/webp"
        };
      }
      if (check([70, 76, 73, 70])) {
        return {
          ext: "flif",
          mime: "image/flif"
        };
      }
      if ((check([73, 73, 42, 0]) || check([77, 77, 0, 42])) && check([67, 82], { offset: 8 })) {
        return {
          ext: "cr2",
          mime: "image/x-canon-cr2"
        };
      }
      if (check([73, 73, 42, 0]) || check([77, 77, 0, 42])) {
        return {
          ext: "tif",
          mime: "image/tiff"
        };
      }
      if (check([66, 77])) {
        return {
          ext: "bmp",
          mime: "image/bmp"
        };
      }
      if (check([73, 73, 188])) {
        return {
          ext: "jxr",
          mime: "image/vnd.ms-photo"
        };
      }
      if (check([56, 66, 80, 83])) {
        return {
          ext: "psd",
          mime: "image/vnd.adobe.photoshop"
        };
      }
      if (check([80, 75, 3, 4])) {
        if (check([109, 105, 109, 101, 116, 121, 112, 101, 97, 112, 112, 108, 105, 99, 97, 116, 105, 111, 110, 47, 101, 112, 117, 98, 43, 122, 105, 112], { offset: 30 })) {
          return {
            ext: "epub",
            mime: "application/epub+zip"
          };
        }
        if (check(xpiZipFilename2, { offset: 30 })) {
          return {
            ext: "xpi",
            mime: "application/x-xpinstall"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", { offset: 30 })) {
          return {
            ext: "odt",
            mime: "application/vnd.oasis.opendocument.text"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", { offset: 30 })) {
          return {
            ext: "ods",
            mime: "application/vnd.oasis.opendocument.spreadsheet"
          };
        }
        if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", { offset: 30 })) {
          return {
            ext: "odp",
            mime: "application/vnd.oasis.opendocument.presentation"
          };
        }
        if (check(oxmlContentTypes2, { offset: 30 }) || check(oxmlRels2, { offset: 30 })) {
          const sliced = buf.subarray(4, 4 + 2e3);
          const nextZipHeaderIndex = (arr) => arr.findIndex((el, i, arr2) => arr2[i] === 80 && arr2[i + 1] === 75 && arr2[i + 2] === 3 && arr2[i + 3] === 4);
          const header2Pos = nextZipHeaderIndex(sliced);
          if (header2Pos !== -1) {
            const slicedAgain = buf.subarray(header2Pos + 8, header2Pos + 8 + 1e3);
            const header3Pos = nextZipHeaderIndex(slicedAgain);
            if (header3Pos !== -1) {
              const offset = 8 + header2Pos + header3Pos + 30;
              if (checkString("word/", { offset })) {
                return {
                  ext: "docx",
                  mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                };
              }
              if (checkString("ppt/", { offset })) {
                return {
                  ext: "pptx",
                  mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                };
              }
              if (checkString("xl/", { offset })) {
                return {
                  ext: "xlsx",
                  mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                };
              }
            }
          }
        }
      }
      if (check([80, 75]) && (buf[2] === 3 || buf[2] === 5 || buf[2] === 7) && (buf[3] === 4 || buf[3] === 6 || buf[3] === 8)) {
        return {
          ext: "zip",
          mime: "application/zip"
        };
      }
      if (check([117, 115, 116, 97, 114], { offset: 257 })) {
        return {
          ext: "tar",
          mime: "application/x-tar"
        };
      }
      if (check([82, 97, 114, 33, 26, 7]) && (buf[6] === 0 || buf[6] === 1)) {
        return {
          ext: "rar",
          mime: "application/x-rar-compressed"
        };
      }
      if (check([31, 139, 8])) {
        return {
          ext: "gz",
          mime: "application/gzip"
        };
      }
      if (check([66, 90, 104])) {
        return {
          ext: "bz2",
          mime: "application/x-bzip2"
        };
      }
      if (check([55, 122, 188, 175, 39, 28])) {
        return {
          ext: "7z",
          mime: "application/x-7z-compressed"
        };
      }
      if (check([120, 1])) {
        return {
          ext: "dmg",
          mime: "application/x-apple-diskimage"
        };
      }
      if (check([51, 103, 112, 53]) || check([0, 0, 0]) && check([102, 116, 121, 112], { offset: 4 }) && (check([109, 112, 52, 49], { offset: 8 }) || check([109, 112, 52, 50], { offset: 8 }) || check([105, 115, 111, 109], { offset: 8 }) || check([105, 115, 111, 50], { offset: 8 }) || check([109, 109, 112, 52], { offset: 8 }) || check([77, 52, 86], { offset: 8 }) || check([100, 97, 115, 104], { offset: 8 }))) {
        return {
          ext: "mp4",
          mime: "video/mp4"
        };
      }
      if (check([77, 84, 104, 100])) {
        return {
          ext: "mid",
          mime: "audio/midi"
        };
      }
      if (check([26, 69, 223, 163])) {
        const sliced = buf.subarray(4, 4 + 4096);
        const idPos = sliced.findIndex((el, i, arr) => arr[i] === 66 && arr[i + 1] === 130);
        if (idPos !== -1) {
          const docTypePos = idPos + 3;
          const findDocType = (type) => [...type].every((c, i) => sliced[docTypePos + i] === c.charCodeAt(0));
          if (findDocType("matroska")) {
            return {
              ext: "mkv",
              mime: "video/x-matroska"
            };
          }
          if (findDocType("webm")) {
            return {
              ext: "webm",
              mime: "video/webm"
            };
          }
        }
      }
      if (check([0, 0, 0, 20, 102, 116, 121, 112, 113, 116, 32, 32]) || check([102, 114, 101, 101], { offset: 4 }) || check([102, 116, 121, 112, 113, 116, 32, 32], { offset: 4 }) || check([109, 100, 97, 116], { offset: 4 }) || check([119, 105, 100, 101], { offset: 4 })) {
        return {
          ext: "mov",
          mime: "video/quicktime"
        };
      }
      if (check([82, 73, 70, 70])) {
        if (check([65, 86, 73], { offset: 8 })) {
          return {
            ext: "avi",
            mime: "video/x-msvideo"
          };
        }
        if (check([87, 65, 86, 69], { offset: 8 })) {
          return {
            ext: "wav",
            mime: "audio/x-wav"
          };
        }
        if (check([81, 76, 67, 77], { offset: 8 })) {
          return {
            ext: "qcp",
            mime: "audio/qcelp"
          };
        }
      }
      if (check([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        return {
          ext: "wmv",
          mime: "video/x-ms-wmv"
        };
      }
      if (check([0, 0, 1, 186]) || check([0, 0, 1, 179])) {
        return {
          ext: "mpg",
          mime: "video/mpeg"
        };
      }
      if (check([102, 116, 121, 112, 51, 103], { offset: 4 })) {
        return {
          ext: "3gp",
          mime: "video/3gpp"
        };
      }
      for (let start = 0; start < 2 && start < buf.length - 16; start++) {
        if (check([73, 68, 51], { offset: start }) || check([255, 226], { offset: start, mask: [255, 226] })) {
          return {
            ext: "mp3",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 228], { offset: start, mask: [255, 228] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 248], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp2",
            mime: "audio/mpeg"
          };
        }
        if (check([255, 240], { offset: start, mask: [255, 252] })) {
          return {
            ext: "mp4",
            mime: "audio/mpeg"
          };
        }
      }
      if (check([102, 116, 121, 112, 77, 52, 65], { offset: 4 }) || check([77, 52, 65, 32])) {
        return {
          ext: "m4a",
          mime: "audio/m4a"
        };
      }
      if (check([79, 112, 117, 115, 72, 101, 97, 100], { offset: 28 })) {
        return {
          ext: "opus",
          mime: "audio/opus"
        };
      }
      if (check([79, 103, 103, 83])) {
        if (check([128, 116, 104, 101, 111, 114, 97], { offset: 28 })) {
          return {
            ext: "ogv",
            mime: "video/ogg"
          };
        }
        if (check([1, 118, 105, 100, 101, 111, 0], { offset: 28 })) {
          return {
            ext: "ogm",
            mime: "video/ogg"
          };
        }
        if (check([127, 70, 76, 65, 67], { offset: 28 })) {
          return {
            ext: "oga",
            mime: "audio/ogg"
          };
        }
        if (check([83, 112, 101, 101, 120, 32, 32], { offset: 28 })) {
          return {
            ext: "spx",
            mime: "audio/ogg"
          };
        }
        if (check([1, 118, 111, 114, 98, 105, 115], { offset: 28 })) {
          return {
            ext: "ogg",
            mime: "audio/ogg"
          };
        }
        return {
          ext: "ogx",
          mime: "application/ogg"
        };
      }
      if (check([102, 76, 97, 67])) {
        return {
          ext: "flac",
          mime: "audio/x-flac"
        };
      }
      if (check([77, 65, 67, 32])) {
        return {
          ext: "ape",
          mime: "audio/ape"
        };
      }
      if (check([35, 33, 65, 77, 82, 10])) {
        return {
          ext: "amr",
          mime: "audio/amr"
        };
      }
      if (check([37, 80, 68, 70])) {
        return {
          ext: "pdf",
          mime: "application/pdf"
        };
      }
      if (check([77, 90])) {
        return {
          ext: "exe",
          mime: "application/x-msdownload"
        };
      }
      if ((buf[0] === 67 || buf[0] === 70) && check([87, 83], { offset: 1 })) {
        return {
          ext: "swf",
          mime: "application/x-shockwave-flash"
        };
      }
      if (check([123, 92, 114, 116, 102])) {
        return {
          ext: "rtf",
          mime: "application/rtf"
        };
      }
      if (check([0, 97, 115, 109])) {
        return {
          ext: "wasm",
          mime: "application/wasm"
        };
      }
      if (check([119, 79, 70, 70]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff",
          mime: "font/woff"
        };
      }
      if (check([119, 79, 70, 50]) && (check([0, 1, 0, 0], { offset: 4 }) || check([79, 84, 84, 79], { offset: 4 }))) {
        return {
          ext: "woff2",
          mime: "font/woff2"
        };
      }
      if (check([76, 80], { offset: 34 }) && (check([0, 0, 1], { offset: 8 }) || check([1, 0, 2], { offset: 8 }) || check([2, 0, 2], { offset: 8 }))) {
        return {
          ext: "eot",
          mime: "application/octet-stream"
        };
      }
      if (check([0, 1, 0, 0, 0])) {
        return {
          ext: "ttf",
          mime: "font/ttf"
        };
      }
      if (check([79, 84, 84, 79, 0])) {
        return {
          ext: "otf",
          mime: "font/otf"
        };
      }
      if (check([0, 0, 1, 0])) {
        return {
          ext: "ico",
          mime: "image/x-icon"
        };
      }
      if (check([0, 0, 2, 0])) {
        return {
          ext: "cur",
          mime: "image/x-icon"
        };
      }
      if (check([70, 76, 86, 1])) {
        return {
          ext: "flv",
          mime: "video/x-flv"
        };
      }
      if (check([37, 33])) {
        return {
          ext: "ps",
          mime: "application/postscript"
        };
      }
      if (check([253, 55, 122, 88, 90, 0])) {
        return {
          ext: "xz",
          mime: "application/x-xz"
        };
      }
      if (check([83, 81, 76, 105])) {
        return {
          ext: "sqlite",
          mime: "application/x-sqlite3"
        };
      }
      if (check([78, 69, 83, 26])) {
        return {
          ext: "nes",
          mime: "application/x-nintendo-nes-rom"
        };
      }
      if (check([67, 114, 50, 52])) {
        return {
          ext: "crx",
          mime: "application/x-google-chrome-extension"
        };
      }
      if (check([77, 83, 67, 70]) || check([73, 83, 99, 40])) {
        return {
          ext: "cab",
          mime: "application/vnd.ms-cab-compressed"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62, 10, 100, 101, 98, 105, 97, 110, 45, 98, 105, 110, 97, 114, 121])) {
        return {
          ext: "deb",
          mime: "application/x-deb"
        };
      }
      if (check([33, 60, 97, 114, 99, 104, 62])) {
        return {
          ext: "ar",
          mime: "application/x-unix-archive"
        };
      }
      if (check([237, 171, 238, 219])) {
        return {
          ext: "rpm",
          mime: "application/x-rpm"
        };
      }
      if (check([31, 160]) || check([31, 157])) {
        return {
          ext: "Z",
          mime: "application/x-compress"
        };
      }
      if (check([76, 90, 73, 80])) {
        return {
          ext: "lz",
          mime: "application/x-lzip"
        };
      }
      if (check([208, 207, 17, 224, 161, 177, 26, 225])) {
        return {
          ext: "msi",
          mime: "application/x-msi"
        };
      }
      if (check([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2])) {
        return {
          ext: "mxf",
          mime: "application/mxf"
        };
      }
      if (check([71], { offset: 4 }) && (check([71], { offset: 192 }) || check([71], { offset: 196 }))) {
        return {
          ext: "mts",
          mime: "video/mp2t"
        };
      }
      if (check([66, 76, 69, 78, 68, 69, 82])) {
        return {
          ext: "blend",
          mime: "application/x-blender"
        };
      }
      if (check([66, 80, 71, 251])) {
        return {
          ext: "bpg",
          mime: "image/bpg"
        };
      }
      if (check([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10])) {
        if (check([106, 112, 50, 32], { offset: 20 })) {
          return {
            ext: "jp2",
            mime: "image/jp2"
          };
        }
        if (check([106, 112, 120, 32], { offset: 20 })) {
          return {
            ext: "jpx",
            mime: "image/jpx"
          };
        }
        if (check([106, 112, 109, 32], { offset: 20 })) {
          return {
            ext: "jpm",
            mime: "image/jpm"
          };
        }
        if (check([109, 106, 112, 50], { offset: 20 })) {
          return {
            ext: "mj2",
            mime: "image/mj2"
          };
        }
      }
      if (check([70, 79, 82, 77, 0])) {
        return {
          ext: "aif",
          mime: "audio/aiff"
        };
      }
      if (checkString("<?xml ")) {
        return {
          ext: "xml",
          mime: "application/xml"
        };
      }
      if (check([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 })) {
        return {
          ext: "mobi",
          mime: "application/x-mobipocket-ebook"
        };
      }
      if (check([102, 116, 121, 112], { offset: 4 })) {
        if (check([109, 105, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif"
          };
        }
        if (check([109, 115, 102, 49], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heif-sequence"
          };
        }
        if (check([104, 101, 105, 99], { offset: 8 }) || check([104, 101, 105, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic"
          };
        }
        if (check([104, 101, 118, 99], { offset: 8 }) || check([104, 101, 118, 120], { offset: 8 })) {
          return {
            ext: "heic",
            mime: "image/heic-sequence"
          };
        }
      }
      if (check([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10])) {
        return {
          ext: "ktx",
          mime: "image/ktx"
        };
      }
      return null;
    };
  }
});

// ../node_modules/download-git-repo/node_modules/download/index.js
var require_download2 = __commonJS({
  "../node_modules/download-git-repo/node_modules/download/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var url = require("url");
    var caw = require_caw();
    var contentDisposition = require_content_disposition();
    var archiveType = require_archive_type();
    var decompress = require_decompress();
    var filenamify = require_filenamify2();
    var getStream = require_get_stream6();
    var got = require_got();
    var makeDir = require_make_dir4();
    var pify = require_pify6();
    var pEvent = require_p_event();
    var fileType2 = require_file_type7();
    var extName = require_ext_name();
    var fsP = pify(fs);
    var filenameFromPath = (res) => path.basename(url.parse(res.requestUrl).pathname);
    var getExtFromMime = (res) => {
      const header = res.headers["content-type"];
      if (!header) {
        return null;
      }
      const exts = extName.mime(header);
      if (exts.length !== 1) {
        return null;
      }
      return exts[0].ext;
    };
    var getFilename = (res, data) => {
      const header = res.headers["content-disposition"];
      if (header) {
        const parsed = contentDisposition.parse(header);
        if (parsed.parameters && parsed.parameters.filename) {
          return parsed.parameters.filename;
        }
      }
      let filename = filenameFromPath(res);
      if (!path.extname(filename)) {
        const ext = (fileType2(data) || {}).ext || getExtFromMime(res);
        if (ext) {
          filename = `${filename}.${ext}`;
        }
      }
      return filename;
    };
    var getProtocolFromUri = (uri) => {
      let { protocol } = url.parse(uri);
      if (protocol) {
        protocol = protocol.slice(0, -1);
      }
      return protocol;
    };
    module2.exports = (uri, output, opts) => {
      if (typeof output === "object") {
        opts = output;
        output = null;
      }
      const protocol = getProtocolFromUri(uri);
      opts = Object.assign({
        encoding: null,
        rejectUnauthorized: process.env.npm_config_strict_ssl !== "false"
      }, opts);
      const agent = caw(opts.proxy, { protocol });
      const stream2 = got.stream(uri, Object.assign({ agent }, opts)).on("redirect", (response, nextOptions) => {
        const redirectProtocol = getProtocolFromUri(nextOptions.href);
        if (redirectProtocol && redirectProtocol !== protocol) {
          nextOptions.agent = caw(opts.proxy, { protocol: redirectProtocol });
        }
      });
      const promise = pEvent(stream2, "response").then((res) => {
        const encoding = opts.encoding === null ? "buffer" : opts.encoding;
        return Promise.all([getStream(stream2, { encoding }), res]);
      }).then((result) => {
        const [data, res] = result;
        if (!output) {
          return opts.extract && archiveType(data) ? decompress(data, opts) : data;
        }
        const filename = opts.filename || filenamify(getFilename(res, data));
        const outputFilepath = path.join(output, filename);
        if (opts.extract && archiveType(data)) {
          return decompress(data, path.dirname(outputFilepath), opts);
        }
        return makeDir(path.dirname(outputFilepath)).then(() => fsP.writeFile(outputFilepath, data)).then(() => data);
      });
      stream2.then = promise.then.bind(promise);
      stream2.catch = promise.catch.bind(promise);
      return stream2;
    };
  }
});

// ../node_modules/git-clone/index.js
var require_git_clone = __commonJS({
  "../node_modules/git-clone/index.js"(exports2, module2) {
    var spawn = require("child_process").spawn;
    module2.exports = function(repo, targetPath, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = null;
      }
      opts = opts || {};
      var git = opts.git || "git";
      var args = ["clone"];
      if (opts.shallow) {
        args.push("--depth");
        args.push("1");
      }
      args.push("--");
      args.push(repo);
      args.push(targetPath);
      var process2 = spawn(git, args);
      process2.on("close", function(status) {
        if (status == 0) {
          if (opts.checkout) {
            _checkout();
          } else {
            cb && cb();
          }
        } else {
          cb && cb(new Error("'git clone' failed with status " + status));
        }
      });
      function _checkout() {
        var args2 = ["checkout", opts.checkout];
        var process3 = spawn(git, args2, { cwd: targetPath });
        process3.on("close", function(status) {
          if (status == 0) {
            cb && cb();
          } else {
            cb && cb(new Error("'git checkout' failed with status " + status));
          }
        });
      }
    };
  }
});

// ../node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "../node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// ../node_modules/fs.realpath/index.js
var require_fs6 = __commonJS({
  "../node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// ../node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "../node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// ../node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "../node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// ../node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "../node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// ../node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "../node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_2, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// ../node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "../node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// ../node_modules/glob/common.js
var require_common3 = __commonJS({
  "../node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || Object.create(null);
      self2.statCache = options.statCache || Object.create(null);
      self2.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// ../node_modules/glob/sync.js
var require_sync7 = __commonJS({
  "../node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs6();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common3();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// ../node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "../node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// ../node_modules/glob/glob.js
var require_glob = __commonJS({
  "../node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var rp = require_fs6();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync7();
    var common = require_common3();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// ../node_modules/rimraf/rimraf.js
var require_rimraf2 = __commonJS({
  "../node_modules/rimraf/rimraf.js"(exports2, module2) {
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// ../node_modules/download-git-repo/index.js
var require_download_git_repo = __commonJS({
  "../node_modules/download-git-repo/index.js"(exports2, module2) {
    var downloadUrl = require_download2();
    var gitclone = require_git_clone();
    var rm = require_rimraf2().sync;
    module2.exports = download;
    function download(repo, dest, opts, fn) {
      if (typeof opts === "function") {
        fn = opts;
        opts = null;
      }
      opts = opts || {};
      var clone = opts.clone || false;
      delete opts.clone;
      repo = normalize(repo);
      var url = repo.url || getUrl(repo, clone);
      if (clone) {
        var cloneOptions = __spreadValues({
          checkout: repo.checkout,
          shallow: repo.checkout === "master"
        }, opts);
        gitclone(url, dest, cloneOptions, function(err) {
          if (err === void 0) {
            rm(dest + "/.git");
            fn();
          } else {
            fn(err);
          }
        });
      } else {
        var downloadOptions = __spreadProps(__spreadValues({
          extract: true,
          strip: 1,
          mode: "666"
        }, opts), {
          headers: __spreadValues({
            accept: "application/zip"
          }, opts.headers || {})
        });
        downloadUrl(url, dest, downloadOptions).then(function(data) {
          fn();
        }).catch(function(err) {
          fn(err);
        });
      }
    }
    function normalize(repo) {
      var regex = /^(?:(direct):([^#]+)(?:#(.+))?)$/;
      var match = regex.exec(repo);
      if (match) {
        var url = match[2];
        var directCheckout = match[3] || "master";
        return {
          type: "direct",
          url,
          checkout: directCheckout
        };
      } else {
        regex = /^(?:(github|gitlab|bitbucket):)?(?:(.+):)?([^/]+)\/([^#]+)(?:#(.+))?$/;
        match = regex.exec(repo);
        var type = match[1] || "github";
        var origin = match[2] || null;
        var owner = match[3];
        var name = match[4];
        var checkout = match[5] || "master";
        if (origin == null) {
          if (type === "github") {
            origin = "github.com";
          } else if (type === "gitlab") {
            origin = "gitlab.com";
          } else if (type === "bitbucket") {
            origin = "bitbucket.org";
          }
        }
        return {
          type,
          origin,
          owner,
          name,
          checkout
        };
      }
    }
    function addProtocol(origin, clone) {
      if (!/^(f|ht)tps?:\/\//i.test(origin)) {
        if (clone) {
          origin = "git@" + origin;
        } else {
          origin = "https://" + origin;
        }
      }
      return origin;
    }
    function getUrl(repo, clone) {
      var url;
      var origin = addProtocol(repo.origin, clone);
      if (/^git@/i.test(origin)) {
        origin = origin + ":";
      } else {
        origin = origin + "/";
      }
      if (clone) {
        url = origin + repo.owner + "/" + repo.name + ".git";
      } else {
        if (repo.type === "github") {
          url = origin + repo.owner + "/" + repo.name + "/archive/" + repo.checkout + ".zip";
        } else if (repo.type === "gitlab") {
          url = origin + repo.owner + "/" + repo.name + "/repository/archive.zip?ref=" + repo.checkout;
        } else if (repo.type === "bitbucket") {
          url = origin + repo.owner + "/" + repo.name + "/get/" + repo.checkout + ".zip";
        }
      }
      return url;
    }
  }
});

// ../node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "../node_modules/axios/lib/helpers/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };
  }
});

// ../node_modules/axios/lib/utils.js
var require_utils8 = __commonJS({
  "../node_modules/axios/lib/utils.js"(exports2, module2) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    function isArray(val) {
      return toString.call(val) === "[object Array]";
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    function isArrayBuffer(val) {
      return toString.call(val) === "[object ArrayBuffer]";
    }
    function isFormData(val) {
      return typeof FormData !== "undefined" && val instanceof FormData;
    }
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (toString.call(val) !== "[object Object]") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isDate(val) {
      return toString.call(val) === "[object Date]";
    }
    function isFile(val) {
      return toString.call(val) === "[object File]";
    }
    function isBlob(val) {
      return toString.call(val) === "[object Blob]";
    }
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
    }
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
    }
    function isStandardBrowserEnv() {
      if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    module2.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM
    };
  }
});

// ../node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "../node_modules/axios/lib/helpers/buildURL.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module2.exports = function buildURL(url, params, paramsSerializer) {
      if (!params) {
        return url;
      }
      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize2(val, key) {
          if (val === null || typeof val === "undefined") {
            return;
          }
          if (utils.isArray(val)) {
            key = key + "[]";
          } else {
            val = [val];
          }
          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + "=" + encode(v));
          });
        });
        serializedParams = parts.join("&");
      }
      if (serializedParams) {
        var hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// ../node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "../node_modules/axios/lib/core/InterceptorManager.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module2.exports = InterceptorManager;
  }
});

// ../node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "../node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    module2.exports = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// ../node_modules/axios/lib/core/enhanceError.js
var require_enhanceError = __commonJS({
  "../node_modules/axios/lib/core/enhanceError.js"(exports2, module2) {
    "use strict";
    module2.exports = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }
      error.request = request;
      error.response = response;
      error.isAxiosError = true;
      error.toJSON = function toJSON() {
        return {
          message: this.message,
          name: this.name,
          description: this.description,
          number: this.number,
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          config: this.config,
          code: this.code
        };
      };
      return error;
    };
  }
});

// ../node_modules/axios/lib/core/createError.js
var require_createError = __commonJS({
  "../node_modules/axios/lib/core/createError.js"(exports2, module2) {
    "use strict";
    var enhanceError = require_enhanceError();
    module2.exports = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };
  }
});

// ../node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "../node_modules/axios/lib/core/settle.js"(exports2, module2) {
    "use strict";
    var createError = require_createError();
    module2.exports = function settle(resolve2, reject2, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve2(response);
      } else {
        reject2(createError("Request failed with status code " + response.status, response.config, null, response.request, response));
      }
    };
  }
});

// ../node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "../node_modules/axios/lib/helpers/cookies.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path)) {
            cookie.push("path=" + path);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }() : function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove() {
        }
      };
    }();
  }
});

// ../node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "../node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };
  }
});

// ../node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "../node_modules/axios/lib/helpers/combineURLs.js"(exports2, module2) {
    "use strict";
    module2.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// ../node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "../node_modules/axios/lib/core/buildFullPath.js"(exports2, module2) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module2.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// ../node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "../node_modules/axios/lib/helpers/parseHeaders.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module2.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// ../node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "../node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    module2.exports = utils.isStandardBrowserEnv() ? function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement("a");
      var originURL;
      function resolveURL(url) {
        var href = url;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();
  }
});

// ../node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "../node_modules/axios/lib/adapters/xhr.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var createError = require_createError();
    module2.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve2, reject2) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        if (utils.isFormData(requestData)) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(resolve2, reject2, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject2(createError("Request aborted", config, "ECONNABORTED", request));
          request = null;
        };
        request.onerror = function handleError() {
          reject2(createError("Network Error", config, null, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = "timeout of " + config.timeout + "ms exceeded";
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject2(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", request));
          request = null;
        };
        if (utils.isStandardBrowserEnv()) {
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : void 0;
          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }
        if ("setRequestHeader" in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }
            request.abort();
            reject2(cancel);
            request = null;
          });
        }
        if (!requestData) {
          requestData = null;
        }
        request.send(requestData);
      });
    };
  }
});

// ../node_modules/ms/index.js
var require_ms = __commonJS({
  "../node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// ../node_modules/debug/src/common.js
var require_common4 = __commonJS({
  "../node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// ../node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "../node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// ../node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "../node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_2, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// ../node_modules/debug/src/index.js
var require_src7 = __commonJS({
  "../node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node2();
    }
  }
});

// ../node_modules/follow-redirects/debug.js
var require_debug = __commonJS({
  "../node_modules/follow-redirects/debug.js"(exports2, module2) {
    var debug;
    module2.exports = function() {
      if (!debug) {
        try {
          debug = require_src7()("follow-redirects");
        } catch (error) {
        }
        if (typeof debug !== "function") {
          debug = function() {
          };
        }
      }
      debug.apply(null, arguments);
    };
  }
});

// ../node_modules/follow-redirects/index.js
var require_follow_redirects = __commonJS({
  "../node_modules/follow-redirects/index.js"(exports2, module2) {
    var url = require("url");
    var URL2 = url.URL;
    var http = require("http");
    var https = require("https");
    var Writable = require("stream").Writable;
    var assert = require("assert");
    var debug = require_debug();
    var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
    var eventHandlers = Object.create(null);
    events.forEach(function(event) {
      eventHandlers[event] = function(arg1, arg2, arg3) {
        this._redirectable.emit(event, arg1, arg2, arg3);
      };
    });
    var RedirectionError = createErrorType("ERR_FR_REDIRECTION_FAILURE", "Redirected request failed");
    var TooManyRedirectsError = createErrorType("ERR_FR_TOO_MANY_REDIRECTS", "Maximum number of redirects exceeded");
    var MaxBodyLengthExceededError = createErrorType("ERR_FR_MAX_BODY_LENGTH_EXCEEDED", "Request body larger than maxBodyLength limit");
    var WriteAfterEndError = createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    function RedirectableRequest(options, responseCallback) {
      Writable.call(this);
      this._sanitizeOptions(options);
      this._options = options;
      this._ended = false;
      this._ending = false;
      this._redirectCount = 0;
      this._redirects = [];
      this._requestBodyLength = 0;
      this._requestBodyBuffers = [];
      if (responseCallback) {
        this.on("response", responseCallback);
      }
      var self2 = this;
      this._onNativeResponse = function(response) {
        self2._processResponse(response);
      };
      this._performRequest();
    }
    RedirectableRequest.prototype = Object.create(Writable.prototype);
    RedirectableRequest.prototype.abort = function() {
      abortRequest(this._currentRequest);
      this.emit("abort");
    };
    RedirectableRequest.prototype.write = function(data, encoding, callback) {
      if (this._ending) {
        throw new WriteAfterEndError();
      }
      if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
        throw new TypeError("data should be a string, Buffer or Uint8Array");
      }
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (data.length === 0) {
        if (callback) {
          callback();
        }
        return;
      }
      if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
        this._requestBodyLength += data.length;
        this._requestBodyBuffers.push({ data, encoding });
        this._currentRequest.write(data, encoding, callback);
      } else {
        this.emit("error", new MaxBodyLengthExceededError());
        this.abort();
      }
    };
    RedirectableRequest.prototype.end = function(data, encoding, callback) {
      if (typeof data === "function") {
        callback = data;
        data = encoding = null;
      } else if (typeof encoding === "function") {
        callback = encoding;
        encoding = null;
      }
      if (!data) {
        this._ended = this._ending = true;
        this._currentRequest.end(null, null, callback);
      } else {
        var self2 = this;
        var currentRequest = this._currentRequest;
        this.write(data, encoding, function() {
          self2._ended = true;
          currentRequest.end(null, null, callback);
        });
        this._ending = true;
      }
    };
    RedirectableRequest.prototype.setHeader = function(name, value) {
      this._options.headers[name] = value;
      this._currentRequest.setHeader(name, value);
    };
    RedirectableRequest.prototype.removeHeader = function(name) {
      delete this._options.headers[name];
      this._currentRequest.removeHeader(name);
    };
    RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
      var self2 = this;
      function destroyOnTimeout(socket) {
        socket.setTimeout(msecs);
        socket.removeListener("timeout", socket.destroy);
        socket.addListener("timeout", socket.destroy);
      }
      function startTimer(socket) {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
        }
        self2._timeout = setTimeout(function() {
          self2.emit("timeout");
          clearTimer();
        }, msecs);
        destroyOnTimeout(socket);
      }
      function clearTimer() {
        if (self2._timeout) {
          clearTimeout(self2._timeout);
          self2._timeout = null;
        }
        self2.removeListener("abort", clearTimer);
        self2.removeListener("error", clearTimer);
        self2.removeListener("response", clearTimer);
        if (callback) {
          self2.removeListener("timeout", callback);
        }
        if (!self2.socket) {
          self2._currentRequest.removeListener("socket", startTimer);
        }
      }
      if (callback) {
        this.on("timeout", callback);
      }
      if (this.socket) {
        startTimer(this.socket);
      } else {
        this._currentRequest.once("socket", startTimer);
      }
      this.on("socket", destroyOnTimeout);
      this.on("abort", clearTimer);
      this.on("error", clearTimer);
      this.on("response", clearTimer);
      return this;
    };
    [
      "flushHeaders",
      "getHeader",
      "setNoDelay",
      "setSocketKeepAlive"
    ].forEach(function(method) {
      RedirectableRequest.prototype[method] = function(a, b) {
        return this._currentRequest[method](a, b);
      };
    });
    ["aborted", "connection", "socket"].forEach(function(property) {
      Object.defineProperty(RedirectableRequest.prototype, property, {
        get: function() {
          return this._currentRequest[property];
        }
      });
    });
    RedirectableRequest.prototype._sanitizeOptions = function(options) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.host) {
        if (!options.hostname) {
          options.hostname = options.host;
        }
        delete options.host;
      }
      if (!options.pathname && options.path) {
        var searchPos = options.path.indexOf("?");
        if (searchPos < 0) {
          options.pathname = options.path;
        } else {
          options.pathname = options.path.substring(0, searchPos);
          options.search = options.path.substring(searchPos);
        }
      }
    };
    RedirectableRequest.prototype._performRequest = function() {
      var protocol = this._options.protocol;
      var nativeProtocol = this._options.nativeProtocols[protocol];
      if (!nativeProtocol) {
        this.emit("error", new TypeError("Unsupported protocol " + protocol));
        return;
      }
      if (this._options.agents) {
        var scheme = protocol.substr(0, protocol.length - 1);
        this._options.agent = this._options.agents[scheme];
      }
      var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
      this._currentUrl = url.format(this._options);
      request._redirectable = this;
      for (var e = 0; e < events.length; e++) {
        request.on(events[e], eventHandlers[events[e]]);
      }
      if (this._isRedirect) {
        var i = 0;
        var self2 = this;
        var buffers = this._requestBodyBuffers;
        (function writeNext(error) {
          if (request === self2._currentRequest) {
            if (error) {
              self2.emit("error", error);
            } else if (i < buffers.length) {
              var buffer = buffers[i++];
              if (!request.finished) {
                request.write(buffer.data, buffer.encoding, writeNext);
              }
            } else if (self2._ended) {
              request.end();
            }
          }
        })();
      }
    };
    RedirectableRequest.prototype._processResponse = function(response) {
      var statusCode = response.statusCode;
      if (this._options.trackRedirects) {
        this._redirects.push({
          url: this._currentUrl,
          headers: response.headers,
          statusCode
        });
      }
      var location = response.headers.location;
      if (location && this._options.followRedirects !== false && statusCode >= 300 && statusCode < 400) {
        abortRequest(this._currentRequest);
        response.destroy();
        if (++this._redirectCount > this._options.maxRedirects) {
          this.emit("error", new TooManyRedirectsError());
          return;
        }
        if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
          this._options.method = "GET";
          this._requestBodyBuffers = [];
          removeMatchingHeaders(/^content-/i, this._options.headers);
        }
        var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
        var currentUrlParts = url.parse(this._currentUrl);
        var currentHost = currentHostHeader || currentUrlParts.host;
        var currentUrl = /^\w+:/.test(location) ? this._currentUrl : url.format(Object.assign(currentUrlParts, { host: currentHost }));
        var redirectUrl;
        try {
          redirectUrl = url.resolve(currentUrl, location);
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
          return;
        }
        debug("redirecting to", redirectUrl);
        this._isRedirect = true;
        var redirectUrlParts = url.parse(redirectUrl);
        Object.assign(this._options, redirectUrlParts);
        if (!(redirectUrlParts.host === currentHost || isSubdomainOf(redirectUrlParts.host, currentHost))) {
          removeMatchingHeaders(/^authorization$/i, this._options.headers);
        }
        if (typeof this._options.beforeRedirect === "function") {
          var responseDetails = { headers: response.headers };
          try {
            this._options.beforeRedirect.call(null, this._options, responseDetails);
          } catch (err) {
            this.emit("error", err);
            return;
          }
          this._sanitizeOptions(this._options);
        }
        try {
          this._performRequest();
        } catch (cause) {
          this.emit("error", new RedirectionError(cause));
        }
      } else {
        response.responseUrl = this._currentUrl;
        response.redirects = this._redirects;
        this.emit("response", response);
        this._requestBodyBuffers = [];
      }
    };
    function wrap(protocols) {
      var exports3 = {
        maxRedirects: 21,
        maxBodyLength: 10 * 1024 * 1024
      };
      var nativeProtocols = {};
      Object.keys(protocols).forEach(function(scheme) {
        var protocol = scheme + ":";
        var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
        var wrappedProtocol = exports3[scheme] = Object.create(nativeProtocol);
        function request(input, options, callback) {
          if (typeof input === "string") {
            var urlStr = input;
            try {
              input = urlToOptions(new URL2(urlStr));
            } catch (err) {
              input = url.parse(urlStr);
            }
          } else if (URL2 && input instanceof URL2) {
            input = urlToOptions(input);
          } else {
            callback = options;
            options = input;
            input = { protocol };
          }
          if (typeof options === "function") {
            callback = options;
            options = null;
          }
          options = Object.assign({
            maxRedirects: exports3.maxRedirects,
            maxBodyLength: exports3.maxBodyLength
          }, input, options);
          options.nativeProtocols = nativeProtocols;
          assert.equal(options.protocol, protocol, "protocol mismatch");
          debug("options", options);
          return new RedirectableRequest(options, callback);
        }
        function get(input, options, callback) {
          var wrappedRequest = wrappedProtocol.request(input, options, callback);
          wrappedRequest.end();
          return wrappedRequest;
        }
        Object.defineProperties(wrappedProtocol, {
          request: { value: request, configurable: true, enumerable: true, writable: true },
          get: { value: get, configurable: true, enumerable: true, writable: true }
        });
      });
      return exports3;
    }
    function noop() {
    }
    function urlToOptions(urlObject) {
      var options = {
        protocol: urlObject.protocol,
        hostname: urlObject.hostname.startsWith("[") ? urlObject.hostname.slice(1, -1) : urlObject.hostname,
        hash: urlObject.hash,
        search: urlObject.search,
        pathname: urlObject.pathname,
        path: urlObject.pathname + urlObject.search,
        href: urlObject.href
      };
      if (urlObject.port !== "") {
        options.port = Number(urlObject.port);
      }
      return options;
    }
    function removeMatchingHeaders(regex, headers) {
      var lastValue;
      for (var header in headers) {
        if (regex.test(header)) {
          lastValue = headers[header].toString().trim();
          delete headers[header];
        }
      }
      return lastValue;
    }
    function createErrorType(code, defaultMessage) {
      function CustomError(cause) {
        Error.captureStackTrace(this, this.constructor);
        if (!cause) {
          this.message = defaultMessage;
        } else {
          this.message = defaultMessage + ": " + cause.message;
          this.cause = cause;
        }
      }
      CustomError.prototype = new Error();
      CustomError.prototype.constructor = CustomError;
      CustomError.prototype.name = "Error [" + code + "]";
      CustomError.prototype.code = code;
      return CustomError;
    }
    function abortRequest(request) {
      for (var e = 0; e < events.length; e++) {
        request.removeListener(events[e], eventHandlers[events[e]]);
      }
      request.on("error", noop);
      request.abort();
    }
    function isSubdomainOf(subdomain, domain) {
      const dot = subdomain.length - domain.length - 1;
      return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
    }
    module2.exports = wrap({ http, https });
    module2.exports.wrap = wrap;
  }
});

// ../node_modules/axios/package.json
var require_package5 = __commonJS({
  "../node_modules/axios/package.json"(exports2, module2) {
    module2.exports = {
      name: "axios",
      version: "0.21.4",
      description: "Promise based HTTP client for the browser and node.js",
      main: "index.js",
      scripts: {
        test: "grunt test",
        start: "node ./sandbox/server.js",
        build: "NODE_ENV=production grunt build",
        preversion: "npm test",
        version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
        postversion: "git push && git push --tags",
        examples: "node ./examples/server.js",
        coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
        fix: "eslint --fix lib/**/*.js"
      },
      repository: {
        type: "git",
        url: "https://github.com/axios/axios.git"
      },
      keywords: [
        "xhr",
        "http",
        "ajax",
        "promise",
        "node"
      ],
      author: "Matt Zabriskie",
      license: "MIT",
      bugs: {
        url: "https://github.com/axios/axios/issues"
      },
      homepage: "https://axios-http.com",
      devDependencies: {
        coveralls: "^3.0.0",
        "es6-promise": "^4.2.4",
        grunt: "^1.3.0",
        "grunt-banner": "^0.6.0",
        "grunt-cli": "^1.2.0",
        "grunt-contrib-clean": "^1.1.0",
        "grunt-contrib-watch": "^1.0.0",
        "grunt-eslint": "^23.0.0",
        "grunt-karma": "^4.0.0",
        "grunt-mocha-test": "^0.13.3",
        "grunt-ts": "^6.0.0-beta.19",
        "grunt-webpack": "^4.0.2",
        "istanbul-instrumenter-loader": "^1.0.0",
        "jasmine-core": "^2.4.1",
        karma: "^6.3.2",
        "karma-chrome-launcher": "^3.1.0",
        "karma-firefox-launcher": "^2.1.0",
        "karma-jasmine": "^1.1.1",
        "karma-jasmine-ajax": "^0.1.13",
        "karma-safari-launcher": "^1.0.0",
        "karma-sauce-launcher": "^4.3.6",
        "karma-sinon": "^1.0.5",
        "karma-sourcemap-loader": "^0.3.8",
        "karma-webpack": "^4.0.2",
        "load-grunt-tasks": "^3.5.2",
        minimist: "^1.2.0",
        mocha: "^8.2.1",
        sinon: "^4.5.0",
        "terser-webpack-plugin": "^4.2.3",
        typescript: "^4.0.5",
        "url-search-params": "^0.10.0",
        webpack: "^4.44.2",
        "webpack-dev-server": "^3.11.0"
      },
      browser: {
        "./lib/adapters/http.js": "./lib/adapters/xhr.js"
      },
      jsdelivr: "dist/axios.min.js",
      unpkg: "dist/axios.min.js",
      typings: "./index.d.ts",
      dependencies: {
        "follow-redirects": "^1.14.0"
      },
      bundlesize: [
        {
          path: "./dist/axios.min.js",
          threshold: "5kB"
        }
      ]
    };
  }
});

// ../node_modules/axios/lib/adapters/http.js
var require_http = __commonJS({
  "../node_modules/axios/lib/adapters/http.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var settle = require_settle();
    var buildFullPath = require_buildFullPath();
    var buildURL = require_buildURL();
    var http = require("http");
    var https = require("https");
    var httpFollow = require_follow_redirects().http;
    var httpsFollow = require_follow_redirects().https;
    var url = require("url");
    var zlib = require("zlib");
    var pkg = require_package5();
    var createError = require_createError();
    var enhanceError = require_enhanceError();
    var isHttps = /https:?/;
    function setProxy(options, proxy, location) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.port = proxy.port;
      options.path = location;
      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ":" + proxy.auth.password, "utf8").toString("base64");
        options.headers["Proxy-Authorization"] = "Basic " + base64;
      }
      options.beforeRedirect = function beforeRedirect(redirection) {
        redirection.headers.host = redirection.host;
        setProxy(redirection, proxy, redirection.href);
      };
    }
    module2.exports = function httpAdapter(config) {
      return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
        var resolve2 = function resolve3(value) {
          resolvePromise(value);
        };
        var reject2 = function reject3(value) {
          rejectPromise(value);
        };
        var data = config.data;
        var headers = config.headers;
        if ("User-Agent" in headers || "user-agent" in headers) {
          if (!headers["User-Agent"] && !headers["user-agent"]) {
            delete headers["User-Agent"];
            delete headers["user-agent"];
          }
        } else {
          headers["User-Agent"] = "axios/" + pkg.version;
        }
        if (data && !utils.isStream(data)) {
          if (Buffer.isBuffer(data)) {
          } else if (utils.isArrayBuffer(data)) {
            data = Buffer.from(new Uint8Array(data));
          } else if (utils.isString(data)) {
            data = Buffer.from(data, "utf-8");
          } else {
            return reject2(createError("Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream", config));
          }
          headers["Content-Length"] = data.length;
        }
        var auth = void 0;
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password || "";
          auth = username + ":" + password;
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        var parsed = url.parse(fullPath);
        var protocol = parsed.protocol || "http:";
        if (!auth && parsed.auth) {
          var urlAuth = parsed.auth.split(":");
          var urlUsername = urlAuth[0] || "";
          var urlPassword = urlAuth[1] || "";
          auth = urlUsername + ":" + urlPassword;
        }
        if (auth) {
          delete headers.Authorization;
        }
        var isHttpsRequest = isHttps.test(protocol);
        var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
        var options = {
          path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ""),
          method: config.method.toUpperCase(),
          headers,
          agent,
          agents: { http: config.httpAgent, https: config.httpsAgent },
          auth
        };
        if (config.socketPath) {
          options.socketPath = config.socketPath;
        } else {
          options.hostname = parsed.hostname;
          options.port = parsed.port;
        }
        var proxy = config.proxy;
        if (!proxy && proxy !== false) {
          var proxyEnv = protocol.slice(0, -1) + "_proxy";
          var proxyUrl = process.env[proxyEnv] || process.env[proxyEnv.toUpperCase()];
          if (proxyUrl) {
            var parsedProxyUrl = url.parse(proxyUrl);
            var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
            var shouldProxy = true;
            if (noProxyEnv) {
              var noProxy = noProxyEnv.split(",").map(function trim(s) {
                return s.trim();
              });
              shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
                if (!proxyElement) {
                  return false;
                }
                if (proxyElement === "*") {
                  return true;
                }
                if (proxyElement[0] === "." && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
                  return true;
                }
                return parsed.hostname === proxyElement;
              });
            }
            if (shouldProxy) {
              proxy = {
                host: parsedProxyUrl.hostname,
                port: parsedProxyUrl.port,
                protocol: parsedProxyUrl.protocol
              };
              if (parsedProxyUrl.auth) {
                var proxyUrlAuth = parsedProxyUrl.auth.split(":");
                proxy.auth = {
                  username: proxyUrlAuth[0],
                  password: proxyUrlAuth[1]
                };
              }
            }
          }
        }
        if (proxy) {
          options.headers.host = parsed.hostname + (parsed.port ? ":" + parsed.port : "");
          setProxy(options, proxy, protocol + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
        }
        var transport;
        var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);
        if (config.transport) {
          transport = config.transport;
        } else if (config.maxRedirects === 0) {
          transport = isHttpsProxy ? https : http;
        } else {
          if (config.maxRedirects) {
            options.maxRedirects = config.maxRedirects;
          }
          transport = isHttpsProxy ? httpsFollow : httpFollow;
        }
        if (config.maxBodyLength > -1) {
          options.maxBodyLength = config.maxBodyLength;
        }
        var req = transport.request(options, function handleResponse(res) {
          if (req.aborted)
            return;
          var stream2 = res;
          var lastRequest = res.req || req;
          if (res.statusCode !== 204 && lastRequest.method !== "HEAD" && config.decompress !== false) {
            switch (res.headers["content-encoding"]) {
              case "gzip":
              case "compress":
              case "deflate":
                stream2 = stream2.pipe(zlib.createUnzip());
                delete res.headers["content-encoding"];
                break;
            }
          }
          var response = {
            status: res.statusCode,
            statusText: res.statusMessage,
            headers: res.headers,
            config,
            request: lastRequest
          };
          if (config.responseType === "stream") {
            response.data = stream2;
            settle(resolve2, reject2, response);
          } else {
            var responseBuffer = [];
            var totalResponseBytes = 0;
            stream2.on("data", function handleStreamData(chunk) {
              responseBuffer.push(chunk);
              totalResponseBytes += chunk.length;
              if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
                stream2.destroy();
                reject2(createError("maxContentLength size of " + config.maxContentLength + " exceeded", config, null, lastRequest));
              }
            });
            stream2.on("error", function handleStreamError(err) {
              if (req.aborted)
                return;
              reject2(enhanceError(err, config, null, lastRequest));
            });
            stream2.on("end", function handleStreamEnd() {
              var responseData = Buffer.concat(responseBuffer);
              if (config.responseType !== "arraybuffer") {
                responseData = responseData.toString(config.responseEncoding);
                if (!config.responseEncoding || config.responseEncoding === "utf8") {
                  responseData = utils.stripBOM(responseData);
                }
              }
              response.data = responseData;
              settle(resolve2, reject2, response);
            });
          }
        });
        req.on("error", function handleRequestError(err) {
          if (req.aborted && err.code !== "ERR_FR_TOO_MANY_REDIRECTS")
            return;
          reject2(enhanceError(err, config, null, req));
        });
        if (config.timeout) {
          var timeout = parseInt(config.timeout, 10);
          if (isNaN(timeout)) {
            reject2(createError("error trying to parse `config.timeout` to int", config, "ERR_PARSE_TIMEOUT", req));
            return;
          }
          req.setTimeout(timeout, function handleRequestTimeout() {
            req.abort();
            reject2(createError("timeout of " + timeout + "ms exceeded", config, config.transitional && config.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED", req));
          });
        }
        if (config.cancelToken) {
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (req.aborted)
              return;
            req.abort();
            reject2(cancel);
          });
        }
        if (utils.isStream(data)) {
          data.on("error", function handleStreamError(err) {
            reject2(enhanceError(err, config, null, req));
          }).pipe(req);
        } else {
          req.end(data);
        }
      });
    };
  }
});

// ../node_modules/axios/lib/defaults.js
var require_defaults2 = __commonJS({
  "../node_modules/axios/lib/defaults.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var normalizeHeaderName = require_normalizeHeaderName();
    var enhanceError = require_enhanceError();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_http();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: {
        silentJSONParsing: true,
        forcedJSONParsing: true,
        clarifyTimeoutError: false
      },
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        if (utils.isObject(data) || headers && headers["Content-Type"] === "application/json") {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional;
        var silentJSONParsing = transitional && transitional.silentJSONParsing;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
        if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw enhanceError(e, this, "E_JSON_PARSE");
              }
              throw e;
            }
          }
        }
        return data;
      }],
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    };
    utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    module2.exports = defaults;
  }
});

// ../node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "../node_modules/axios/lib/core/transformData.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var defaults = require_defaults2();
    module2.exports = function transformData(data, headers, fns) {
      var context = this || defaults;
      utils.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers);
      });
      return data;
    };
  }
});

// ../node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "../node_modules/axios/lib/cancel/isCancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// ../node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "../node_modules/axios/lib/core/dispatchRequest.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults2();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    module2.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(config, config.data, config.headers, config.transformRequest);
      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(["delete", "get", "head", "post", "put", "patch", "common"], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// ../node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "../node_modules/axios/lib/core/mergeConfig.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    module2.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ["url", "method", "data"];
      var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
      var defaultToConfig2Keys = [
        "baseURL",
        "transformRequest",
        "transformResponse",
        "paramsSerializer",
        "timeout",
        "timeoutMessage",
        "withCredentials",
        "adapter",
        "responseType",
        "xsrfCookieName",
        "xsrfHeaderName",
        "onUploadProgress",
        "onDownloadProgress",
        "decompress",
        "maxContentLength",
        "maxBodyLength",
        "maxRedirects",
        "transport",
        "httpAgent",
        "httpsAgent",
        "cancelToken",
        "socketPath",
        "responseEncoding"
      ];
      var directMergeKeys = ["validateStatus"];
      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      }
      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(void 0, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(void 0, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };
  }
});

// ../node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "../node_modules/axios/lib/helpers/validator.js"(exports2, module2) {
    "use strict";
    var pkg = require_package5();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    var currentVerArr = pkg.version.split(".");
    function isOlderVersion(version, thanVersion) {
      var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
      var destVer = version.split(".");
      for (var i = 0; i < 3; i++) {
        if (pkgVersionArr[i] > destVer[i]) {
          return true;
        } else if (pkgVersionArr[i] < destVer[i]) {
          return false;
        }
      }
      return false;
    }
    validators.transitional = function transitional(validator, version, message) {
      var isDeprecated = version && isOlderVersion(version);
      function formatMessage(opt, desc) {
        return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new Error(formatMessage(opt, " has been removed in " + version));
        }
        if (isDeprecated && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(formatMessage(opt, " has been deprecated since v" + version + " and will be removed in the near future"));
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new TypeError("options must be an object");
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new TypeError("option " + opt + " must be " + result);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw Error("Unknown option " + opt);
        }
      }
    }
    module2.exports = {
      isOlderVersion,
      assertOptions,
      validators
    };
  }
});

// ../node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "../node_modules/axios/lib/core/Axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(config) {
      if (typeof config === "string") {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
          clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
        }, false);
      }
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, "");
    };
    utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data
        }));
      };
    });
    module2.exports = Axios;
  }
});

// ../node_modules/axios/lib/cancel/Cancel.js
var require_Cancel = __commonJS({
  "../node_modules/axios/lib/cancel/Cancel.js"(exports2, module2) {
    "use strict";
    function Cancel(message) {
      this.message = message;
    }
    Cancel.prototype.toString = function toString() {
      return "Cancel" + (this.message ? ": " + this.message : "");
    };
    Cancel.prototype.__CANCEL__ = true;
    module2.exports = Cancel;
  }
});

// ../node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "../node_modules/axios/lib/cancel/CancelToken.js"(exports2, module2) {
    "use strict";
    var Cancel = require_Cancel();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve2) {
        resolvePromise = resolve2;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          return;
        }
        token.reason = new Cancel(message);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module2.exports = CancelToken;
  }
});

// ../node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "../node_modules/axios/lib/helpers/spread.js"(exports2, module2) {
    "use strict";
    module2.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// ../node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "../node_modules/axios/lib/helpers/isAxiosError.js"(exports2, module2) {
    "use strict";
    module2.exports = function isAxiosError(payload) {
      return typeof payload === "object" && payload.isAxiosError === true;
    };
  }
});

// ../node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "../node_modules/axios/lib/axios.js"(exports2, module2) {
    "use strict";
    var utils = require_utils8();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults2();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils.extend(instance, Axios.prototype, context);
      utils.extend(instance, context);
      return instance;
    }
    var axios = createInstance(defaults);
    axios.Axios = Axios;
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };
    axios.Cancel = require_Cancel();
    axios.CancelToken = require_CancelToken();
    axios.isCancel = require_isCancel();
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = require_spread();
    axios.isAxiosError = require_isAxiosError();
    module2.exports = axios;
    module2.exports.default = axios;
  }
});

// ../node_modules/axios/index.js
var require_axios2 = __commonJS({
  "../node_modules/axios/index.js"(exports2, module2) {
    module2.exports = require_axios();
  }
});

// ../node_modules/chunk/src/chunk.js
var require_chunk = __commonJS({
  "../node_modules/chunk/src/chunk.js"(exports2, module2) {
    "use strict";
    (function() {
      function chunk(collection, size) {
        var result = [];
        size = parseInt(size) || 2;
        for (var x = 0; x < Math.ceil(collection.length / size); x++) {
          var start = x * size;
          var end = start + size;
          result.push(collection.slice(start, end));
        }
        return result;
      }
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = chunk;
        }
        exports2.chunk = chunk;
      } else {
        this.chunk = chunk;
      }
    }).call(exports2);
  }
});

// ../node_modules/array-union/index.js
var require_array_union = __commonJS({
  "../node_modules/array-union/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (...arguments_) => {
      return [...new Set([].concat(...arguments_))];
    };
  }
});

// ../node_modules/path-type/index.js
var require_path_type = __commonJS({
  "../node_modules/path-type/index.js"(exports2) {
    "use strict";
    var { promisify } = require("util");
    var fs = require("fs");
    async function isType(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        const stats = await promisify(fs[fsStatType])(filePath);
        return stats[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    function isTypeSync(fsStatType, statsMethodName, filePath) {
      if (typeof filePath !== "string") {
        throw new TypeError(`Expected a string, got ${typeof filePath}`);
      }
      try {
        return fs[fsStatType](filePath)[statsMethodName]();
      } catch (error) {
        if (error.code === "ENOENT") {
          return false;
        }
        throw error;
      }
    }
    exports2.isFile = isType.bind(null, "stat", "isFile");
    exports2.isDirectory = isType.bind(null, "stat", "isDirectory");
    exports2.isSymlink = isType.bind(null, "lstat", "isSymbolicLink");
    exports2.isFileSync = isTypeSync.bind(null, "statSync", "isFile");
    exports2.isDirectorySync = isTypeSync.bind(null, "statSync", "isDirectory");
    exports2.isSymlinkSync = isTypeSync.bind(null, "lstatSync", "isSymbolicLink");
  }
});

// ../node_modules/dir-glob/index.js
var require_dir_glob = __commonJS({
  "../node_modules/dir-glob/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var pathType = require_path_type();
    var getExtensions = (extensions) => extensions.length > 1 ? `{${extensions.join(",")}}` : extensions[0];
    var getPath = (filepath, cwd) => {
      const pth = filepath[0] === "!" ? filepath.slice(1) : filepath;
      return path.isAbsolute(pth) ? pth : path.join(cwd, pth);
    };
    var addExtensions = (file, extensions) => {
      if (path.extname(file)) {
        return `**/${file}`;
      }
      return `**/${file}.${getExtensions(extensions)}`;
    };
    var getGlob = (directory, options) => {
      if (options.files && !Array.isArray(options.files)) {
        throw new TypeError(`Expected \`files\` to be of type \`Array\` but received type \`${typeof options.files}\``);
      }
      if (options.extensions && !Array.isArray(options.extensions)) {
        throw new TypeError(`Expected \`extensions\` to be of type \`Array\` but received type \`${typeof options.extensions}\``);
      }
      if (options.files && options.extensions) {
        return options.files.map((x) => path.posix.join(directory, addExtensions(x, options.extensions)));
      }
      if (options.files) {
        return options.files.map((x) => path.posix.join(directory, `**/${x}`));
      }
      if (options.extensions) {
        return [path.posix.join(directory, `**/*.${getExtensions(options.extensions)}`)];
      }
      return [path.posix.join(directory, "**")];
    };
    module2.exports = async (input, options) => {
      options = __spreadValues({
        cwd: process.cwd()
      }, options);
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = await Promise.all([].concat(input).map(async (x) => {
        const isDirectory = await pathType.isDirectory(getPath(x, options.cwd));
        return isDirectory ? getGlob(x, options) : x;
      }));
      return [].concat.apply([], globs);
    };
    module2.exports.sync = (input, options) => {
      options = __spreadValues({
        cwd: process.cwd()
      }, options);
      if (typeof options.cwd !== "string") {
        throw new TypeError(`Expected \`cwd\` to be of type \`string\` but received type \`${typeof options.cwd}\``);
      }
      const globs = [].concat(input).map((x) => pathType.isDirectorySync(getPath(x, options.cwd)) ? getGlob(x, options) : x);
      return [].concat.apply([], globs);
    };
  }
});

// ../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.*\/|^\.+$/;
    var SLASH = "/";
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
    var define2 = (object, key, value) => Object.defineProperty(object, key, { value });
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY);
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        /\\?\s+$/,
        (match) => match.indexOf("\\") === 0 ? SPACE : EMPTY
      ],
      [
        /\\\s/g,
        () => SPACE
      ],
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      [
        /^\//,
        () => "^"
      ],
      [
        /\//g,
        () => "\\/"
      ],
      [
        /^\^*\\\*\\\*\\\//,
        () => "^(?:.*\\/)?"
      ],
      [
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      [
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        (_2, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      [
        /(^|[^\\]+)\\\*(?=.+)/g,
        (_2, p1) => `${p1}[^\\/]*`
      ],
      [
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        /\\\\/g,
        () => ESCAPE
      ],
      [
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      [
        /(?:[^*])$/,
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ],
      [
        /(\^|\\\/)?\\\*$/,
        (_2, p1) => {
          const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
          return `${prefix}(?=$|\\/$)`;
        }
      ]
    ];
    var regexCache = Object.create(null);
    var makeRegex = (pattern, ignorecase) => {
      let source = regexCache[pattern];
      if (!source) {
        source = REPLACERS.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
        regexCache[pattern] = source;
      }
      return ignorecase ? new RegExp(source, "i") : new RegExp(source);
    };
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF);
    var IgnoreRule = class {
      constructor(origin, pattern, negative, regex) {
        this.origin = origin;
        this.pattern = pattern;
        this.negative = negative;
        this.regex = regex;
      }
    };
    var createRule = (pattern, ignorecase) => {
      const origin = pattern;
      let negative = false;
      if (pattern.indexOf("!") === 0) {
        negative = true;
        pattern = pattern.substr(1);
      }
      pattern = pattern.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regex = makeRegex(pattern, ignorecase);
      return new IgnoreRule(origin, pattern, negative, regex);
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(`path must be a string, but got \`${originalPath}\``, TypeError);
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(`path should be a ${r} string, but got "${originalPath}"`, RangeError);
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = [];
        this._ignorecase = ignorecase;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = Object.create(null);
        this._testCache = Object.create(null);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (checkPattern(pattern)) {
          const rule = createRule(pattern, this._ignorecase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      add(pattern) {
        this._added = false;
        makeArray(isString(pattern) ? splitPattern(pattern) : pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _testOne(path, checkUnignored) {
        let ignored = false;
        let unignored = false;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule.regex.test(path);
          if (matched) {
            ignored = !negative;
            unignored = negative;
          }
        });
        return {
          ignored,
          unignored
        };
      }
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(path, originalPath, throwError);
        return this._t(path, cache, checkUnignored, slices);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._testOne(path, checkUnignored);
        }
        const parent = this._t(slices.join(SLASH) + SLASH, cache, checkUnignored, slices);
        return cache[path] = parent.ignored ? parent : this._testOne(path, checkUnignored);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var returnFalse = () => false;
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, returnFalse);
    factory.isPathValid = isPathValid;
    factory.default = factory;
    module2.exports = factory;
    if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGIX_IS_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGIX_IS_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    }
  }
});

// ../node_modules/slash/index.js
var require_slash = __commonJS({
  "../node_modules/slash/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (path) => {
      const isExtendedLengthPath = /^\\\\\?\\/.test(path);
      const hasNonAscii = /[^\u0000-\u0080]+/.test(path);
      if (isExtendedLengthPath || hasNonAscii) {
        return path;
      }
      return path.replace(/\\/g, "/");
    };
  }
});

// ../node_modules/globby/gitignore.js
var require_gitignore = __commonJS({
  "../node_modules/globby/gitignore.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var fs = require("fs");
    var path = require("path");
    var fastGlob = require_out4();
    var gitIgnore = require_ignore();
    var slash = require_slash();
    var DEFAULT_IGNORE = [
      "**/node_modules/**",
      "**/flow-typed/**",
      "**/coverage/**",
      "**/.git"
    ];
    var readFileP = promisify(fs.readFile);
    var mapGitIgnorePatternTo = (base) => (ignore) => {
      if (ignore.startsWith("!")) {
        return "!" + path.posix.join(base, ignore.slice(1));
      }
      return path.posix.join(base, ignore);
    };
    var parseGitIgnore = (content, options) => {
      const base = slash(path.relative(options.cwd, path.dirname(options.fileName)));
      return content.split(/\r?\n/).filter(Boolean).filter((line) => !line.startsWith("#")).map(mapGitIgnorePatternTo(base));
    };
    var reduceIgnore = (files) => {
      const ignores = gitIgnore();
      for (const file of files) {
        ignores.add(parseGitIgnore(file.content, {
          cwd: file.cwd,
          fileName: file.filePath
        }));
      }
      return ignores;
    };
    var ensureAbsolutePathForCwd = (cwd, p) => {
      cwd = slash(cwd);
      if (path.isAbsolute(p)) {
        if (slash(p).startsWith(cwd)) {
          return p;
        }
        throw new Error(`Path ${p} is not in cwd ${cwd}`);
      }
      return path.join(cwd, p);
    };
    var getIsIgnoredPredecate = (ignores, cwd) => {
      return (p) => ignores.ignores(slash(path.relative(cwd, ensureAbsolutePathForCwd(cwd, p.path || p))));
    };
    var getFile = async (file, cwd) => {
      const filePath = path.join(cwd, file);
      const content = await readFileP(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var getFileSync = (file, cwd) => {
      const filePath = path.join(cwd, file);
      const content = fs.readFileSync(filePath, "utf8");
      return {
        cwd,
        filePath,
        content
      };
    };
    var normalizeOptions = ({
      ignore = [],
      cwd = slash(process.cwd())
    } = {}) => {
      return { ignore, cwd };
    };
    module2.exports = async (options) => {
      options = normalizeOptions(options);
      const paths = await fastGlob("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = await Promise.all(paths.map((file) => getFile(file, options.cwd)));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
    module2.exports.sync = (options) => {
      options = normalizeOptions(options);
      const paths = fastGlob.sync("**/.gitignore", {
        ignore: DEFAULT_IGNORE.concat(options.ignore),
        cwd: options.cwd
      });
      const files = paths.map((file) => getFileSync(file, options.cwd));
      const ignores = reduceIgnore(files);
      return getIsIgnoredPredecate(ignores, options.cwd);
    };
  }
});

// ../node_modules/globby/stream-utils.js
var require_stream_utils = __commonJS({
  "../node_modules/globby/stream-utils.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2 } = require("stream");
    var ObjectTransform = class extends Transform2 {
      constructor() {
        super({
          objectMode: true
        });
      }
    };
    var FilterStream = class extends ObjectTransform {
      constructor(filter) {
        super();
        this._filter = filter;
      }
      _transform(data, encoding, callback) {
        if (this._filter(data)) {
          this.push(data);
        }
        callback();
      }
    };
    var UniqueStream = class extends ObjectTransform {
      constructor() {
        super();
        this._pushed = new Set();
      }
      _transform(data, encoding, callback) {
        if (!this._pushed.has(data)) {
          this.push(data);
          this._pushed.add(data);
        }
        callback();
      }
    };
    module2.exports = {
      FilterStream,
      UniqueStream
    };
  }
});

// ../node_modules/globby/index.js
var require_globby = __commonJS({
  "../node_modules/globby/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var arrayUnion = require_array_union();
    var merge2 = require_merge2();
    var fastGlob = require_out4();
    var dirGlob = require_dir_glob();
    var gitignore = require_gitignore();
    var { FilterStream, UniqueStream } = require_stream_utils();
    var DEFAULT_FILTER = () => false;
    var isNegative = (pattern) => pattern[0] === "!";
    var assertPatternsInput = (patterns) => {
      if (!patterns.every((pattern) => typeof pattern === "string")) {
        throw new TypeError("Patterns must be a string or an array of strings");
      }
    };
    var checkCwdOption = (options = {}) => {
      if (!options.cwd) {
        return;
      }
      let stat;
      try {
        stat = fs.statSync(options.cwd);
      } catch {
        return;
      }
      if (!stat.isDirectory()) {
        throw new Error("The `cwd` option must be a path to a directory");
      }
    };
    var getPathString = (p) => p.stats instanceof fs.Stats ? p.path : p;
    var generateGlobTasks = (patterns, taskOptions) => {
      patterns = arrayUnion([].concat(patterns));
      assertPatternsInput(patterns);
      checkCwdOption(taskOptions);
      const globTasks = [];
      taskOptions = __spreadValues({
        ignore: [],
        expandDirectories: true
      }, taskOptions);
      for (const [index, pattern] of patterns.entries()) {
        if (isNegative(pattern)) {
          continue;
        }
        const ignore = patterns.slice(index).filter((pattern2) => isNegative(pattern2)).map((pattern2) => pattern2.slice(1));
        const options = __spreadProps(__spreadValues({}, taskOptions), {
          ignore: taskOptions.ignore.concat(ignore)
        });
        globTasks.push({ pattern, options });
      }
      return globTasks;
    };
    var globDirs = (task, fn) => {
      let options = {};
      if (task.options.cwd) {
        options.cwd = task.options.cwd;
      }
      if (Array.isArray(task.options.expandDirectories)) {
        options = __spreadProps(__spreadValues({}, options), {
          files: task.options.expandDirectories
        });
      } else if (typeof task.options.expandDirectories === "object") {
        options = __spreadValues(__spreadValues({}, options), task.options.expandDirectories);
      }
      return fn(task.pattern, options);
    };
    var getPattern = (task, fn) => task.options.expandDirectories ? globDirs(task, fn) : [task.pattern];
    var getFilterSync = (options) => {
      return options && options.gitignore ? gitignore.sync({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
    };
    var globToTask = (task) => (glob) => {
      const { options } = task;
      if (options.ignore && Array.isArray(options.ignore) && options.expandDirectories) {
        options.ignore = dirGlob.sync(options.ignore);
      }
      return {
        pattern: glob,
        options
      };
    };
    module2.exports = async (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const getFilter = async () => {
        return options && options.gitignore ? gitignore({ cwd: options.cwd, ignore: options.ignore }) : DEFAULT_FILTER;
      };
      const getTasks = async () => {
        const tasks2 = await Promise.all(globTasks.map(async (task) => {
          const globs = await getPattern(task, dirGlob);
          return Promise.all(globs.map(globToTask(task)));
        }));
        return arrayUnion(...tasks2);
      };
      const [filter, tasks] = await Promise.all([getFilter(), getTasks()]);
      const paths = await Promise.all(tasks.map((task) => fastGlob(task.pattern, task.options)));
      return arrayUnion(...paths).filter((path_) => !filter(getPathString(path_)));
    };
    module2.exports.sync = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      let matches = [];
      for (const task of tasks) {
        matches = arrayUnion(matches, fastGlob.sync(task.pattern, task.options));
      }
      return matches.filter((path_) => !filter(path_));
    };
    module2.exports.stream = (patterns, options) => {
      const globTasks = generateGlobTasks(patterns, options);
      const tasks = [];
      for (const task of globTasks) {
        const newTask = getPattern(task, dirGlob.sync).map(globToTask(task));
        tasks.push(...newTask);
      }
      const filter = getFilterSync(options);
      const filterStream = new FilterStream((p) => !filter(p));
      const uniqueStream = new UniqueStream();
      return merge2(tasks.map((task) => fastGlob.stream(task.pattern, task.options))).pipe(filterStream).pipe(uniqueStream);
    };
    module2.exports.generateGlobTasks = generateGlobTasks;
    module2.exports.hasMagic = (patterns, options) => [].concat(patterns).some((pattern) => fastGlob.isDynamicPattern(pattern, options));
    module2.exports.gitignore = gitignore;
  }
});

// ../node_modules/is-path-cwd/index.js
var require_is_path_cwd = __commonJS({
  "../node_modules/is-path-cwd/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    module2.exports = (path_) => {
      let cwd = process.cwd();
      path_ = path.resolve(path_);
      if (process.platform === "win32") {
        cwd = cwd.toLowerCase();
        path_ = path_.toLowerCase();
      }
      return path_ === cwd;
    };
  }
});

// ../node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "../node_modules/indent-string/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (string, count = 1, options) => {
      options = __spreadValues({
        indent: " ",
        includeEmptyLines: false
      }, options);
      if (typeof string !== "string") {
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
      }
      if (typeof count !== "number") {
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
      }
      if (count === 0) {
        return string;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string.replace(regex, options.indent.repeat(count));
    };
  }
});

// ../node_modules/clean-stack/index.js
var require_clean_stack = __commonJS({
  "../node_modules/clean-stack/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});

// ../node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS({
  "../node_modules/aggregate-error/index.js"(exports2, module2) {
    "use strict";
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError = class extends Error {
      constructor(errors) {
        if (!Array.isArray(errors)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
        }
        errors = [...errors].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError;
  }
});

// ../node_modules/p-map/index.js
var require_p_map = __commonJS({
  "../node_modules/p-map/index.js"(exports2, module2) {
    "use strict";
    var AggregateError = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve2, reject2) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors.length !== 0) {
                reject2(new AggregateError(errors));
              } else {
                resolve2(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject2(error);
              } else {
                errors.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  }
});

// ../node_modules/del/index.js
var require_del = __commonJS({
  "../node_modules/del/index.js"(exports2, module2) {
    "use strict";
    var { promisify } = require("util");
    var path = require("path");
    var globby = require_globby();
    var isGlob = require_is_glob();
    var slash = require_slash();
    var gracefulFs = require_graceful_fs();
    var isPathCwd = require_is_path_cwd();
    var isPathInside = require_is_path_inside();
    var rimraf = require_rimraf2();
    var pMap = require_p_map();
    var rimrafP = promisify(rimraf);
    var rimrafOptions = {
      glob: false,
      unlink: gracefulFs.unlink,
      unlinkSync: gracefulFs.unlinkSync,
      chmod: gracefulFs.chmod,
      chmodSync: gracefulFs.chmodSync,
      stat: gracefulFs.stat,
      statSync: gracefulFs.statSync,
      lstat: gracefulFs.lstat,
      lstatSync: gracefulFs.lstatSync,
      rmdir: gracefulFs.rmdir,
      rmdirSync: gracefulFs.rmdirSync,
      readdir: gracefulFs.readdir,
      readdirSync: gracefulFs.readdirSync
    };
    function safeCheck(file, cwd) {
      if (isPathCwd(file)) {
        throw new Error("Cannot delete the current working directory. Can be overridden with the `force` option.");
      }
      if (!isPathInside(file, cwd)) {
        throw new Error("Cannot delete files/directories outside the current working directory. Can be overridden with the `force` option.");
      }
    }
    function normalizePatterns(patterns) {
      patterns = Array.isArray(patterns) ? patterns : [patterns];
      patterns = patterns.map((pattern) => {
        if (process.platform === "win32" && isGlob(pattern) === false) {
          return slash(pattern);
        }
        return pattern;
      });
      return patterns;
    }
    module2.exports = async (patterns, _a = {}) => {
      var _b = _a, { force, dryRun, cwd = process.cwd() } = _b, options = __objRest(_b, ["force", "dryRun", "cwd"]);
      options = __spreadValues({
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd
      }, options);
      patterns = normalizePatterns(patterns);
      const files = (await globby(patterns, options)).sort((a, b) => b.localeCompare(a));
      const mapper = async (file) => {
        file = path.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          await rimrafP(file, rimrafOptions);
        }
        return file;
      };
      const removedFiles = await pMap(files, mapper, options);
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
    module2.exports.sync = (patterns, _a = {}) => {
      var _b = _a, { force, dryRun, cwd = process.cwd() } = _b, options = __objRest(_b, ["force", "dryRun", "cwd"]);
      options = __spreadValues({
        expandDirectories: false,
        onlyFiles: false,
        followSymbolicLinks: false,
        cwd
      }, options);
      patterns = normalizePatterns(patterns);
      const files = globby.sync(patterns, options).sort((a, b) => b.localeCompare(a));
      const removedFiles = files.map((file) => {
        file = path.resolve(cwd, file);
        if (!force) {
          safeCheck(file, cwd);
        }
        if (!dryRun) {
          rimraf.sync(file, rimrafOptions);
        }
        return file;
      });
      removedFiles.sort((a, b) => a.localeCompare(b));
      return removedFiles;
    };
  }
});

// ../node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "../node_modules/p-defer/index.js"(exports2, module2) {
    "use strict";
    var pDefer = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve2, reject2) => {
        deferred.resolve = resolve2;
        deferred.reject = reject2;
      });
      return deferred;
    };
    module2.exports = pDefer;
  }
});

// ../node_modules/it-parallel/index.js
var require_it_parallel = __commonJS({
  "../node_modules/it-parallel/index.js"(exports2, module2) {
    "use strict";
    var defer = require_p_defer();
    var EventEmitter = require("events").EventEmitter;
    async function* parallel(source, options = {}) {
      let concurrency = options.concurrency || Infinity;
      if (concurrency < 1) {
        concurrency = Infinity;
      }
      const ordered = options.ordered == null ? false : options.ordered;
      const emitter = new EventEmitter();
      const ops = [];
      let slotAvailable = defer();
      let resultAvailable = defer();
      let sourceFinished = false;
      let sourceErr;
      let opErred = false;
      emitter.on("task-complete", () => {
        resultAvailable.resolve();
      });
      Promise.resolve().then(async () => {
        try {
          for await (const task of source) {
            if (ops.length === concurrency) {
              slotAvailable = defer();
              await slotAvailable.promise;
            }
            if (opErred) {
              break;
            }
            const op = {
              done: false
            };
            ops.push(op);
            task().then((result) => {
              op.done = true;
              op.ok = true;
              op.value = result;
              emitter.emit("task-complete");
            }, (err) => {
              op.done = true;
              op.err = err;
              emitter.emit("task-complete");
            });
          }
          sourceFinished = true;
          emitter.emit("task-complete");
        } catch (err) {
          sourceErr = err;
          emitter.emit("task-complete");
        }
      });
      function valuesAvailable() {
        if (ordered) {
          return Boolean(ops[0] && ops[0].done);
        }
        return Boolean(ops.find((op) => op.done));
      }
      function* yieldOrderedValues() {
        while (ops.length && ops[0].done) {
          const op = ops[0];
          ops.shift();
          if (op.ok) {
            yield op.value;
          } else {
            opErred = true;
            slotAvailable.resolve();
            throw op.err;
          }
          slotAvailable.resolve();
        }
      }
      function* yieldUnOrderedValues() {
        while (valuesAvailable()) {
          for (let i = 0; i < ops.length; i++) {
            if (ops[i].done) {
              const op = ops[i];
              ops.splice(i, 1);
              i--;
              if (op.ok) {
                yield op.value;
              } else {
                opErred = true;
                slotAvailable.resolve();
                throw op.err;
              }
              slotAvailable.resolve();
            }
          }
        }
      }
      while (true) {
        if (!valuesAvailable()) {
          resultAvailable = defer();
          await resultAvailable.promise;
        }
        if (sourceErr) {
          throw sourceErr;
        }
        if (ordered) {
          yield* yieldOrderedValues();
        } else {
          yield* yieldUnOrderedValues();
        }
        if (sourceFinished && ops.length === 0) {
          break;
        }
      }
    }
    module2.exports = parallel;
  }
});

// src/models/FS.js
var require_FS = __commonJS({
  "src/models/FS.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fse = require_lib();
    var AdmZip = require_adm_zip();
    var download = require_download();
    var chokidar = require("chokidar");
    var parsePackageJsonName = require_parse_packagejson_name();
    var fs = require("fs");
    var fg = require_out4();
    var debounce = require_debounce();
    var spawn = require_spawn();
    var isGitUrl = require_is_git_url();
    var downloadRepo = require_download_git_repo();
    var axios = require_axios2();
    var chunk = require_chunk();
    var os = require("os");
    var del = require_del();
    var { Worker } = require("worker_threads");
    var parallel = require_it_parallel();
    var cpus = os.cpus();
    var defaultIgnored = [".git/**", ".gitignore", ".serverlessignore", "node_modules/**"];
    var defaultExcludes = [
      ".git",
      ".gitignore",
      ".serverlessignore",
      "package-lock.json",
      "node_modules/serverless",
      "node_modules/@serverless/cloud",
      "node_modules/aws-sdk/**/*.d.ts",
      "node_modules/aws-sdk/**/*.examples.json",
      "node_modules/aws-sdk/**/*.md",
      "node_modules/aws-sdk/dist",
      "node_modules/aws-sdk/dist-tools",
      "node_modules/aws-sdk/scripts"
    ];
    var pool = [];
    var HashWorker = class {
      constructor() {
        this.pending = false;
        const workerPath = __dirname.indexOf("/src/models") === -1 ? path.resolve(__dirname, "workers", "hash.js") : path.resolve(__dirname, "..", "workers", "hash.js");
        this.worker = new Worker(workerPath, {
          execArgv: []
        });
        this.worker.on("message", ({ err, res }) => {
          if (err) {
            this.onError && this.onError(err);
          } else {
            this.onResult && this.onResult(res);
          }
        });
        this.worker.on("error", (err) => {
          this.onError && this.onError(err);
        });
        this.worker.on("exit", (code) => {
          const error = new Error(`Cloud hash worker exited with code ${code}`);
          this.onError && this.onError(error);
        });
      }
      async run(base, task, useArchive) {
        if (!this.worker) {
          throw new Error("Hash worker crashed");
        }
        try {
          return await new Promise((resolve2, reject2) => {
            this.onError = reject2;
            this.onResult = resolve2;
            this.worker.postMessage({ base, task, useArchive });
          });
        } finally {
          delete this.onError;
          delete this.onResult;
        }
      }
    };
    var FS = class {
      constructor(data = {}) {
        this.update(data);
      }
      update(data = {}) {
        this.serviceRoot = data.serviceRoot || this.serviceRoot || process.cwd();
        this.serviceFileName = data.serviceFileName || this.serviceFileName || "package.json";
        this.serviceFilePath = path.join(this.serviceRoot, this.serviceFileName);
        this.serviceFile = data.serviceFile || this.serviceFile;
        this.dataFileName = data.dataFileName || this.dataFileName || "data.json";
        this.dataFilePath = path.join(this.serviceRoot, this.dataFileName);
        this.dataFile = data.dataFile || this.dataFile;
        this.exclude = defaultExcludes.concat(data.exclude || this.exclude || []);
        this.ignored = defaultIgnored;
        this.setIgnoredFiles();
      }
      setIgnoredFiles() {
        if (fs.existsSync(".serverlessignore")) {
          const contents = fs.readFileSync(".serverlessignore");
          contents.toString("utf8").split(/\r?\n/).forEach((ignore) => {
            if (ignore) {
              this.ignored.push(ignore);
              this.exclude.push(ignore);
            }
          });
        }
      }
      createServiceDir(serviceName) {
        const serviceRoot = path.resolve(process.cwd(), serviceName);
        if (fs.existsSync(serviceRoot)) {
          throw new Error(`Directory named ${serviceName} already exists.`);
        }
        fs.mkdirSync(serviceRoot);
        this.update({ serviceRoot });
      }
      async read() {
        await Promise.all([this.readServiceFileIfExists(), this.readDataFileIfExists()]);
      }
      async emptyDir() {
        del.sync([
          `${this.serviceRoot}/**`,
          `!${this.serviceRoot}`,
          `!${this.serviceRoot}/.git/**`,
          `!${this.serviceRoot}/.gitignore`,
          `!${this.serviceRoot}/.serverlessignore`
        ]);
      }
      async isCwdEmpty() {
        const fileNames = fg.sync("**/*", {
          cwd: this.serviceRoot,
          dot: true,
          unique: true,
          ignore: [".git", ".gitignore", ".serverlessignore"]
        });
        if (fileNames.length === 0) {
          return true;
        }
        return false;
      }
      async readJsonFileIfExists(jsonPath) {
        try {
          return await fse.readJson(jsonPath, { throws: false });
        } catch (e) {
          return null;
        }
      }
      async readServiceFileIfExists() {
        const serviceFile = await this.readJsonFileIfExists(this.serviceFilePath);
        if (serviceFile && await this._isValidServiceFile(serviceFile)) {
          this.serviceFile = serviceFile;
          this.defaults = this._parseNameProperty(this.serviceFile.name);
          this.serviceFile.serverless = this.serviceFile.serverless || {};
          this.serviceFile.serverless.app = this.serviceFile.serverless.app || this.serviceFile.serverless.service;
          if (!this.serviceFile.serverless.app && this.serviceFile.serverless.service) {
            this.serviceFile.serverless.app = this.serviceFile.serverless.service;
            await this.writeServiceFile();
          }
          return this.serviceFile;
        }
      }
      async readDataFileIfExists() {
        this.dataFile = await this.readJsonFileIfExists(this.dataFilePath);
        return this.dataFile;
      }
      async readDataFile() {
        this.dataFile = await this.readDataFileIfExists();
        if (!this.dataFile) {
          throw new Error(`Data file "${this.dataFileName}" does not exist in the cwd`);
        }
        return this.dataFile;
      }
      async writeServiceFile({ serviceName, orgName } = {}) {
        if (serviceName) {
          this.serviceFile.serverless.app = serviceName;
        }
        if (orgName) {
          this.serviceFile.serverless.org = orgName;
        }
        if (this.serviceFile.serverless.service) {
          delete this.serviceFile.serverless.service;
        }
        await fse.writeJson(this.serviceFilePath, this.serviceFile, { spaces: 2 });
        return this.serviceFile;
      }
      async writeDataFile(data) {
        this.dataFile = data || this.dataFile;
        await fse.writeJson(this.dataFilePath, this.dataFile, { spaces: 2 });
      }
      _normalizePotentialGitUrl(potentialGitUrl) {
        return potentialGitUrl.endsWith(".git") ? potentialGitUrl : `${potentialGitUrl}.git`;
      }
      async initService({ orgName, serviceName, templateName }) {
        await this.emptyDir();
        if (templateName && isGitUrl(this._normalizePotentialGitUrl(templateName))) {
          await this.downloadUserTemplate(this._normalizePotentialGitUrl(templateName));
        } else {
          await this.downloadCoreTemplate(templateName);
        }
        await this.readServiceFileIfExists();
        await this.writeServiceFile({ orgName, serviceName });
      }
      async listCoreTemplates() {
        const templatesJsonPath = `https://raw.githubusercontent.com/serverless/cloud/main/templates.json`;
        return (await axios.get(templatesJsonPath)).data;
      }
      async downloadUserTemplate(template) {
        return new Promise((resolve2, reject2) => {
          downloadRepo(`direct:${template}`, this.serviceRoot, { clone: true }, (error) => error ? reject2(error) : resolve2());
        });
      }
      async downloadCoreTemplate(templateName = "default") {
        const githubOrgName = "serverless";
        const githubRepoName = "cloud";
        const githubBranchName = "main";
        const githubDirectoryName = "templates";
        const githubRepoUrl = `https://github.com/${githubOrgName}/${githubRepoName}/archive/refs/heads/${githubBranchName}.zip`;
        const githubExampleFilePrefix = `${githubRepoName}-${githubBranchName}/${githubDirectoryName}/${templateName}/`;
        const githubRepoBuffer = await download(githubRepoUrl);
        const githubRepoZip = new AdmZip(githubRepoBuffer);
        const githubRepoZipEntries = githubRepoZip.getEntries();
        const exampleEntries = githubRepoZipEntries.filter((e) => {
          return e.entryName.startsWith(githubExampleFilePrefix) && e.entryName !== githubExampleFilePrefix && !e.entryName.endsWith("/");
        });
        if (exampleEntries.length === 0) {
          throw new Error(`Template "${templateName}" does not exist`);
        }
        const promises = [];
        for (const exampleEntry of exampleEntries) {
          const exampleFileRelativePath = exampleEntry.entryName.replace(githubExampleFilePrefix, "");
          const exampleFileAbsolutePath = path.join(this.serviceRoot, exampleFileRelativePath);
          const exampleFileContent = exampleEntry.getData();
          promises.push(fse.outputFile(exampleFileAbsolutePath, exampleFileContent));
        }
        await Promise.all(promises);
      }
      async installDependenciesIfExists() {
        const dependenciesPropExists = this.serviceFile.dependencies && Object.keys(this.serviceFile.dependencies).length !== 0;
        const devDependenciesPropExists = this.serviceFile.devDependencies && Object.keys(this.serviceFile.devDependencies).length !== 0;
        if (dependenciesPropExists || devDependenciesPropExists) {
          try {
            await spawn("npm", ["install"], { cwd: this.serviceRoot });
          } catch (e) {
            const outputString = e.stdBuffer.toString();
            throw new Error(`Failed to install app dependencies due to the following error:
${outputString}`);
          }
        }
      }
      _parseNameProperty(name) {
        const { scope: org, fullName: app } = parsePackageJsonName(name);
        return { org, app };
      }
      async _isValidServiceFile(serviceFile) {
        const mainFilePath = path.join(this.serviceRoot, serviceFile.main || "index.js");
        const defaultMainJsFilePath = path.join(this.serviceRoot, "index.js");
        const defaultMainTsFilePath = path.join(this.serviceRoot, "index.ts");
        const namePropertyExists = serviceFile.name;
        const mainFileExists = await fse.pathExists(mainFilePath) || await fse.pathExists(defaultMainJsFilePath) || await fse.pathExists(defaultMainTsFilePath);
        if (namePropertyExists && mainFileExists) {
          return true;
        }
        return false;
      }
      async watch(callback) {
        this.setIgnoredFiles();
        const watcher = chokidar.watch(this.serviceRoot, {
          cwd: this.serviceRoot,
          ignored: this.ignored
        });
        const filePaths = new Set();
        const sync = debounce(() => {
          const cloned = new Set(filePaths);
          callback(cloned);
          filePaths.clear();
        }, 50, false);
        const emit = (filePath) => {
          filePaths.add(filePath);
          sync();
        };
        watcher.on("ready", () => {
          watcher.on("add", emit);
          watcher.on("change", emit);
          watcher.on("unlink", emit);
        });
      }
      glob(src) {
        const fileNames = fg.sync("**/*", {
          cwd: src,
          dot: true,
          unique: true,
          ignore: this.exclude
        });
        return fileNames.map((fileName) => path.resolve(src, fileName));
      }
      hash(base, filePaths, useArchive) {
        const taskSize = Math.ceil((filePaths.length + 1) / cpus.length) * 2;
        const tasks = chunk(filePaths, taskSize);
        return parallel(tasks.map((task) => async () => {
          if (task.length === 0) {
            return [];
          }
          let worker;
          try {
            worker = pool.pop() || new HashWorker();
            return await worker.run(base, task, useArchive);
          } finally {
            if (worker) {
              pool.push(worker);
            }
          }
        }, { concurrency: taskSize }));
      }
    };
    module2.exports = FS;
  }
});

// ../node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "../node_modules/lodash/lodash.js"(exports2, module2) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        "\xC0": "A",
        "\xC1": "A",
        "\xC2": "A",
        "\xC3": "A",
        "\xC4": "A",
        "\xC5": "A",
        "\xE0": "a",
        "\xE1": "a",
        "\xE2": "a",
        "\xE3": "a",
        "\xE4": "a",
        "\xE5": "a",
        "\xC7": "C",
        "\xE7": "c",
        "\xD0": "D",
        "\xF0": "d",
        "\xC8": "E",
        "\xC9": "E",
        "\xCA": "E",
        "\xCB": "E",
        "\xE8": "e",
        "\xE9": "e",
        "\xEA": "e",
        "\xEB": "e",
        "\xCC": "I",
        "\xCD": "I",
        "\xCE": "I",
        "\xCF": "I",
        "\xEC": "i",
        "\xED": "i",
        "\xEE": "i",
        "\xEF": "i",
        "\xD1": "N",
        "\xF1": "n",
        "\xD2": "O",
        "\xD3": "O",
        "\xD4": "O",
        "\xD5": "O",
        "\xD6": "O",
        "\xD8": "O",
        "\xF2": "o",
        "\xF3": "o",
        "\xF4": "o",
        "\xF5": "o",
        "\xF6": "o",
        "\xF8": "o",
        "\xD9": "U",
        "\xDA": "U",
        "\xDB": "U",
        "\xDC": "U",
        "\xF9": "u",
        "\xFA": "u",
        "\xFB": "u",
        "\xFC": "u",
        "\xDD": "Y",
        "\xFD": "y",
        "\xFF": "y",
        "\xC6": "Ae",
        "\xE6": "ae",
        "\xDE": "Th",
        "\xFE": "th",
        "\xDF": "ss",
        "\u0100": "A",
        "\u0102": "A",
        "\u0104": "A",
        "\u0101": "a",
        "\u0103": "a",
        "\u0105": "a",
        "\u0106": "C",
        "\u0108": "C",
        "\u010A": "C",
        "\u010C": "C",
        "\u0107": "c",
        "\u0109": "c",
        "\u010B": "c",
        "\u010D": "c",
        "\u010E": "D",
        "\u0110": "D",
        "\u010F": "d",
        "\u0111": "d",
        "\u0112": "E",
        "\u0114": "E",
        "\u0116": "E",
        "\u0118": "E",
        "\u011A": "E",
        "\u0113": "e",
        "\u0115": "e",
        "\u0117": "e",
        "\u0119": "e",
        "\u011B": "e",
        "\u011C": "G",
        "\u011E": "G",
        "\u0120": "G",
        "\u0122": "G",
        "\u011D": "g",
        "\u011F": "g",
        "\u0121": "g",
        "\u0123": "g",
        "\u0124": "H",
        "\u0126": "H",
        "\u0125": "h",
        "\u0127": "h",
        "\u0128": "I",
        "\u012A": "I",
        "\u012C": "I",
        "\u012E": "I",
        "\u0130": "I",
        "\u0129": "i",
        "\u012B": "i",
        "\u012D": "i",
        "\u012F": "i",
        "\u0131": "i",
        "\u0134": "J",
        "\u0135": "j",
        "\u0136": "K",
        "\u0137": "k",
        "\u0138": "k",
        "\u0139": "L",
        "\u013B": "L",
        "\u013D": "L",
        "\u013F": "L",
        "\u0141": "L",
        "\u013A": "l",
        "\u013C": "l",
        "\u013E": "l",
        "\u0140": "l",
        "\u0142": "l",
        "\u0143": "N",
        "\u0145": "N",
        "\u0147": "N",
        "\u014A": "N",
        "\u0144": "n",
        "\u0146": "n",
        "\u0148": "n",
        "\u014B": "n",
        "\u014C": "O",
        "\u014E": "O",
        "\u0150": "O",
        "\u014D": "o",
        "\u014F": "o",
        "\u0151": "o",
        "\u0154": "R",
        "\u0156": "R",
        "\u0158": "R",
        "\u0155": "r",
        "\u0157": "r",
        "\u0159": "r",
        "\u015A": "S",
        "\u015C": "S",
        "\u015E": "S",
        "\u0160": "S",
        "\u015B": "s",
        "\u015D": "s",
        "\u015F": "s",
        "\u0161": "s",
        "\u0162": "T",
        "\u0164": "T",
        "\u0166": "T",
        "\u0163": "t",
        "\u0165": "t",
        "\u0167": "t",
        "\u0168": "U",
        "\u016A": "U",
        "\u016C": "U",
        "\u016E": "U",
        "\u0170": "U",
        "\u0172": "U",
        "\u0169": "u",
        "\u016B": "u",
        "\u016D": "u",
        "\u016F": "u",
        "\u0171": "u",
        "\u0173": "u",
        "\u0174": "W",
        "\u0175": "w",
        "\u0176": "Y",
        "\u0177": "y",
        "\u0178": "Y",
        "\u0179": "Z",
        "\u017B": "Z",
        "\u017D": "Z",
        "\u017A": "z",
        "\u017C": "z",
        "\u017E": "z",
        "\u0132": "IJ",
        "\u0133": "ij",
        "\u0152": "Oe",
        "\u0153": "oe",
        "\u0149": "'n",
        "\u017F": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
      var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap && new WeakMap();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          "escape": reEscape,
          "evaluate": reEvaluate,
          "interpolate": reInterpolate,
          "variable": "",
          "imports": {
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty2.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty2.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty2.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject2(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite2(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape2(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject2;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite2;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape2;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _2 = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _2;
        define(function() {
          return _2;
        });
      } else if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(exports2);
  }
});

// ../node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "../node_modules/imurmurhash/imurmurhash.js"(exports2, module2) {
    (function() {
      var cache;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache = new MurmurHash3();
      if (typeof module2 != "undefined") {
        module2.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// ../node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "../node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// ../node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "../node_modules/signal-exit/index.js"(exports2, module2) {
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
      };
    } else {
      assert = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return;
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || 0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// ../node_modules/is-typedarray/index.js
var require_is_typedarray = __commonJS({
  "../node_modules/is-typedarray/index.js"(exports2, module2) {
    module2.exports = isTypedArray;
    isTypedArray.strict = isStrictTypedArray;
    isTypedArray.loose = isLooseTypedArray;
    var toString = Object.prototype.toString;
    var names = {
      "[object Int8Array]": true,
      "[object Int16Array]": true,
      "[object Int32Array]": true,
      "[object Uint8Array]": true,
      "[object Uint8ClampedArray]": true,
      "[object Uint16Array]": true,
      "[object Uint32Array]": true,
      "[object Float32Array]": true,
      "[object Float64Array]": true
    };
    function isTypedArray(arr) {
      return isStrictTypedArray(arr) || isLooseTypedArray(arr);
    }
    function isStrictTypedArray(arr) {
      return arr instanceof Int8Array || arr instanceof Int16Array || arr instanceof Int32Array || arr instanceof Uint8Array || arr instanceof Uint8ClampedArray || arr instanceof Uint16Array || arr instanceof Uint32Array || arr instanceof Float32Array || arr instanceof Float64Array;
    }
    function isLooseTypedArray(arr) {
      return names[toString.call(arr)];
    }
  }
});

// ../node_modules/typedarray-to-buffer/index.js
var require_typedarray_to_buffer = __commonJS({
  "../node_modules/typedarray-to-buffer/index.js"(exports2, module2) {
    var isTypedArray = require_is_typedarray().strict;
    module2.exports = function typedarrayToBuffer(arr) {
      if (isTypedArray(arr)) {
        var buf = Buffer.from(arr.buffer);
        if (arr.byteLength !== arr.buffer.byteLength) {
          buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength);
        }
        return buf;
      } else {
        return Buffer.from(arr);
      }
    };
  }
});

// ../node_modules/@serverless/utils/node_modules/write-file-atomic/index.js
var require_write_file_atomic = __commonJS({
  "../node_modules/@serverless/utils/node_modules/write-file-atomic/index.js"(exports2, module2) {
    "use strict";
    module2.exports = writeFile;
    module2.exports.sync = writeFileSync;
    module2.exports._getTmpname = getTmpname;
    module2.exports._cleanupOnExit = cleanupOnExit;
    var fs = require("fs");
    var MurmurHash3 = require_imurmurhash();
    var onExit = require_signal_exit();
    var path = require("path");
    var isTypedArray = require_is_typedarray();
    var typedArrayToBuffer = require_typedarray_to_buffer();
    var { promisify } = require("util");
    var activeFiles = {};
    var threadId = function getId() {
      try {
        const workerThreads = require("worker_threads");
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    }();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch (_2) {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve2) => {
        if (!activeFiles[absoluteName])
          activeFiles[absoluteName] = [];
        activeFiles[absoluteName].push(resolve2);
        if (activeFiles[absoluteName].length === 1)
          resolve2();
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify(fs.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify(fs.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify(fs.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (isTypedArray(data)) {
          data = typedArrayToBuffer(data);
        }
        if (Buffer.isBuffer(data)) {
          await promisify(fs.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify(fs.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify(fs.fsync)(fd);
        }
        await promisify(fs.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify(fs.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify(fs.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify(fs.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify(fs.close)(fd).catch(() => {
          });
        }
        removeOnExitHandler();
        await promisify(fs.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else
          delete activeFiles[absoluteName];
      }
    }
    function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        promise.then(callback, callback);
      }
      return promise;
    }
    function writeFileSync(filename, data, options) {
      if (typeof options === "string")
        options = { encoding: options };
      else if (!options)
        options = {};
      try {
        filename = fs.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (isTypedArray(data)) {
          data = typedArrayToBuffer(data);
        }
        if (Buffer.isBuffer(data)) {
          fs.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs.fsyncSync(fd);
        }
        fs.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// ../node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "../node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// ../node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "../node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "../node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/stringify.js
var require_stringify2 = __commonJS({
  "../node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify(arr, offset = 0) {
      const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "../node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default = v1;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/parse.js
var require_parse4 = __commonJS({
  "../node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "../node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    exports2.URL = exports2.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify2());
    var _parse = _interopRequireDefault(require_parse4());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes2(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes2(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// ../node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "../node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "../node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "../node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify2());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default = v4;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "../node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "../node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "../node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "../node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.substr(14, 1), 16);
    }
    var _default = version;
    exports2.default = _default;
  }
});

// ../node_modules/uuid/dist/index.js
var require_dist4 = __commonJS({
  "../node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify2());
    var _parse = _interopRequireDefault(require_parse4());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// ../node_modules/@serverless/utils/log.js
var require_log2 = __commonJS({
  "../node_modules/@serverless/utils/log.js"(exports2, module2) {
    "use strict";
    var chalk = require_source();
    module2.exports = (message, options = {}) => {
      const { underline = false, bold = false, color = null, entity = "Serverless" } = options;
      let print = chalk.yellow;
      if (color)
        print = chalk.keyword(color);
      if (underline)
        print = print.underline;
      if (bold)
        print = print.bold;
      process.stdout.write(`${entity}: ${print(message)}
`);
    };
  }
});

// ../node_modules/@serverless/utils/config.js
var require_config = __commonJS({
  "../node_modules/@serverless/utils/config.js"(exports2, module2) {
    "use strict";
    var p = require("path");
    var os = require("os");
    var fs = require("fs");
    var _2 = require_lodash();
    var writeFileAtomic = require_write_file_atomic();
    var uuid = require_dist4();
    var log = require_log2();
    var baseFilename = "serverless";
    if (process.env.SERVERLESS_PLATFORM_STAGE && process.env.SERVERLESS_PLATFORM_STAGE !== "prod") {
      baseFilename = `serverless${process.env.SERVERLESS_PLATFORM_STAGE.toLowerCase()}`;
      baseFilename = baseFilename.trim();
    }
    baseFilename = `.${baseFilename}rc`;
    var getLocalConfigPath = () => p.join(process.cwd(), baseFilename);
    var getDefaultGlobalConfigPath = () => p.join(os.homedir(), baseFilename);
    var getHomeConfigGlobalConfigPath = () => p.join(os.homedir(), ".config", baseFilename);
    var getGlobalConfigPath = () => {
      const homeConfigGlobalConfigPath = getHomeConfigGlobalConfigPath();
      const defaultGlobalConfigPath = getDefaultGlobalConfigPath();
      const homeConfigGlobalConfigExists = fs.existsSync(homeConfigGlobalConfigPath);
      const defaultGlobalConfigExists = fs.existsSync(defaultGlobalConfigPath);
      if (homeConfigGlobalConfigExists && defaultGlobalConfigExists) {
        log(`Found two global configuration files. Using: ${defaultGlobalConfigPath}`, {
          color: "orange"
        });
        return defaultGlobalConfigPath;
      }
      if (homeConfigGlobalConfigExists) {
        return homeConfigGlobalConfigPath;
      }
      return defaultGlobalConfigPath;
    };
    function storeConfig(config, configPath) {
      config.meta = config.meta || {};
      config.meta.updated_at = Math.round(Date.now() / 1e3);
      const jsonConfig = JSON.stringify(config, null, 2);
      try {
        writeFileAtomic.sync(configPath, jsonConfig);
      } catch (error) {
        if (process.env.SLS_DEBUG) {
          log(error.stack, { color: "red" });
          log(`Unable to store serverless config: ${configPath} due to ${error.code} error`, {
            color: "red"
          });
        }
      }
    }
    function createDefaultGlobalConfig() {
      const defaultConfig = {
        userId: null,
        frameworkId: uuid.v1(),
        trackingDisabled: false,
        enterpriseDisabled: false,
        meta: {
          created_at: Math.round(Date.now() / 1e3),
          updated_at: null
        }
      };
      storeConfig(defaultConfig, getDefaultGlobalConfigPath());
      return defaultConfig;
    }
    function getLocalConfig() {
      const localConfigPath = getLocalConfigPath();
      try {
        return JSON.parse(fs.readFileSync(localConfigPath));
      } catch (error) {
        if (error.code === "ENOENT")
          return {};
        log(`User Configuration warning: Cannot resolve local config file.
Error: ${error.message}`, {
          color: "orange"
        });
        try {
          const backupServerlessrcPath = `${localConfigPath}.bak`;
          fs.renameSync(localConfigPath, backupServerlessrcPath);
          log(`Your previous local config was renamed to ${backupServerlessrcPath} for debugging.`, {
            color: "orange"
          });
        } catch {
        }
      }
      return {};
    }
    function getGlobalConfig() {
      const globalConfigPath = getGlobalConfigPath();
      try {
        return JSON.parse(fs.readFileSync(globalConfigPath));
      } catch (error) {
        if (error.code !== "ENOENT") {
          log(`User Configuration warning: Cannot resolve global config file: ${globalConfigPath} 
Error: ${error.message}`, {
            color: "orange"
          });
          try {
            const backupServerlessrcPath = `${globalConfigPath}.bak`;
            fs.renameSync(globalConfigPath, backupServerlessrcPath);
            log(`Your previous global config was renamed to ${backupServerlessrcPath} for debugging. Default global config will be recreated under ${getDefaultGlobalConfigPath()}.`, { color: "orange" });
          } catch {
          }
        }
      }
      return createDefaultGlobalConfig();
    }
    function getConfig() {
      const localConfig = getLocalConfig();
      const globalConfig = getGlobalConfig();
      return _2.merge(globalConfig, localConfig);
    }
    function getConfigForUpdate() {
      const localConfigPath = getLocalConfigPath();
      const localConfigExists = fs.existsSync(localConfigPath);
      if (localConfigExists) {
        return {
          config: getLocalConfig(),
          configPath: localConfigPath
        };
      }
      return {
        config: getGlobalConfig(),
        configPath: getGlobalConfigPath()
      };
    }
    function set(key, value) {
      const configForUpdate = getConfigForUpdate();
      let { config } = configForUpdate;
      const { configPath } = configForUpdate;
      if (key && typeof key === "string" && typeof value !== "undefined") {
        config = _2.set(config, key, value);
      } else if (_2.isObject(key)) {
        config = _2.merge(config, key);
      } else if (typeof value !== "undefined") {
        config = _2.merge(config, value);
      }
      storeConfig(config, configPath);
      return getConfig();
    }
    function deleteValue(key) {
      const configForUpdate = getConfigForUpdate();
      let { config } = configForUpdate;
      const { configPath } = configForUpdate;
      if (key && typeof key === "string") {
        config = _2.omit(config, [key]);
      } else if (key && Array.isArray(key)) {
        config = _2.omit(config, key);
      }
      storeConfig(config, configPath);
      return getConfig();
    }
    function get(path) {
      const config = getConfig();
      return _2.get(config, path);
    }
    function getLoggedInUser() {
      const config = getConfig();
      if (!config.userId) {
        return null;
      }
      const user = _2.get(config, ["users", config.userId, "dashboard"]);
      if (!user || !user.username) {
        return null;
      }
      return {
        userId: config.userId,
        username: user.username,
        accessKeys: user.accessKeys,
        idToken: user.idToken,
        refreshToken: user.refreshToken
      };
    }
    module2.exports = {
      set,
      get,
      delete: deleteValue,
      getConfig,
      getLoggedInUser,
      CONFIG_FILE_NAME: baseFilename
    };
  }
});

// ../node_modules/@serverless/utils/node_modules/jwt-decode/build/jwt-decode.cjs.js
var require_jwt_decode_cjs = __commonJS({
  "../node_modules/@serverless/utils/node_modules/jwt-decode/build/jwt-decode.cjs.js"(exports2, module2) {
    "use strict";
    function e(e2) {
      this.message = e2;
    }
    e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
    var r = typeof window != "undefined" && window.atob && window.atob.bind(window) || function(r2) {
      var t2 = String(r2).replace(/=+$/, "");
      if (t2.length % 4 == 1)
        throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
      for (var n2, o2, a2 = 0, i = 0, c = ""; o2 = t2.charAt(i++); ~o2 && (n2 = a2 % 4 ? 64 * n2 + o2 : o2, a2++ % 4) ? c += String.fromCharCode(255 & n2 >> (-2 * a2 & 6)) : 0)
        o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
      return c;
    };
    function t(e2) {
      var t2 = e2.replace(/-/g, "+").replace(/_/g, "/");
      switch (t2.length % 4) {
        case 0:
          break;
        case 2:
          t2 += "==";
          break;
        case 3:
          t2 += "=";
          break;
        default:
          throw "Illegal base64url string!";
      }
      try {
        return function(e3) {
          return decodeURIComponent(r(e3).replace(/(.)/g, function(e4, r2) {
            var t3 = r2.charCodeAt(0).toString(16).toUpperCase();
            return t3.length < 2 && (t3 = "0" + t3), "%" + t3;
          }));
        }(t2);
      } catch (e3) {
        return r(t2);
      }
    }
    function n(e2) {
      this.message = e2;
    }
    function o(e2, r2) {
      if (typeof e2 != "string")
        throw new n("Invalid token specified");
      var o2 = (r2 = r2 || {}).header === true ? 0 : 1;
      try {
        return JSON.parse(t(e2.split(".")[o2]));
      } catch (e3) {
        throw new n("Invalid token specified: " + e3.message);
      }
    }
    n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
    var a = o;
    a.default = o, a.InvalidTokenError = n, module2.exports = a;
  }
});

// ../node_modules/@serverless/utils/account.js
var require_account = __commonJS({
  "../node_modules/@serverless/utils/account.js"(exports2, module2) {
    "use strict";
    var configUtils = require_config();
    var jwtDecode = require_jwt_decode_cjs();
    var logout = () => {
      const loggedInUser = configUtils.getLoggedInUser();
      const data = {
        userId: null
      };
      if (loggedInUser) {
        data.users = {
          [loggedInUser.userId]: {
            dashboard: {
              accessToken: null,
              idToken: null,
              expiresAt: null,
              refreshToken: null
            }
          }
        };
      }
      configUtils.set(data);
    };
    var refreshToken = async (sdk) => {
      const loggedInUser = configUtils.getLoggedInUser();
      if (!loggedInUser || !loggedInUser.refreshToken || !loggedInUser.idToken) {
        return;
      }
      const decoded = jwtDecode(loggedInUser.idToken);
      if (Number(decoded.exp) * 1e3 > Date.now()) {
        return;
      }
      const tokens = await sdk.session.refreshToken(loggedInUser.refreshToken);
      const data = {
        users: {
          [loggedInUser.userId]: {
            dashboard: {
              idToken: tokens.id_token,
              accessToken: tokens.access_token
            }
          }
        }
      };
      configUtils.set(data);
    };
    module2.exports = {
      logout,
      refreshToken
    };
  }
});

// ../node_modules/ws/lib/constants.js
var require_constants5 = __commonJS({
  "../node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// ../node_modules/node-gyp-build/index.js
var require_node_gyp_build = __commonJS({
  "../node_modules/node-gyp-build/index.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var runtimeRequire = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
    var vars = process.config && process.config.variables || {};
    var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
    var abi = process.versions.modules;
    var runtime = isElectron() ? "electron" : "node";
    var arch = os.arch();
    var platform = os.platform();
    var libc = process.env.LIBC || (isAlpine(platform) ? "musl" : "glibc");
    var armv = process.env.ARM_VERSION || (arch === "arm64" ? "8" : vars.arm_version) || "";
    var uv = (process.versions.uv || "").split(".")[0];
    module2.exports = load;
    function load(dir) {
      return runtimeRequire(load.path(dir));
    }
    load.path = function(dir) {
      dir = path.resolve(dir || ".");
      try {
        var name = runtimeRequire(path.join(dir, "package.json")).name.toUpperCase().replace(/-/g, "_");
        if (process.env[name + "_PREBUILD"])
          dir = process.env[name + "_PREBUILD"];
      } catch (err) {
      }
      if (!prebuildsOnly) {
        var release = getFirst(path.join(dir, "build/Release"), matchBuild);
        if (release)
          return release;
        var debug = getFirst(path.join(dir, "build/Debug"), matchBuild);
        if (debug)
          return debug;
      }
      var prebuild = resolve2(dir);
      if (prebuild)
        return prebuild;
      var nearby = resolve2(path.dirname(process.execPath));
      if (nearby)
        return nearby;
      var target = [
        "platform=" + platform,
        "arch=" + arch,
        "runtime=" + runtime,
        "abi=" + abi,
        "uv=" + uv,
        armv ? "armv=" + armv : "",
        "libc=" + libc,
        "node=" + process.versions.node,
        process.versions.electron ? "electron=" + process.versions.electron : "",
        typeof __webpack_require__ === "function" ? "webpack=true" : ""
      ].filter(Boolean).join(" ");
      throw new Error("No native build was found for " + target + "\n    loaded from: " + dir + "\n");
      function resolve2(dir2) {
        var tuples = readdirSync(path.join(dir2, "prebuilds")).map(parseTuple);
        var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
        if (!tuple)
          return;
        var prebuilds = path.join(dir2, "prebuilds", tuple.name);
        var parsed = readdirSync(prebuilds).map(parseTags);
        var candidates = parsed.filter(matchTags(runtime, abi));
        var winner = candidates.sort(compareTags(runtime))[0];
        if (winner)
          return path.join(prebuilds, winner.file);
      }
    };
    function readdirSync(dir) {
      try {
        return fs.readdirSync(dir);
      } catch (err) {
        return [];
      }
    }
    function getFirst(dir, filter) {
      var files = readdirSync(dir).filter(filter);
      return files[0] && path.join(dir, files[0]);
    }
    function matchBuild(name) {
      return /\.node$/.test(name);
    }
    function parseTuple(name) {
      var arr = name.split("-");
      if (arr.length !== 2)
        return;
      var platform2 = arr[0];
      var architectures = arr[1].split("+");
      if (!platform2)
        return;
      if (!architectures.length)
        return;
      if (!architectures.every(Boolean))
        return;
      return { name, platform: platform2, architectures };
    }
    function matchTuple(platform2, arch2) {
      return function(tuple) {
        if (tuple == null)
          return false;
        if (tuple.platform !== platform2)
          return false;
        return tuple.architectures.includes(arch2);
      };
    }
    function compareTuples(a, b) {
      return a.architectures.length - b.architectures.length;
    }
    function parseTags(file) {
      var arr = file.split(".");
      var extension = arr.pop();
      var tags = { file, specificity: 0 };
      if (extension !== "node")
        return;
      for (var i = 0; i < arr.length; i++) {
        var tag = arr[i];
        if (tag === "node" || tag === "electron" || tag === "node-webkit") {
          tags.runtime = tag;
        } else if (tag === "napi") {
          tags.napi = true;
        } else if (tag.slice(0, 3) === "abi") {
          tags.abi = tag.slice(3);
        } else if (tag.slice(0, 2) === "uv") {
          tags.uv = tag.slice(2);
        } else if (tag.slice(0, 4) === "armv") {
          tags.armv = tag.slice(4);
        } else if (tag === "glibc" || tag === "musl") {
          tags.libc = tag;
        } else {
          continue;
        }
        tags.specificity++;
      }
      return tags;
    }
    function matchTags(runtime2, abi2) {
      return function(tags) {
        if (tags == null)
          return false;
        if (tags.runtime !== runtime2 && !runtimeAgnostic(tags))
          return false;
        if (tags.abi !== abi2 && !tags.napi)
          return false;
        if (tags.uv && tags.uv !== uv)
          return false;
        if (tags.armv && tags.armv !== armv)
          return false;
        if (tags.libc && tags.libc !== libc)
          return false;
        return true;
      };
    }
    function runtimeAgnostic(tags) {
      return tags.runtime === "node" && tags.napi;
    }
    function compareTags(runtime2) {
      return function(a, b) {
        if (a.runtime !== b.runtime) {
          return a.runtime === runtime2 ? -1 : 1;
        } else if (a.abi !== b.abi) {
          return a.abi ? -1 : 1;
        } else if (a.specificity !== b.specificity) {
          return a.specificity > b.specificity ? -1 : 1;
        } else {
          return 0;
        }
      };
    }
    function isElectron() {
      if (process.versions && process.versions.electron)
        return true;
      if (process.env.ELECTRON_RUN_AS_NODE)
        return true;
      return typeof window !== "undefined" && window.process && window.process.type === "renderer";
    }
    function isAlpine(platform2) {
      return platform2 === "linux" && fs.existsSync("/etc/alpine-release");
    }
    load.parseTags = parseTags;
    load.matchTags = matchTags;
    load.compareTags = compareTags;
    load.parseTuple = parseTuple;
    load.matchTuple = matchTuple;
    load.compareTuples = compareTuples;
  }
});

// ../node_modules/bufferutil/fallback.js
var require_fallback = __commonJS({
  "../node_modules/bufferutil/fallback.js"(exports2, module2) {
    "use strict";
    var mask = (source, mask2, output, offset, length) => {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask2[i & 3];
      }
    };
    var unmask = (buffer, mask2) => {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask2[i & 3];
      }
    };
    module2.exports = { mask, unmask };
  }
});

// ../node_modules/bufferutil/index.js
var require_bufferutil = __commonJS({
  "../node_modules/bufferutil/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e) {
      module2.exports = require_fallback();
    }
  }
});

// ../node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "../node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants5();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength)
        return target.slice(0, offset);
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (let i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    try {
      const bufferUtil = require_bufferutil();
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// ../node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "../node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      [kRun]() {
        if (this.pending === this.concurrency)
          return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// ../node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "../node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode, NOOP } = require_constants5();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw(__spreadProps(__spreadValues({}, this._options.zlibInflateOptions), {
            windowBits
          }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw(__spreadProps(__spreadValues({}, this._options.zlibDeflateOptions), {
            windowBits
          }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// ../node_modules/utf-8-validate/fallback.js
var require_fallback2 = __commonJS({
  "../node_modules/utf-8-validate/fallback.js"(exports2, module2) {
    "use strict";
    function isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    module2.exports = isValidUTF8;
  }
});

// ../node_modules/utf-8-validate/index.js
var require_utf_8_validate = __commonJS({
  "../node_modules/utf-8-validate/index.js"(exports2, module2) {
    "use strict";
    try {
      module2.exports = require_node_gyp_build()(__dirname);
    } catch (e) {
      module2.exports = require_fallback2();
    }
  }
});

// ../node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "../node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    try {
      let isValidUTF8 = require_utf_8_validate();
      if (typeof isValidUTF8 === "object") {
        isValidUTF8 = isValidUTF8.Validation.isValidUTF8;
      }
      module2.exports = {
        isValidStatusCode,
        isValidUTF8(buf) {
          return buf.length < 150 ? _isValidUTF8(buf) : isValidUTF8(buf);
        }
      };
    } catch (e) {
      module2.exports = {
        isValidStatusCode,
        isValidUTF8: _isValidUTF8
      };
    }
  }
});

// ../node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "../node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants5();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, isServer, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._isServer = !!isServer;
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        let err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            this._loop = false;
            return error(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
          }
        } else if (this._masked) {
          this._loop = false;
          return error(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
        }
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            let data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode, errorCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err.code = errorCode;
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// ../node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "../node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants5();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var mask = Buffer.alloc(4);
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        let offset = options.mask ? 6 : 2;
        let payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        randomFillSync(mask, 0, 4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask2, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask2, cb]);
        } else {
          this.doClose(buf, mask2, cb);
        }
      }
      doClose(data, mask2, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask: mask2,
          readOnly: false
        }), cb);
      }
      ping(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask: mask2,
          readOnly
        }), cb);
      }
      pong(data, mask2, cb) {
        const buf = toBuffer(data);
        if (buf.length > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask2, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask2, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask2, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask: mask2,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += data.length;
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_2, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function")
              cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const callback = this._queue[i][4];
              if (typeof callback === "function")
                callback(err);
            }
            return;
          }
          this._bufferedBytes -= data.length;
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// ../node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "../node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var Event = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(type, listener, options) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        const method = options && options.once ? "once" : "on";
        if (type === "message") {
          onMessage._listener = listener;
          this[method](type, onMessage);
        } else if (type === "close") {
          onClose._listener = listener;
          this[method](type, onClose);
        } else if (type === "error") {
          onError._listener = listener;
          this[method](type, onError);
        } else if (type === "open") {
          onOpen._listener = listener;
          this[method](type, onOpen);
        } else {
          this[method](type, listener);
        }
      },
      removeEventListener(type, listener) {
        const listeners = this.listeners(type);
        for (let i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(type, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// ../node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "../node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (dest[name] === void 0)
        dest[name] = [elem];
      else
        dest[name].push(elem);
    }
    function parse(header) {
      const offers = Object.create(null);
      if (header === void 0 || header === "")
        return offers;
      let params = Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            let values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// ../node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "../node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Readable: Readable2 } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants5();
    var { addEventListener, removeEventListener } = require_event_target();
    var { format, parse } = require_extension();
    var { toBuffer } = require_buffer_util();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._extensions = {};
        this._protocol = "";
        this._readyState = WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      get onclose() {
        return void 0;
      }
      set onclose(listener) {
      }
      get onerror() {
        return void 0;
      }
      set onerror(listener) {
      }
      get onopen() {
        return void 0;
      }
      set onopen(listener) {
      }
      get onmessage() {
        return void 0;
      }
      set onmessage(listener) {
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get url() {
        return this._url;
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this.binaryType, this._extensions, this._isServer, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (this.readyState === WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number")
          data = data.toString();
        if (this.readyState !== WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = __spreadValues({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this._readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        enumerable: true,
        get() {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (let i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = addEventListener;
    WebSocket.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = __spreadProps(__spreadValues({
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options), {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
        websocket._url = address.href;
      } else {
        parsedUrl = new URL2(address);
        websocket._url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        const err = new Error(`Invalid URL: ${websocket.url}`);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      let perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = __spreadValues({
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      }, opts.headers);
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req.aborted)
          return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (err) {
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        let protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length) {
            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
              const message = "Server indicated an extension that was not requested";
              abortHandshake(websocket, socket, message);
              return;
            }
            try {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
            } catch (err) {
              const message = "Invalid Sec-WebSocket-Extensions header";
              abortHandshake(websocket, socket, message);
              return;
            }
            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream2, message) {
      websocket._readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream2.setHeader) {
        stream2.abort();
        if (stream2.socket && !stream2.socket.destroyed) {
          stream2.socket.destroy();
        }
        stream2.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream2.destroy(err);
        stream2.once("error", websocket.emit.bind(websocket, "error"));
        stream2.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer(data).length;
        if (websocket._socket)
          websocket._sender._bufferedBytes += length;
        else
          websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        cb(err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0)
        return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream2) {
      stream2.resume();
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket.CLOSING;
        this.destroy();
      }
    }
  }
});

// ../node_modules/ws/lib/stream.js
var require_stream9 = __commonJS({
  "../node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream2) {
      stream2.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream(ws, options) {
      let resumeOnReceiverDrain = true;
      let terminateOnDestroy = true;
      function receiverOnDrain() {
        if (resumeOnReceiverDrain)
          ws._socket.resume();
      }
      if (ws.readyState === ws.CONNECTING) {
        ws.once("open", function open() {
          ws._receiver.removeAllListeners("drain");
          ws._receiver.on("drain", receiverOnDrain);
        });
      } else {
        ws._receiver.removeAllListeners("drain");
        ws._receiver.on("drain", receiverOnDrain);
      }
      const duplex = new Duplex(__spreadProps(__spreadValues({}, options), {
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      }));
      ws.on("message", function message(msg) {
        if (!duplex.push(msg)) {
          resumeOnReceiverDrain = false;
          ws._socket.pause();
        }
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed)
          return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed)
          return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called)
            callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy)
          ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null)
          return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted)
            duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if ((ws.readyState === ws.OPEN || ws.readyState === ws.CLOSING) && !resumeOnReceiverDrain) {
          resumeOnReceiverDrain = true;
          if (!ws._receiver._writableState.needDrain)
            ws._socket.resume();
        }
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream;
  }
});

// ../node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "../node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var https = require("https");
    var net = require("net");
    var tls = require("tls");
    var { createHash } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var WebSocket = require_websocket();
    var { format, parse } = require_extension();
    var { GUID, kWebSocket } = require_constants5();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = __spreadValues({
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null
        }, options);
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = new Set();
        this.options = options;
        this._state = RUNNING;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this._state === CLOSED) {
          process.nextTick(emitClose, this);
          return;
        }
        if (this._state === CLOSING)
          return;
        this._state = CLOSING;
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(emitClose.bind(void 0, this));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING)
          return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        let protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = __spreadValues({
          Connection: "close",
          "Content-Type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// ../node_modules/ws/index.js
var require_ws = __commonJS({
  "../node_modules/ws/index.js"(exports2, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.createWebSocketStream = require_stream9();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// ../node_modules/isomorphic-ws/node.js
var require_node3 = __commonJS({
  "../node_modules/isomorphic-ws/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_ws();
  }
});

// ../node_modules/jwt-decode/lib/atob.js
var require_atob = __commonJS({
  "../node_modules/jwt-decode/lib/atob.js"(exports2, module2) {
    var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    function InvalidCharacterError(message) {
      this.message = message;
    }
    InvalidCharacterError.prototype = new Error();
    InvalidCharacterError.prototype.name = "InvalidCharacterError";
    function polyfill(input) {
      var str = String(input).replace(/=+$/, "");
      if (str.length % 4 == 1) {
        throw new InvalidCharacterError("'atob' failed: The string to be decoded is not correctly encoded.");
      }
      for (var bc = 0, bs, buffer, idx = 0, output = ""; buffer = str.charAt(idx++); ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer, bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0) {
        buffer = chars.indexOf(buffer);
      }
      return output;
    }
    module2.exports = typeof window !== "undefined" && window.atob && window.atob.bind(window) || polyfill;
  }
});

// ../node_modules/jwt-decode/lib/base64_url_decode.js
var require_base64_url_decode = __commonJS({
  "../node_modules/jwt-decode/lib/base64_url_decode.js"(exports2, module2) {
    var atob = require_atob();
    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).replace(/(.)/g, function(m, p) {
        var code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      }));
    }
    module2.exports = function(str) {
      var output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw "Illegal base64url string!";
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob(output);
      }
    };
  }
});

// ../node_modules/jwt-decode/lib/index.js
var require_lib3 = __commonJS({
  "../node_modules/jwt-decode/lib/index.js"(exports2, module2) {
    "use strict";
    var base64_url_decode = require_base64_url_decode();
    function InvalidTokenError(message) {
      this.message = message;
    }
    InvalidTokenError.prototype = new Error();
    InvalidTokenError.prototype.name = "InvalidTokenError";
    module2.exports = function(token, options) {
      if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified");
      }
      options = options || {};
      var pos = options.header === true ? 0 : 1;
      try {
        return JSON.parse(base64_url_decode(token.split(".")[pos]));
      } catch (e) {
        throw new InvalidTokenError("Invalid token specified: " + e.message);
      }
    };
    module2.exports.InvalidTokenError = InvalidTokenError;
  }
});

// ../node_modules/@serverless/platform-client/src/domains.json
var require_domains = __commonJS({
  "../node_modules/@serverless/platform-client/src/domains.json"(exports2, module2) {
    module2.exports = {
      local: {
        core: "http://localhost:3011"
      },
      dev: {
        core: "https://api.serverless-dev.com",
        "events-streaming": "wss://events-streaming-v1.serverless-platform-dev.com",
        events: "https://events-v1.serverless-platform-dev.com",
        registry: "https://registry-v1.serverless-platform-dev.com",
        engine: "https://engine-v1.serverless-platform-dev.com",
        dashboard: "https://app.serverless-dev.com",
        providers: "https://sp-providers-v1.serverless-platform-dev.com",
        "event-webhooks": "https://event-webhooks-v1.serverless-platform-dev.com",
        connections: "https://connections-v1.serverless-platform-dev.com",
        desktop: "https://desktop-v1.serverless-platform-dev.com"
      },
      prod: {
        core: "https://api.serverless.com",
        "events-streaming": "wss://events-streaming-v1.serverless-platform.com",
        events: "https://events-v1.serverless-platform.com",
        registry: "https://registry-v1.serverless-platform.com",
        engine: "https://engine-v1.serverless-platform.com",
        dashboard: "https://app.serverless.com",
        providers: "https://sp-providers-v1.serverless-platform.com",
        "event-webhooks": "https://event-webhooks-v1.serverless-platform.com",
        connections: "https://connections-v1.serverless-platform.com",
        desktop: "https://desktop-v1.serverless-platform.com"
      }
    };
  }
});

// ../node_modules/traverse/index.js
var require_traverse = __commonJS({
  "../node_modules/traverse/index.js"(exports2, module2) {
    var traverse = module2.exports = function(obj) {
      return new Traverse(obj);
    };
    function Traverse(obj) {
      this.value = obj;
    }
    Traverse.prototype.get = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty2.call(node, key)) {
          node = void 0;
          break;
        }
        node = node[key];
      }
      return node;
    };
    Traverse.prototype.has = function(ps) {
      var node = this.value;
      for (var i = 0; i < ps.length; i++) {
        var key = ps[i];
        if (!node || !hasOwnProperty2.call(node, key)) {
          return false;
        }
        node = node[key];
      }
      return true;
    };
    Traverse.prototype.set = function(ps, value) {
      var node = this.value;
      for (var i = 0; i < ps.length - 1; i++) {
        var key = ps[i];
        if (!hasOwnProperty2.call(node, key))
          node[key] = {};
        node = node[key];
      }
      node[ps[i]] = value;
      return value;
    };
    Traverse.prototype.map = function(cb) {
      return walk(this.value, cb, true);
    };
    Traverse.prototype.forEach = function(cb) {
      this.value = walk(this.value, cb, false);
      return this.value;
    };
    Traverse.prototype.reduce = function(cb, init) {
      var skip = arguments.length === 1;
      var acc = skip ? this.value : init;
      this.forEach(function(x) {
        if (!this.isRoot || !skip) {
          acc = cb.call(this, acc, x);
        }
      });
      return acc;
    };
    Traverse.prototype.paths = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.path);
      });
      return acc;
    };
    Traverse.prototype.nodes = function() {
      var acc = [];
      this.forEach(function(x) {
        acc.push(this.node);
      });
      return acc;
    };
    Traverse.prototype.clone = function() {
      var parents = [], nodes = [];
      return function clone(src) {
        for (var i = 0; i < parents.length; i++) {
          if (parents[i] === src) {
            return nodes[i];
          }
        }
        if (typeof src === "object" && src !== null) {
          var dst = copy(src);
          parents.push(src);
          nodes.push(dst);
          forEach(objectKeys(src), function(key) {
            dst[key] = clone(src[key]);
          });
          parents.pop();
          nodes.pop();
          return dst;
        } else {
          return src;
        }
      }(this.value);
    };
    function walk(root, cb, immutable) {
      var path = [];
      var parents = [];
      var alive = true;
      return function walker(node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        var keepGoing = true;
        var state = {
          node,
          node_,
          path: [].concat(path),
          parent: parents[parents.length - 1],
          parents,
          key: path.slice(-1)[0],
          isRoot: path.length === 0,
          level: path.length,
          circular: null,
          update: function(x, stopHere) {
            if (!state.isRoot) {
              state.parent.node[state.key] = x;
            }
            state.node = x;
            if (stopHere)
              keepGoing = false;
          },
          "delete": function(stopHere) {
            delete state.parent.node[state.key];
            if (stopHere)
              keepGoing = false;
          },
          remove: function(stopHere) {
            if (isArray(state.parent.node)) {
              state.parent.node.splice(state.key, 1);
            } else {
              delete state.parent.node[state.key];
            }
            if (stopHere)
              keepGoing = false;
          },
          keys: null,
          before: function(f) {
            modifiers.before = f;
          },
          after: function(f) {
            modifiers.after = f;
          },
          pre: function(f) {
            modifiers.pre = f;
          },
          post: function(f) {
            modifiers.post = f;
          },
          stop: function() {
            alive = false;
          },
          block: function() {
            keepGoing = false;
          }
        };
        if (!alive)
          return state;
        function updateState() {
          if (typeof state.node === "object" && state.node !== null) {
            if (!state.keys || state.node_ !== state.node) {
              state.keys = objectKeys(state.node);
            }
            state.isLeaf = state.keys.length == 0;
            for (var i = 0; i < parents.length; i++) {
              if (parents[i].node_ === node_) {
                state.circular = parents[i];
                break;
              }
            }
          } else {
            state.isLeaf = true;
            state.keys = null;
          }
          state.notLeaf = !state.isLeaf;
          state.notRoot = !state.isRoot;
        }
        updateState();
        var ret = cb.call(state, state.node);
        if (ret !== void 0 && state.update)
          state.update(ret);
        if (modifiers.before)
          modifiers.before.call(state, state.node);
        if (!keepGoing)
          return state;
        if (typeof state.node == "object" && state.node !== null && !state.circular) {
          parents.push(state);
          updateState();
          forEach(state.keys, function(key, i) {
            path.push(key);
            if (modifiers.pre)
              modifiers.pre.call(state, state.node[key], key);
            var child = walker(state.node[key]);
            if (immutable && hasOwnProperty2.call(state.node, key)) {
              state.node[key] = child.node;
            }
            child.isLast = i == state.keys.length - 1;
            child.isFirst = i == 0;
            if (modifiers.post)
              modifiers.post.call(state, child);
            path.pop();
          });
          parents.pop();
        }
        if (modifiers.after)
          modifiers.after.call(state, state.node);
        return state;
      }(root).node;
    }
    function copy(src) {
      if (typeof src === "object" && src !== null) {
        var dst;
        if (isArray(src)) {
          dst = [];
        } else if (isDate(src)) {
          dst = new Date(src.getTime ? src.getTime() : src);
        } else if (isRegExp(src)) {
          dst = new RegExp(src);
        } else if (isError(src)) {
          dst = { message: src.message };
        } else if (isBoolean(src)) {
          dst = new Boolean(src);
        } else if (isNumber(src)) {
          dst = new Number(src);
        } else if (isString(src)) {
          dst = new String(src);
        } else if (Object.create && Object.getPrototypeOf) {
          dst = Object.create(Object.getPrototypeOf(src));
        } else if (src.constructor === Object) {
          dst = {};
        } else {
          var proto = src.constructor && src.constructor.prototype || src.__proto__ || {};
          var T = function() {
          };
          T.prototype = proto;
          dst = new T();
        }
        forEach(objectKeys(src), function(key) {
          dst[key] = src[key];
        });
        return dst;
      } else
        return src;
    }
    var objectKeys = Object.keys || function keys(obj) {
      var res = [];
      for (var key in obj)
        res.push(key);
      return res;
    };
    function toS(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isDate(obj) {
      return toS(obj) === "[object Date]";
    }
    function isRegExp(obj) {
      return toS(obj) === "[object RegExp]";
    }
    function isError(obj) {
      return toS(obj) === "[object Error]";
    }
    function isBoolean(obj) {
      return toS(obj) === "[object Boolean]";
    }
    function isNumber(obj) {
      return toS(obj) === "[object Number]";
    }
    function isString(obj) {
      return toS(obj) === "[object String]";
    }
    var isArray = Array.isArray || function isArray2(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
    var forEach = function(xs, fn) {
      if (xs.forEach)
        return xs.forEach(fn);
      else
        for (var i = 0; i < xs.length; i++) {
          fn(xs[i], i, xs);
        }
    };
    forEach(objectKeys(Traverse.prototype), function(key) {
      traverse[key] = function(obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
      };
    });
    var hasOwnProperty2 = Object.hasOwnProperty || function(obj, key) {
      return key in obj;
    };
  }
});

// ../node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "../node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve2, reject2) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject2(err);
            } else {
              resolve2(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// ../node_modules/agent-base/dist/src/index.js
var require_src8 = __commonJS({
  "../node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src7());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// ../node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "../node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src7());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve2, reject2) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject2(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve2({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// ../node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "../node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src7());
    var agent_base_1 = require_src8();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// ../node_modules/https-proxy-agent/dist/index.js
var require_dist5 = __commonJS({
  "../node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// ../node_modules/readdir-glob/index.js
var require_readdir_glob = __commonJS({
  "../node_modules/readdir-glob/index.js"(exports2, module2) {
    module2.exports = readdirGlob;
    var fs = require("fs");
    var { EventEmitter } = require("events");
    var { Minimatch } = require_minimatch();
    var { resolve: resolve2 } = require("path");
    function readdir(dir, strict) {
      return new Promise((resolve3, reject2) => {
        fs.readdir(dir, { withFileTypes: true }, (err, files) => {
          if (err) {
            switch (err.code) {
              case "ENOTDIR":
                if (strict) {
                  reject2(err);
                } else {
                  resolve3([]);
                }
                break;
              case "ENOTSUP":
              case "ENOENT":
              case "ENAMETOOLONG":
              case "UNKNOWN":
                resolve3([]);
                break;
              case "ELOOP":
              default:
                reject2(err);
                break;
            }
          } else {
            resolve3(files);
          }
        });
      });
    }
    function stat(file, followSyslinks) {
      return new Promise((resolve3, reject2) => {
        const statFunc = followSyslinks ? fs.stat : fs.lstat;
        statFunc(file, (err, stats) => {
          if (err) {
            switch (err.code) {
              case "ENOENT":
                if (followSyslinks) {
                  resolve3(stat(file, false));
                } else {
                  resolve3(null);
                }
                break;
              default:
                resolve3(null);
                break;
            }
          } else {
            resolve3(stats);
          }
        });
      });
    }
    async function* exploreWalkAsync(dir, path, followSyslinks, useStat, shouldSkip, strict) {
      let files = await readdir(path + dir, strict);
      for (const file of files) {
        let name = file.name;
        if (name === void 0) {
          name = file;
          useStat = true;
        }
        const filename = dir + "/" + name;
        const relative = filename.slice(1);
        const absolute = path + "/" + relative;
        let stats = null;
        if (useStat || followSyslinks) {
          stats = await stat(absolute, followSyslinks);
        }
        if (!stats && file.name !== void 0) {
          stats = file;
        }
        if (stats === null) {
          stats = { isDirectory: () => false };
        }
        if (stats.isDirectory()) {
          if (!shouldSkip(relative)) {
            yield { relative, absolute, stats };
            yield* exploreWalkAsync(filename, path, followSyslinks, useStat, shouldSkip, false);
          }
        } else {
          yield { relative, absolute, stats };
        }
      }
    }
    async function* explore(path, followSyslinks, useStat, shouldSkip) {
      yield* exploreWalkAsync("", path, followSyslinks, useStat, shouldSkip, true);
    }
    function readOptions(options) {
      return {
        pattern: options.pattern,
        dot: !!options.dot,
        noglobstar: !!options.noglobstar,
        matchBase: !!options.matchBase,
        nocase: !!options.nocase,
        ignore: options.ignore,
        skip: options.skip,
        follow: !!options.follow,
        stat: !!options.stat,
        nodir: !!options.nodir,
        mark: !!options.mark,
        silent: !!options.silent,
        absolute: !!options.absolute
      };
    }
    var ReaddirGlob = class extends EventEmitter {
      constructor(cwd, options, cb) {
        super();
        if (typeof options === "function") {
          cb = options;
          options = null;
        }
        this.options = readOptions(options || {});
        this.matchers = [];
        if (this.options.pattern) {
          const matchers = Array.isArray(this.options.pattern) ? this.options.pattern : [this.options.pattern];
          this.matchers = matchers.map((m) => new Minimatch(m, {
            dot: this.options.dot,
            noglobstar: this.options.noglobstar,
            matchBase: this.options.matchBase,
            nocase: this.options.nocase
          }));
        }
        this.ignoreMatchers = [];
        if (this.options.ignore) {
          const ignorePatterns = Array.isArray(this.options.ignore) ? this.options.ignore : [this.options.ignore];
          this.ignoreMatchers = ignorePatterns.map((ignore) => new Minimatch(ignore, { dot: true }));
        }
        this.skipMatchers = [];
        if (this.options.skip) {
          const skipPatterns = Array.isArray(this.options.skip) ? this.options.skip : [this.options.skip];
          this.skipMatchers = skipPatterns.map((skip) => new Minimatch(skip, { dot: true }));
        }
        this.iterator = explore(resolve2(cwd || "."), this.options.follow, this.options.stat, this._shouldSkipDirectory.bind(this));
        this.paused = false;
        this.inactive = false;
        this.aborted = false;
        if (cb) {
          this._matches = [];
          this.on("match", (match) => this._matches.push(this.options.absolute ? match.absolute : match.relative));
          this.on("error", (err) => cb(err));
          this.on("end", () => cb(null, this._matches));
        }
        setTimeout(() => this._next(), 0);
      }
      _shouldSkipDirectory(relative) {
        return this.skipMatchers.some((m) => m.match(relative));
      }
      _fileMatches(relative, isDirectory) {
        const file = relative + (isDirectory ? "/" : "");
        return (this.matchers.length === 0 || this.matchers.some((m) => m.match(file))) && !this.ignoreMatchers.some((m) => m.match(file)) && (!this.options.nodir || !isDirectory);
      }
      _next() {
        if (!this.paused && !this.aborted) {
          this.iterator.next().then((obj) => {
            if (!obj.done) {
              const isDirectory = obj.value.stats.isDirectory();
              if (this._fileMatches(obj.value.relative, isDirectory)) {
                let relative = obj.value.relative;
                let absolute = obj.value.absolute;
                if (this.options.mark && isDirectory) {
                  relative += "/";
                  absolute += "/";
                }
                if (this.options.stat) {
                  this.emit("match", { relative, absolute, stat: obj.value.stats });
                } else {
                  this.emit("match", { relative, absolute });
                }
              }
              this._next(this.iterator);
            } else {
              this.emit("end");
            }
          }).catch((err) => {
            this.abort();
            this.emit("error", err);
            if (!err.code && !this.options.silent) {
              console.error(err);
            }
          });
        } else {
          this.inactive = true;
        }
      }
      abort() {
        this.aborted = true;
      }
      pause() {
        this.paused = true;
      }
      resume() {
        this.paused = false;
        if (this.inactive) {
          this.inactive = false;
          this._next();
        }
      }
    };
    function readdirGlob(pattern, options, cb) {
      return new ReaddirGlob(pattern, options, cb);
    }
    readdirGlob.ReaddirGlob = ReaddirGlob;
  }
});

// ../node_modules/async/dist/async.js
var require_async6 = __commonJS({
  "../node_modules/async/dist/async.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.async = {});
    })(exports2, function(exports3) {
      "use strict";
      function apply(fn, ...args) {
        return (...callArgs) => fn(...args, ...callArgs);
      }
      function initialParams(fn) {
        return function(...args) {
          var callback = args.pop();
          return fn.call(this, args, callback);
        };
      }
      var hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
      var hasSetImmediate = typeof setImmediate === "function" && setImmediate;
      var hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
      function fallback(fn) {
        setTimeout(fn, 0);
      }
      function wrap(defer) {
        return (fn, ...args) => defer(() => fn(...args));
      }
      var _defer;
      if (hasQueueMicrotask) {
        _defer = queueMicrotask;
      } else if (hasSetImmediate) {
        _defer = setImmediate;
      } else if (hasNextTick) {
        _defer = process.nextTick;
      } else {
        _defer = fallback;
      }
      var setImmediate$1 = wrap(_defer);
      function asyncify(func) {
        if (isAsync(func)) {
          return function(...args) {
            const callback = args.pop();
            const promise = func.apply(this, args);
            return handlePromise(promise, callback);
          };
        }
        return initialParams(function(args, callback) {
          var result;
          try {
            result = func.apply(this, args);
          } catch (e) {
            return callback(e);
          }
          if (result && typeof result.then === "function") {
            return handlePromise(result, callback);
          } else {
            callback(null, result);
          }
        });
      }
      function handlePromise(promise, callback) {
        return promise.then((value) => {
          invokeCallback(callback, null, value);
        }, (err) => {
          invokeCallback(callback, err && err.message ? err : new Error(err));
        });
      }
      function invokeCallback(callback, error, value) {
        try {
          callback(error, value);
        } catch (err) {
          setImmediate$1((e) => {
            throw e;
          }, err);
        }
      }
      function isAsync(fn) {
        return fn[Symbol.toStringTag] === "AsyncFunction";
      }
      function isAsyncGenerator(fn) {
        return fn[Symbol.toStringTag] === "AsyncGenerator";
      }
      function isAsyncIterable(obj) {
        return typeof obj[Symbol.asyncIterator] === "function";
      }
      function wrapAsync(asyncFn) {
        if (typeof asyncFn !== "function")
          throw new Error("expected a function");
        return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
      }
      function awaitify(asyncFn, arity = asyncFn.length) {
        if (!arity)
          throw new Error("arity is undefined");
        function awaitable(...args) {
          if (typeof args[arity - 1] === "function") {
            return asyncFn.apply(this, args);
          }
          return new Promise((resolve2, reject3) => {
            args[arity - 1] = (err, ...cbArgs) => {
              if (err)
                return reject3(err);
              resolve2(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
            };
            asyncFn.apply(this, args);
          });
        }
        return awaitable;
      }
      function applyEach(eachfn) {
        return function applyEach2(fns, ...callArgs) {
          const go = awaitify(function(callback) {
            var that = this;
            return eachfn(fns, (fn, cb) => {
              wrapAsync(fn).apply(that, callArgs.concat(cb));
            }, callback);
          });
          return go;
        };
      }
      function _asyncMap(eachfn, arr, iteratee, callback) {
        arr = arr || [];
        var results = [];
        var counter = 0;
        var _iteratee = wrapAsync(iteratee);
        return eachfn(arr, (value, _2, iterCb) => {
          var index2 = counter++;
          _iteratee(value, (err, v) => {
            results[index2] = v;
            iterCb(err);
          });
        }, (err) => {
          callback(err, results);
        });
      }
      function isArrayLike(value) {
        return value && typeof value.length === "number" && value.length >= 0 && value.length % 1 === 0;
      }
      const breakLoop = {};
      function once(fn) {
        function wrapper(...args) {
          if (fn === null)
            return;
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        }
        Object.assign(wrapper, fn);
        return wrapper;
      }
      function getIterator(coll) {
        return coll[Symbol.iterator] && coll[Symbol.iterator]();
      }
      function createArrayIterator(coll) {
        var i = -1;
        var len = coll.length;
        return function next() {
          return ++i < len ? { value: coll[i], key: i } : null;
        };
      }
      function createES2015Iterator(iterator) {
        var i = -1;
        return function next() {
          var item = iterator.next();
          if (item.done)
            return null;
          i++;
          return { value: item.value, key: i };
        };
      }
      function createObjectIterator(obj) {
        var okeys = obj ? Object.keys(obj) : [];
        var i = -1;
        var len = okeys.length;
        return function next() {
          var key = okeys[++i];
          if (key === "__proto__") {
            return next();
          }
          return i < len ? { value: obj[key], key } : null;
        };
      }
      function createIterator(coll) {
        if (isArrayLike(coll)) {
          return createArrayIterator(coll);
        }
        var iterator = getIterator(coll);
        return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
      }
      function onlyOnce(fn) {
        return function(...args) {
          if (fn === null)
            throw new Error("Callback was already called.");
          var callFn = fn;
          fn = null;
          callFn.apply(this, args);
        };
      }
      function asyncEachOfLimit(generator, limit, iteratee, callback) {
        let done = false;
        let canceled = false;
        let awaiting = false;
        let running = 0;
        let idx = 0;
        function replenish() {
          if (running >= limit || awaiting || done)
            return;
          awaiting = true;
          generator.next().then(({ value, done: iterDone }) => {
            if (canceled || done)
              return;
            awaiting = false;
            if (iterDone) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running++;
            iteratee(value, idx, iterateeCallback);
            idx++;
            replenish();
          }).catch(handleError);
        }
        function iterateeCallback(err, result) {
          running -= 1;
          if (canceled)
            return;
          if (err)
            return handleError(err);
          if (err === false) {
            done = true;
            canceled = true;
            return;
          }
          if (result === breakLoop || done && running <= 0) {
            done = true;
            return callback(null);
          }
          replenish();
        }
        function handleError(err) {
          if (canceled)
            return;
          awaiting = false;
          done = true;
          callback(err);
        }
        replenish();
      }
      var eachOfLimit = (limit) => {
        return (obj, iteratee, callback) => {
          callback = once(callback);
          if (limit <= 0) {
            throw new RangeError("concurrency limit cannot be less than 1");
          }
          if (!obj) {
            return callback(null);
          }
          if (isAsyncGenerator(obj)) {
            return asyncEachOfLimit(obj, limit, iteratee, callback);
          }
          if (isAsyncIterable(obj)) {
            return asyncEachOfLimit(obj[Symbol.asyncIterator](), limit, iteratee, callback);
          }
          var nextElem = createIterator(obj);
          var done = false;
          var canceled = false;
          var running = 0;
          var looping = false;
          function iterateeCallback(err, value) {
            if (canceled)
              return;
            running -= 1;
            if (err) {
              done = true;
              callback(err);
            } else if (err === false) {
              done = true;
              canceled = true;
            } else if (value === breakLoop || done && running <= 0) {
              done = true;
              return callback(null);
            } else if (!looping) {
              replenish();
            }
          }
          function replenish() {
            looping = true;
            while (running < limit && !done) {
              var elem = nextElem();
              if (elem === null) {
                done = true;
                if (running <= 0) {
                  callback(null);
                }
                return;
              }
              running += 1;
              iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
            }
            looping = false;
          }
          replenish();
        };
      };
      function eachOfLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
      }
      var eachOfLimit$2 = awaitify(eachOfLimit$1, 4);
      function eachOfArrayLike(coll, iteratee, callback) {
        callback = once(callback);
        var index2 = 0, completed = 0, { length } = coll, canceled = false;
        if (length === 0) {
          callback(null);
        }
        function iteratorCallback(err, value) {
          if (err === false) {
            canceled = true;
          }
          if (canceled === true)
            return;
          if (err) {
            callback(err);
          } else if (++completed === length || value === breakLoop) {
            callback(null);
          }
        }
        for (; index2 < length; index2++) {
          iteratee(coll[index2], index2, onlyOnce(iteratorCallback));
        }
      }
      function eachOfGeneric(coll, iteratee, callback) {
        return eachOfLimit$2(coll, Infinity, iteratee, callback);
      }
      function eachOf(coll, iteratee, callback) {
        var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
        return eachOfImplementation(coll, wrapAsync(iteratee), callback);
      }
      var eachOf$1 = awaitify(eachOf, 3);
      function map(coll, iteratee, callback) {
        return _asyncMap(eachOf$1, coll, iteratee, callback);
      }
      var map$1 = awaitify(map, 3);
      var applyEach$1 = applyEach(map$1);
      function eachOfSeries(coll, iteratee, callback) {
        return eachOfLimit$2(coll, 1, iteratee, callback);
      }
      var eachOfSeries$1 = awaitify(eachOfSeries, 3);
      function mapSeries(coll, iteratee, callback) {
        return _asyncMap(eachOfSeries$1, coll, iteratee, callback);
      }
      var mapSeries$1 = awaitify(mapSeries, 3);
      var applyEachSeries = applyEach(mapSeries$1);
      const PROMISE_SYMBOL = Symbol("promiseCallback");
      function promiseCallback() {
        let resolve2, reject3;
        function callback(err, ...args) {
          if (err)
            return reject3(err);
          resolve2(args.length > 1 ? args : args[0]);
        }
        callback[PROMISE_SYMBOL] = new Promise((res, rej) => {
          resolve2 = res, reject3 = rej;
        });
        return callback;
      }
      function auto(tasks, concurrency, callback) {
        if (typeof concurrency !== "number") {
          callback = concurrency;
          concurrency = null;
        }
        callback = once(callback || promiseCallback());
        var numTasks = Object.keys(tasks).length;
        if (!numTasks) {
          return callback(null);
        }
        if (!concurrency) {
          concurrency = numTasks;
        }
        var results = {};
        var runningTasks = 0;
        var canceled = false;
        var hasError = false;
        var listeners = Object.create(null);
        var readyTasks = [];
        var readyToCheck = [];
        var uncheckedDependencies = {};
        Object.keys(tasks).forEach((key) => {
          var task = tasks[key];
          if (!Array.isArray(task)) {
            enqueueTask(key, [task]);
            readyToCheck.push(key);
            return;
          }
          var dependencies = task.slice(0, task.length - 1);
          var remainingDependencies = dependencies.length;
          if (remainingDependencies === 0) {
            enqueueTask(key, task);
            readyToCheck.push(key);
            return;
          }
          uncheckedDependencies[key] = remainingDependencies;
          dependencies.forEach((dependencyName) => {
            if (!tasks[dependencyName]) {
              throw new Error("async.auto task `" + key + "` has a non-existent dependency `" + dependencyName + "` in " + dependencies.join(", "));
            }
            addListener(dependencyName, () => {
              remainingDependencies--;
              if (remainingDependencies === 0) {
                enqueueTask(key, task);
              }
            });
          });
        });
        checkForDeadlocks();
        processQueue();
        function enqueueTask(key, task) {
          readyTasks.push(() => runTask(key, task));
        }
        function processQueue() {
          if (canceled)
            return;
          if (readyTasks.length === 0 && runningTasks === 0) {
            return callback(null, results);
          }
          while (readyTasks.length && runningTasks < concurrency) {
            var run = readyTasks.shift();
            run();
          }
        }
        function addListener(taskName, fn) {
          var taskListeners = listeners[taskName];
          if (!taskListeners) {
            taskListeners = listeners[taskName] = [];
          }
          taskListeners.push(fn);
        }
        function taskComplete(taskName) {
          var taskListeners = listeners[taskName] || [];
          taskListeners.forEach((fn) => fn());
          processQueue();
        }
        function runTask(key, task) {
          if (hasError)
            return;
          var taskCallback = onlyOnce((err, ...result) => {
            runningTasks--;
            if (err === false) {
              canceled = true;
              return;
            }
            if (result.length < 2) {
              [result] = result;
            }
            if (err) {
              var safeResults = {};
              Object.keys(results).forEach((rkey) => {
                safeResults[rkey] = results[rkey];
              });
              safeResults[key] = result;
              hasError = true;
              listeners = Object.create(null);
              if (canceled)
                return;
              callback(err, safeResults);
            } else {
              results[key] = result;
              taskComplete(key);
            }
          });
          runningTasks++;
          var taskFn = wrapAsync(task[task.length - 1]);
          if (task.length > 1) {
            taskFn(results, taskCallback);
          } else {
            taskFn(taskCallback);
          }
        }
        function checkForDeadlocks() {
          var currentTask;
          var counter = 0;
          while (readyToCheck.length) {
            currentTask = readyToCheck.pop();
            counter++;
            getDependents(currentTask).forEach((dependent) => {
              if (--uncheckedDependencies[dependent] === 0) {
                readyToCheck.push(dependent);
              }
            });
          }
          if (counter !== numTasks) {
            throw new Error("async.auto cannot execute tasks due to a recursive dependency");
          }
        }
        function getDependents(taskName) {
          var result = [];
          Object.keys(tasks).forEach((key) => {
            const task = tasks[key];
            if (Array.isArray(task) && task.indexOf(taskName) >= 0) {
              result.push(key);
            }
          });
          return result;
        }
        return callback[PROMISE_SYMBOL];
      }
      var FN_ARGS = /^(?:async\s+)?(?:function)?\s*\w*\s*\(\s*([^)]+)\s*\)(?:\s*{)/;
      var ARROW_FN_ARGS = /^(?:async\s+)?\(?\s*([^)=]+)\s*\)?(?:\s*=>)/;
      var FN_ARG_SPLIT = /,/;
      var FN_ARG = /(=.+)?(\s*)$/;
      var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      function parseParams(func) {
        const src = func.toString().replace(STRIP_COMMENTS, "");
        let match = src.match(FN_ARGS);
        if (!match) {
          match = src.match(ARROW_FN_ARGS);
        }
        if (!match)
          throw new Error("could not parse args in autoInject\nSource:\n" + src);
        let [, args] = match;
        return args.replace(/\s/g, "").split(FN_ARG_SPLIT).map((arg) => arg.replace(FN_ARG, "").trim());
      }
      function autoInject(tasks, callback) {
        var newTasks = {};
        Object.keys(tasks).forEach((key) => {
          var taskFn = tasks[key];
          var params;
          var fnIsAsync = isAsync(taskFn);
          var hasNoDeps = !fnIsAsync && taskFn.length === 1 || fnIsAsync && taskFn.length === 0;
          if (Array.isArray(taskFn)) {
            params = [...taskFn];
            taskFn = params.pop();
            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
          } else if (hasNoDeps) {
            newTasks[key] = taskFn;
          } else {
            params = parseParams(taskFn);
            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
              throw new Error("autoInject task functions require explicit parameters.");
            }
            if (!fnIsAsync)
              params.pop();
            newTasks[key] = params.concat(newTask);
          }
          function newTask(results, taskCb) {
            var newArgs = params.map((name) => results[name]);
            newArgs.push(taskCb);
            wrapAsync(taskFn)(...newArgs);
          }
        });
        return auto(newTasks, callback);
      }
      class DLL {
        constructor() {
          this.head = this.tail = null;
          this.length = 0;
        }
        removeLink(node) {
          if (node.prev)
            node.prev.next = node.next;
          else
            this.head = node.next;
          if (node.next)
            node.next.prev = node.prev;
          else
            this.tail = node.prev;
          node.prev = node.next = null;
          this.length -= 1;
          return node;
        }
        empty() {
          while (this.head)
            this.shift();
          return this;
        }
        insertAfter(node, newNode) {
          newNode.prev = node;
          newNode.next = node.next;
          if (node.next)
            node.next.prev = newNode;
          else
            this.tail = newNode;
          node.next = newNode;
          this.length += 1;
        }
        insertBefore(node, newNode) {
          newNode.prev = node.prev;
          newNode.next = node;
          if (node.prev)
            node.prev.next = newNode;
          else
            this.head = newNode;
          node.prev = newNode;
          this.length += 1;
        }
        unshift(node) {
          if (this.head)
            this.insertBefore(this.head, node);
          else
            setInitial(this, node);
        }
        push(node) {
          if (this.tail)
            this.insertAfter(this.tail, node);
          else
            setInitial(this, node);
        }
        shift() {
          return this.head && this.removeLink(this.head);
        }
        pop() {
          return this.tail && this.removeLink(this.tail);
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          var cur = this.head;
          while (cur) {
            yield cur.data;
            cur = cur.next;
          }
        }
        remove(testFn) {
          var curr = this.head;
          while (curr) {
            var { next } = curr;
            if (testFn(curr)) {
              this.removeLink(curr);
            }
            curr = next;
          }
          return this;
        }
      }
      function setInitial(dll, node) {
        dll.length = 1;
        dll.head = dll.tail = node;
      }
      function queue(worker, concurrency, payload) {
        if (concurrency == null) {
          concurrency = 1;
        } else if (concurrency === 0) {
          throw new RangeError("Concurrency must not be zero");
        }
        var _worker = wrapAsync(worker);
        var numRunning = 0;
        var workersList = [];
        const events = {
          error: [],
          drain: [],
          saturated: [],
          unsaturated: [],
          empty: []
        };
        function on(event, handler) {
          events[event].push(handler);
        }
        function once2(event, handler) {
          const handleAndRemove = (...args) => {
            off(event, handleAndRemove);
            handler(...args);
          };
          events[event].push(handleAndRemove);
        }
        function off(event, handler) {
          if (!event)
            return Object.keys(events).forEach((ev) => events[ev] = []);
          if (!handler)
            return events[event] = [];
          events[event] = events[event].filter((ev) => ev !== handler);
        }
        function trigger(event, ...args) {
          events[event].forEach((handler) => handler(...args));
        }
        var processingScheduled = false;
        function _insert(data, insertAtFront, rejectOnError, callback) {
          if (callback != null && typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          var res, rej;
          function promiseCallback2(err, ...args) {
            if (err)
              return rejectOnError ? rej(err) : res();
            if (args.length <= 1)
              return res(args[0]);
            res(args);
          }
          var item = {
            data,
            callback: rejectOnError ? promiseCallback2 : callback || promiseCallback2
          };
          if (insertAtFront) {
            q._tasks.unshift(item);
          } else {
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
          if (rejectOnError || !callback) {
            return new Promise((resolve2, reject3) => {
              res = resolve2;
              rej = reject3;
            });
          }
        }
        function _createCB(tasks) {
          return function(err, ...args) {
            numRunning -= 1;
            for (var i = 0, l = tasks.length; i < l; i++) {
              var task = tasks[i];
              var index2 = workersList.indexOf(task);
              if (index2 === 0) {
                workersList.shift();
              } else if (index2 > 0) {
                workersList.splice(index2, 1);
              }
              task.callback(err, ...args);
              if (err != null) {
                trigger("error", err, task.data);
              }
            }
            if (numRunning <= q.concurrency - q.buffer) {
              trigger("unsaturated");
            }
            if (q.idle()) {
              trigger("drain");
            }
            q.process();
          };
        }
        function _maybeDrain(data) {
          if (data.length === 0 && q.idle()) {
            setImmediate$1(() => trigger("drain"));
            return true;
          }
          return false;
        }
        const eventMethod = (name) => (handler) => {
          if (!handler) {
            return new Promise((resolve2, reject3) => {
              once2(name, (err, data) => {
                if (err)
                  return reject3(err);
                resolve2(data);
              });
            });
          }
          off(name);
          on(name, handler);
        };
        var isProcessing = false;
        var q = {
          _tasks: new DLL(),
          *[Symbol.iterator]() {
            yield* q._tasks[Symbol.iterator]();
          },
          concurrency,
          payload,
          buffer: concurrency / 4,
          started: false,
          paused: false,
          push(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, false, callback));
            }
            return _insert(data, false, false, callback);
          },
          pushAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, false, true, callback));
            }
            return _insert(data, false, true, callback);
          },
          kill() {
            off();
            q._tasks.empty();
          },
          unshift(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, false, callback));
            }
            return _insert(data, true, false, callback);
          },
          unshiftAsync(data, callback) {
            if (Array.isArray(data)) {
              if (_maybeDrain(data))
                return;
              return data.map((datum) => _insert(datum, true, true, callback));
            }
            return _insert(data, true, true, callback);
          },
          remove(testFn) {
            q._tasks.remove(testFn);
          },
          process() {
            if (isProcessing) {
              return;
            }
            isProcessing = true;
            while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
              var tasks = [], data = [];
              var l = q._tasks.length;
              if (q.payload)
                l = Math.min(l, q.payload);
              for (var i = 0; i < l; i++) {
                var node = q._tasks.shift();
                tasks.push(node);
                workersList.push(node);
                data.push(node.data);
              }
              numRunning += 1;
              if (q._tasks.length === 0) {
                trigger("empty");
              }
              if (numRunning === q.concurrency) {
                trigger("saturated");
              }
              var cb = onlyOnce(_createCB(tasks));
              _worker(data, cb);
            }
            isProcessing = false;
          },
          length() {
            return q._tasks.length;
          },
          running() {
            return numRunning;
          },
          workersList() {
            return workersList;
          },
          idle() {
            return q._tasks.length + numRunning === 0;
          },
          pause() {
            q.paused = true;
          },
          resume() {
            if (q.paused === false) {
              return;
            }
            q.paused = false;
            setImmediate$1(q.process);
          }
        };
        Object.defineProperties(q, {
          saturated: {
            writable: false,
            value: eventMethod("saturated")
          },
          unsaturated: {
            writable: false,
            value: eventMethod("unsaturated")
          },
          empty: {
            writable: false,
            value: eventMethod("empty")
          },
          drain: {
            writable: false,
            value: eventMethod("drain")
          },
          error: {
            writable: false,
            value: eventMethod("error")
          }
        });
        return q;
      }
      function cargo(worker, payload) {
        return queue(worker, 1, payload);
      }
      function cargo$1(worker, concurrency, payload) {
        return queue(worker, concurrency, payload);
      }
      function reduce(coll, memo, iteratee, callback) {
        callback = once(callback);
        var _iteratee = wrapAsync(iteratee);
        return eachOfSeries$1(coll, (x, i, iterCb) => {
          _iteratee(memo, x, (err, v) => {
            memo = v;
            iterCb(err);
          });
        }, (err) => callback(err, memo));
      }
      var reduce$1 = awaitify(reduce, 4);
      function seq(...functions) {
        var _functions = functions.map(wrapAsync);
        return function(...args) {
          var that = this;
          var cb = args[args.length - 1];
          if (typeof cb == "function") {
            args.pop();
          } else {
            cb = promiseCallback();
          }
          reduce$1(_functions, args, (newargs, fn, iterCb) => {
            fn.apply(that, newargs.concat((err, ...nextargs) => {
              iterCb(err, nextargs);
            }));
          }, (err, results) => cb(err, ...results));
          return cb[PROMISE_SYMBOL];
        };
      }
      function compose(...args) {
        return seq(...args.reverse());
      }
      function mapLimit(coll, limit, iteratee, callback) {
        return _asyncMap(eachOfLimit(limit), coll, iteratee, callback);
      }
      var mapLimit$1 = awaitify(mapLimit, 4);
      function concatLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, ...args) => {
            if (err)
              return iterCb(err);
            return iterCb(err, args);
          });
        }, (err, mapResults) => {
          var result = [];
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              result = result.concat(...mapResults[i]);
            }
          }
          return callback(err, result);
        });
      }
      var concatLimit$1 = awaitify(concatLimit, 4);
      function concat(coll, iteratee, callback) {
        return concatLimit$1(coll, Infinity, iteratee, callback);
      }
      var concat$1 = awaitify(concat, 3);
      function concatSeries(coll, iteratee, callback) {
        return concatLimit$1(coll, 1, iteratee, callback);
      }
      var concatSeries$1 = awaitify(concatSeries, 3);
      function constant(...args) {
        return function(...ignoredArgs) {
          var callback = ignoredArgs.pop();
          return callback(null, ...args);
        };
      }
      function _createTester(check, getResult) {
        return (eachfn, arr, _iteratee, cb) => {
          var testPassed = false;
          var testResult;
          const iteratee = wrapAsync(_iteratee);
          eachfn(arr, (value, _2, callback) => {
            iteratee(value, (err, result) => {
              if (err || err === false)
                return callback(err);
              if (check(result) && !testResult) {
                testPassed = true;
                testResult = getResult(true, value);
                return callback(null, breakLoop);
              }
              callback();
            });
          }, (err) => {
            if (err)
              return cb(err);
            cb(null, testPassed ? testResult : getResult(false));
          });
        };
      }
      function detect(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOf$1, coll, iteratee, callback);
      }
      var detect$1 = awaitify(detect, 3);
      function detectLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var detectLimit$1 = awaitify(detectLimit, 4);
      function detectSeries(coll, iteratee, callback) {
        return _createTester((bool) => bool, (res, item) => item)(eachOfLimit(1), coll, iteratee, callback);
      }
      var detectSeries$1 = awaitify(detectSeries, 3);
      function consoleFunc(name) {
        return (fn, ...args) => wrapAsync(fn)(...args, (err, ...resultArgs) => {
          if (typeof console === "object") {
            if (err) {
              if (console.error) {
                console.error(err);
              }
            } else if (console[name]) {
              resultArgs.forEach((x) => console[name](x));
            }
          }
        });
      }
      var dir = consoleFunc("dir");
      function doWhilst(iteratee, test, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results;
        function next(err, ...args) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          results = args;
          _test(...args, check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return check(null, true);
      }
      var doWhilst$1 = awaitify(doWhilst, 3);
      function doUntil(iteratee, test, callback) {
        const _test = wrapAsync(test);
        return doWhilst$1(iteratee, (...args) => {
          const cb = args.pop();
          _test(...args, (err, truth) => cb(err, !truth));
        }, callback);
      }
      function _withoutIndex(iteratee) {
        return (value, index2, callback) => iteratee(value, callback);
      }
      function eachLimit(coll, iteratee, callback) {
        return eachOf$1(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var each = awaitify(eachLimit, 3);
      function eachLimit$1(coll, limit, iteratee, callback) {
        return eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
      }
      var eachLimit$2 = awaitify(eachLimit$1, 4);
      function eachSeries(coll, iteratee, callback) {
        return eachLimit$2(coll, 1, iteratee, callback);
      }
      var eachSeries$1 = awaitify(eachSeries, 3);
      function ensureAsync(fn) {
        if (isAsync(fn))
          return fn;
        return function(...args) {
          var callback = args.pop();
          var sync = true;
          args.push((...innerArgs) => {
            if (sync) {
              setImmediate$1(() => callback(...innerArgs));
            } else {
              callback(...innerArgs);
            }
          });
          fn.apply(this, args);
          sync = false;
        };
      }
      function every(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOf$1, coll, iteratee, callback);
      }
      var every$1 = awaitify(every, 3);
      function everyLimit(coll, limit, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var everyLimit$1 = awaitify(everyLimit, 4);
      function everySeries(coll, iteratee, callback) {
        return _createTester((bool) => !bool, (res) => !res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var everySeries$1 = awaitify(everySeries, 3);
      function filterArray(eachfn, arr, iteratee, callback) {
        var truthValues = new Array(arr.length);
        eachfn(arr, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            truthValues[index2] = !!v;
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          var results = [];
          for (var i = 0; i < arr.length; i++) {
            if (truthValues[i])
              results.push(arr[i]);
          }
          callback(null, results);
        });
      }
      function filterGeneric(eachfn, coll, iteratee, callback) {
        var results = [];
        eachfn(coll, (x, index2, iterCb) => {
          iteratee(x, (err, v) => {
            if (err)
              return iterCb(err);
            if (v) {
              results.push({ index: index2, value: x });
            }
            iterCb(err);
          });
        }, (err) => {
          if (err)
            return callback(err);
          callback(null, results.sort((a, b) => a.index - b.index).map((v) => v.value));
        });
      }
      function _filter(eachfn, coll, iteratee, callback) {
        var filter2 = isArrayLike(coll) ? filterArray : filterGeneric;
        return filter2(eachfn, coll, wrapAsync(iteratee), callback);
      }
      function filter(coll, iteratee, callback) {
        return _filter(eachOf$1, coll, iteratee, callback);
      }
      var filter$1 = awaitify(filter, 3);
      function filterLimit(coll, limit, iteratee, callback) {
        return _filter(eachOfLimit(limit), coll, iteratee, callback);
      }
      var filterLimit$1 = awaitify(filterLimit, 4);
      function filterSeries(coll, iteratee, callback) {
        return _filter(eachOfSeries$1, coll, iteratee, callback);
      }
      var filterSeries$1 = awaitify(filterSeries, 3);
      function forever(fn, errback) {
        var done = onlyOnce(errback);
        var task = wrapAsync(ensureAsync(fn));
        function next(err) {
          if (err)
            return done(err);
          if (err === false)
            return;
          task(next);
        }
        return next();
      }
      var forever$1 = awaitify(forever, 2);
      function groupByLimit(coll, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(coll, limit, (val, iterCb) => {
          _iteratee(val, (err, key) => {
            if (err)
              return iterCb(err);
            return iterCb(err, { key, val });
          });
        }, (err, mapResults) => {
          var result = {};
          var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
          for (var i = 0; i < mapResults.length; i++) {
            if (mapResults[i]) {
              var { key } = mapResults[i];
              var { val } = mapResults[i];
              if (hasOwnProperty2.call(result, key)) {
                result[key].push(val);
              } else {
                result[key] = [val];
              }
            }
          }
          return callback(err, result);
        });
      }
      var groupByLimit$1 = awaitify(groupByLimit, 4);
      function groupBy(coll, iteratee, callback) {
        return groupByLimit$1(coll, Infinity, iteratee, callback);
      }
      function groupBySeries(coll, iteratee, callback) {
        return groupByLimit$1(coll, 1, iteratee, callback);
      }
      var log = consoleFunc("log");
      function mapValuesLimit(obj, limit, iteratee, callback) {
        callback = once(callback);
        var newObj = {};
        var _iteratee = wrapAsync(iteratee);
        return eachOfLimit(limit)(obj, (val, key, next) => {
          _iteratee(val, key, (err, result) => {
            if (err)
              return next(err);
            newObj[key] = result;
            next(err);
          });
        }, (err) => callback(err, newObj));
      }
      var mapValuesLimit$1 = awaitify(mapValuesLimit, 4);
      function mapValues(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, Infinity, iteratee, callback);
      }
      function mapValuesSeries(obj, iteratee, callback) {
        return mapValuesLimit$1(obj, 1, iteratee, callback);
      }
      function memoize(fn, hasher = (v) => v) {
        var memo = Object.create(null);
        var queues = Object.create(null);
        var _fn = wrapAsync(fn);
        var memoized = initialParams((args, callback) => {
          var key = hasher(...args);
          if (key in memo) {
            setImmediate$1(() => callback(null, ...memo[key]));
          } else if (key in queues) {
            queues[key].push(callback);
          } else {
            queues[key] = [callback];
            _fn(...args, (err, ...resultArgs) => {
              if (!err) {
                memo[key] = resultArgs;
              }
              var q = queues[key];
              delete queues[key];
              for (var i = 0, l = q.length; i < l; i++) {
                q[i](err, ...resultArgs);
              }
            });
          }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
      }
      var _defer$1;
      if (hasNextTick) {
        _defer$1 = process.nextTick;
      } else if (hasSetImmediate) {
        _defer$1 = setImmediate;
      } else {
        _defer$1 = fallback;
      }
      var nextTick = wrap(_defer$1);
      var _parallel = awaitify((eachfn, tasks, callback) => {
        var results = isArrayLike(tasks) ? [] : {};
        eachfn(tasks, (task, key, taskCb) => {
          wrapAsync(task)((err, ...result) => {
            if (result.length < 2) {
              [result] = result;
            }
            results[key] = result;
            taskCb(err);
          });
        }, (err) => callback(err, results));
      }, 3);
      function parallel(tasks, callback) {
        return _parallel(eachOf$1, tasks, callback);
      }
      function parallelLimit(tasks, limit, callback) {
        return _parallel(eachOfLimit(limit), tasks, callback);
      }
      function queue$1(worker, concurrency) {
        var _worker = wrapAsync(worker);
        return queue((items, cb) => {
          _worker(items[0], cb);
        }, concurrency, 1);
      }
      class Heap {
        constructor() {
          this.heap = [];
          this.pushCount = Number.MIN_SAFE_INTEGER;
        }
        get length() {
          return this.heap.length;
        }
        empty() {
          this.heap = [];
          return this;
        }
        percUp(index2) {
          let p;
          while (index2 > 0 && smaller(this.heap[index2], this.heap[p = parent(index2)])) {
            let t = this.heap[index2];
            this.heap[index2] = this.heap[p];
            this.heap[p] = t;
            index2 = p;
          }
        }
        percDown(index2) {
          let l;
          while ((l = leftChi(index2)) < this.heap.length) {
            if (l + 1 < this.heap.length && smaller(this.heap[l + 1], this.heap[l])) {
              l = l + 1;
            }
            if (smaller(this.heap[index2], this.heap[l])) {
              break;
            }
            let t = this.heap[index2];
            this.heap[index2] = this.heap[l];
            this.heap[l] = t;
            index2 = l;
          }
        }
        push(node) {
          node.pushCount = ++this.pushCount;
          this.heap.push(node);
          this.percUp(this.heap.length - 1);
        }
        unshift(node) {
          return this.heap.push(node);
        }
        shift() {
          let [top] = this.heap;
          this.heap[0] = this.heap[this.heap.length - 1];
          this.heap.pop();
          this.percDown(0);
          return top;
        }
        toArray() {
          return [...this];
        }
        *[Symbol.iterator]() {
          for (let i = 0; i < this.heap.length; i++) {
            yield this.heap[i].data;
          }
        }
        remove(testFn) {
          let j = 0;
          for (let i = 0; i < this.heap.length; i++) {
            if (!testFn(this.heap[i])) {
              this.heap[j] = this.heap[i];
              j++;
            }
          }
          this.heap.splice(j);
          for (let i = parent(this.heap.length - 1); i >= 0; i--) {
            this.percDown(i);
          }
          return this;
        }
      }
      function leftChi(i) {
        return (i << 1) + 1;
      }
      function parent(i) {
        return (i + 1 >> 1) - 1;
      }
      function smaller(x, y) {
        if (x.priority !== y.priority) {
          return x.priority < y.priority;
        } else {
          return x.pushCount < y.pushCount;
        }
      }
      function priorityQueue(worker, concurrency) {
        var q = queue$1(worker, concurrency);
        var processingScheduled = false;
        q._tasks = new Heap();
        q.push = function(data, priority = 0, callback = () => {
        }) {
          if (typeof callback !== "function") {
            throw new Error("task callback must be a function");
          }
          q.started = true;
          if (!Array.isArray(data)) {
            data = [data];
          }
          if (data.length === 0 && q.idle()) {
            return setImmediate$1(() => q.drain());
          }
          for (var i = 0, l = data.length; i < l; i++) {
            var item = {
              data: data[i],
              priority,
              callback
            };
            q._tasks.push(item);
          }
          if (!processingScheduled) {
            processingScheduled = true;
            setImmediate$1(() => {
              processingScheduled = false;
              q.process();
            });
          }
        };
        delete q.unshift;
        return q;
      }
      function race(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new TypeError("First argument to race must be an array of functions"));
        if (!tasks.length)
          return callback();
        for (var i = 0, l = tasks.length; i < l; i++) {
          wrapAsync(tasks[i])(callback);
        }
      }
      var race$1 = awaitify(race, 2);
      function reduceRight(array, memo, iteratee, callback) {
        var reversed = [...array].reverse();
        return reduce$1(reversed, memo, iteratee, callback);
      }
      function reflect(fn) {
        var _fn = wrapAsync(fn);
        return initialParams(function reflectOn(args, reflectCallback) {
          args.push((error, ...cbArgs) => {
            let retVal = {};
            if (error) {
              retVal.error = error;
            }
            if (cbArgs.length > 0) {
              var value = cbArgs;
              if (cbArgs.length <= 1) {
                [value] = cbArgs;
              }
              retVal.value = value;
            }
            reflectCallback(null, retVal);
          });
          return _fn.apply(this, args);
        });
      }
      function reflectAll(tasks) {
        var results;
        if (Array.isArray(tasks)) {
          results = tasks.map(reflect);
        } else {
          results = {};
          Object.keys(tasks).forEach((key) => {
            results[key] = reflect.call(this, tasks[key]);
          });
        }
        return results;
      }
      function reject2(eachfn, arr, _iteratee, callback) {
        const iteratee = wrapAsync(_iteratee);
        return _filter(eachfn, arr, (value, cb) => {
          iteratee(value, (err, v) => {
            cb(err, !v);
          });
        }, callback);
      }
      function reject$1(coll, iteratee, callback) {
        return reject2(eachOf$1, coll, iteratee, callback);
      }
      var reject$2 = awaitify(reject$1, 3);
      function rejectLimit(coll, limit, iteratee, callback) {
        return reject2(eachOfLimit(limit), coll, iteratee, callback);
      }
      var rejectLimit$1 = awaitify(rejectLimit, 4);
      function rejectSeries(coll, iteratee, callback) {
        return reject2(eachOfSeries$1, coll, iteratee, callback);
      }
      var rejectSeries$1 = awaitify(rejectSeries, 3);
      function constant$1(value) {
        return function() {
          return value;
        };
      }
      const DEFAULT_TIMES = 5;
      const DEFAULT_INTERVAL = 0;
      function retry(opts, task, callback) {
        var options = {
          times: DEFAULT_TIMES,
          intervalFunc: constant$1(DEFAULT_INTERVAL)
        };
        if (arguments.length < 3 && typeof opts === "function") {
          callback = task || promiseCallback();
          task = opts;
        } else {
          parseTimes(options, opts);
          callback = callback || promiseCallback();
        }
        if (typeof task !== "function") {
          throw new Error("Invalid arguments for async.retry");
        }
        var _task = wrapAsync(task);
        var attempt = 1;
        function retryAttempt() {
          _task((err, ...args) => {
            if (err === false)
              return;
            if (err && attempt++ < options.times && (typeof options.errorFilter != "function" || options.errorFilter(err))) {
              setTimeout(retryAttempt, options.intervalFunc(attempt - 1));
            } else {
              callback(err, ...args);
            }
          });
        }
        retryAttempt();
        return callback[PROMISE_SYMBOL];
      }
      function parseTimes(acc, t) {
        if (typeof t === "object") {
          acc.times = +t.times || DEFAULT_TIMES;
          acc.intervalFunc = typeof t.interval === "function" ? t.interval : constant$1(+t.interval || DEFAULT_INTERVAL);
          acc.errorFilter = t.errorFilter;
        } else if (typeof t === "number" || typeof t === "string") {
          acc.times = +t || DEFAULT_TIMES;
        } else {
          throw new Error("Invalid arguments for async.retry");
        }
      }
      function retryable(opts, task) {
        if (!task) {
          task = opts;
          opts = null;
        }
        let arity = opts && opts.arity || task.length;
        if (isAsync(task)) {
          arity += 1;
        }
        var _task = wrapAsync(task);
        return initialParams((args, callback) => {
          if (args.length < arity - 1 || callback == null) {
            args.push(callback);
            callback = promiseCallback();
          }
          function taskFn(cb) {
            _task(...args, cb);
          }
          if (opts)
            retry(opts, taskFn, callback);
          else
            retry(taskFn, callback);
          return callback[PROMISE_SYMBOL];
        });
      }
      function series(tasks, callback) {
        return _parallel(eachOfSeries$1, tasks, callback);
      }
      function some(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOf$1, coll, iteratee, callback);
      }
      var some$1 = awaitify(some, 3);
      function someLimit(coll, limit, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfLimit(limit), coll, iteratee, callback);
      }
      var someLimit$1 = awaitify(someLimit, 4);
      function someSeries(coll, iteratee, callback) {
        return _createTester(Boolean, (res) => res)(eachOfSeries$1, coll, iteratee, callback);
      }
      var someSeries$1 = awaitify(someSeries, 3);
      function sortBy(coll, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return map$1(coll, (x, iterCb) => {
          _iteratee(x, (err, criteria) => {
            if (err)
              return iterCb(err);
            iterCb(err, { value: x, criteria });
          });
        }, (err, results) => {
          if (err)
            return callback(err);
          callback(null, results.sort(comparator).map((v) => v.value));
        });
        function comparator(left, right) {
          var a = left.criteria, b = right.criteria;
          return a < b ? -1 : a > b ? 1 : 0;
        }
      }
      var sortBy$1 = awaitify(sortBy, 3);
      function timeout(asyncFn, milliseconds, info) {
        var fn = wrapAsync(asyncFn);
        return initialParams((args, callback) => {
          var timedOut = false;
          var timer;
          function timeoutCallback() {
            var name = asyncFn.name || "anonymous";
            var error = new Error('Callback function "' + name + '" timed out.');
            error.code = "ETIMEDOUT";
            if (info) {
              error.info = info;
            }
            timedOut = true;
            callback(error);
          }
          args.push((...cbArgs) => {
            if (!timedOut) {
              callback(...cbArgs);
              clearTimeout(timer);
            }
          });
          timer = setTimeout(timeoutCallback, milliseconds);
          fn(...args);
        });
      }
      function range(size) {
        var result = Array(size);
        while (size--) {
          result[size] = size;
        }
        return result;
      }
      function timesLimit(count, limit, iteratee, callback) {
        var _iteratee = wrapAsync(iteratee);
        return mapLimit$1(range(count), limit, _iteratee, callback);
      }
      function times(n, iteratee, callback) {
        return timesLimit(n, Infinity, iteratee, callback);
      }
      function timesSeries(n, iteratee, callback) {
        return timesLimit(n, 1, iteratee, callback);
      }
      function transform(coll, accumulator, iteratee, callback) {
        if (arguments.length <= 3 && typeof accumulator === "function") {
          callback = iteratee;
          iteratee = accumulator;
          accumulator = Array.isArray(coll) ? [] : {};
        }
        callback = once(callback || promiseCallback());
        var _iteratee = wrapAsync(iteratee);
        eachOf$1(coll, (v, k, cb) => {
          _iteratee(accumulator, v, k, cb);
        }, (err) => callback(err, accumulator));
        return callback[PROMISE_SYMBOL];
      }
      function tryEach(tasks, callback) {
        var error = null;
        var result;
        return eachSeries$1(tasks, (task, taskCb) => {
          wrapAsync(task)((err, ...args) => {
            if (err === false)
              return taskCb(err);
            if (args.length < 2) {
              [result] = args;
            } else {
              result = args;
            }
            error = err;
            taskCb(err ? null : {});
          });
        }, () => callback(error, result));
      }
      var tryEach$1 = awaitify(tryEach);
      function unmemoize(fn) {
        return (...args) => {
          return (fn.unmemoized || fn)(...args);
        };
      }
      function whilst(test, iteratee, callback) {
        callback = onlyOnce(callback);
        var _fn = wrapAsync(iteratee);
        var _test = wrapAsync(test);
        var results = [];
        function next(err, ...rest) {
          if (err)
            return callback(err);
          results = rest;
          if (err === false)
            return;
          _test(check);
        }
        function check(err, truth) {
          if (err)
            return callback(err);
          if (err === false)
            return;
          if (!truth)
            return callback(null, ...results);
          _fn(next);
        }
        return _test(check);
      }
      var whilst$1 = awaitify(whilst, 3);
      function until(test, iteratee, callback) {
        const _test = wrapAsync(test);
        return whilst$1((cb) => _test((err, truth) => cb(err, !truth)), iteratee, callback);
      }
      function waterfall(tasks, callback) {
        callback = once(callback);
        if (!Array.isArray(tasks))
          return callback(new Error("First argument to waterfall must be an array of functions"));
        if (!tasks.length)
          return callback();
        var taskIndex = 0;
        function nextTask(args) {
          var task = wrapAsync(tasks[taskIndex++]);
          task(...args, onlyOnce(next));
        }
        function next(err, ...args) {
          if (err === false)
            return;
          if (err || taskIndex === tasks.length) {
            return callback(err, ...args);
          }
          nextTask(args);
        }
        nextTask([]);
      }
      var waterfall$1 = awaitify(waterfall);
      var index = {
        apply,
        applyEach: applyEach$1,
        applyEachSeries,
        asyncify,
        auto,
        autoInject,
        cargo,
        cargoQueue: cargo$1,
        compose,
        concat: concat$1,
        concatLimit: concatLimit$1,
        concatSeries: concatSeries$1,
        constant,
        detect: detect$1,
        detectLimit: detectLimit$1,
        detectSeries: detectSeries$1,
        dir,
        doUntil,
        doWhilst: doWhilst$1,
        each,
        eachLimit: eachLimit$2,
        eachOf: eachOf$1,
        eachOfLimit: eachOfLimit$2,
        eachOfSeries: eachOfSeries$1,
        eachSeries: eachSeries$1,
        ensureAsync,
        every: every$1,
        everyLimit: everyLimit$1,
        everySeries: everySeries$1,
        filter: filter$1,
        filterLimit: filterLimit$1,
        filterSeries: filterSeries$1,
        forever: forever$1,
        groupBy,
        groupByLimit: groupByLimit$1,
        groupBySeries,
        log,
        map: map$1,
        mapLimit: mapLimit$1,
        mapSeries: mapSeries$1,
        mapValues,
        mapValuesLimit: mapValuesLimit$1,
        mapValuesSeries,
        memoize,
        nextTick,
        parallel,
        parallelLimit,
        priorityQueue,
        queue: queue$1,
        race: race$1,
        reduce: reduce$1,
        reduceRight,
        reflect,
        reflectAll,
        reject: reject$2,
        rejectLimit: rejectLimit$1,
        rejectSeries: rejectSeries$1,
        retry,
        retryable,
        seq,
        series,
        setImmediate: setImmediate$1,
        some: some$1,
        someLimit: someLimit$1,
        someSeries: someSeries$1,
        sortBy: sortBy$1,
        timeout,
        times,
        timesLimit,
        timesSeries,
        transform,
        tryEach: tryEach$1,
        unmemoize,
        until,
        waterfall: waterfall$1,
        whilst: whilst$1,
        all: every$1,
        allLimit: everyLimit$1,
        allSeries: everySeries$1,
        any: some$1,
        anyLimit: someLimit$1,
        anySeries: someSeries$1,
        find: detect$1,
        findLimit: detectLimit$1,
        findSeries: detectSeries$1,
        flatMap: concat$1,
        flatMapLimit: concatLimit$1,
        flatMapSeries: concatSeries$1,
        forEach: each,
        forEachSeries: eachSeries$1,
        forEachLimit: eachLimit$2,
        forEachOf: eachOf$1,
        forEachOfSeries: eachOfSeries$1,
        forEachOfLimit: eachOfLimit$2,
        inject: reduce$1,
        foldl: reduce$1,
        foldr: reduceRight,
        select: filter$1,
        selectLimit: filterLimit$1,
        selectSeries: filterSeries$1,
        wrapSync: asyncify,
        during: whilst$1,
        doDuring: doWhilst$1
      };
      exports3.default = index;
      exports3.apply = apply;
      exports3.applyEach = applyEach$1;
      exports3.applyEachSeries = applyEachSeries;
      exports3.asyncify = asyncify;
      exports3.auto = auto;
      exports3.autoInject = autoInject;
      exports3.cargo = cargo;
      exports3.cargoQueue = cargo$1;
      exports3.compose = compose;
      exports3.concat = concat$1;
      exports3.concatLimit = concatLimit$1;
      exports3.concatSeries = concatSeries$1;
      exports3.constant = constant;
      exports3.detect = detect$1;
      exports3.detectLimit = detectLimit$1;
      exports3.detectSeries = detectSeries$1;
      exports3.dir = dir;
      exports3.doUntil = doUntil;
      exports3.doWhilst = doWhilst$1;
      exports3.each = each;
      exports3.eachLimit = eachLimit$2;
      exports3.eachOf = eachOf$1;
      exports3.eachOfLimit = eachOfLimit$2;
      exports3.eachOfSeries = eachOfSeries$1;
      exports3.eachSeries = eachSeries$1;
      exports3.ensureAsync = ensureAsync;
      exports3.every = every$1;
      exports3.everyLimit = everyLimit$1;
      exports3.everySeries = everySeries$1;
      exports3.filter = filter$1;
      exports3.filterLimit = filterLimit$1;
      exports3.filterSeries = filterSeries$1;
      exports3.forever = forever$1;
      exports3.groupBy = groupBy;
      exports3.groupByLimit = groupByLimit$1;
      exports3.groupBySeries = groupBySeries;
      exports3.log = log;
      exports3.map = map$1;
      exports3.mapLimit = mapLimit$1;
      exports3.mapSeries = mapSeries$1;
      exports3.mapValues = mapValues;
      exports3.mapValuesLimit = mapValuesLimit$1;
      exports3.mapValuesSeries = mapValuesSeries;
      exports3.memoize = memoize;
      exports3.nextTick = nextTick;
      exports3.parallel = parallel;
      exports3.parallelLimit = parallelLimit;
      exports3.priorityQueue = priorityQueue;
      exports3.queue = queue$1;
      exports3.race = race$1;
      exports3.reduce = reduce$1;
      exports3.reduceRight = reduceRight;
      exports3.reflect = reflect;
      exports3.reflectAll = reflectAll;
      exports3.reject = reject$2;
      exports3.rejectLimit = rejectLimit$1;
      exports3.rejectSeries = rejectSeries$1;
      exports3.retry = retry;
      exports3.retryable = retryable;
      exports3.seq = seq;
      exports3.series = series;
      exports3.setImmediate = setImmediate$1;
      exports3.some = some$1;
      exports3.someLimit = someLimit$1;
      exports3.someSeries = someSeries$1;
      exports3.sortBy = sortBy$1;
      exports3.timeout = timeout;
      exports3.times = times;
      exports3.timesLimit = timesLimit;
      exports3.timesSeries = timesSeries;
      exports3.transform = transform;
      exports3.tryEach = tryEach$1;
      exports3.unmemoize = unmemoize;
      exports3.until = until;
      exports3.waterfall = waterfall$1;
      exports3.whilst = whilst$1;
      exports3.all = every$1;
      exports3.allLimit = everyLimit$1;
      exports3.allSeries = everySeries$1;
      exports3.any = some$1;
      exports3.anyLimit = someLimit$1;
      exports3.anySeries = someSeries$1;
      exports3.find = detect$1;
      exports3.findLimit = detectLimit$1;
      exports3.findSeries = detectSeries$1;
      exports3.flatMap = concat$1;
      exports3.flatMapLimit = concatLimit$1;
      exports3.flatMapSeries = concatSeries$1;
      exports3.forEach = each;
      exports3.forEachSeries = eachSeries$1;
      exports3.forEachLimit = eachLimit$2;
      exports3.forEachOf = eachOf$1;
      exports3.forEachOfSeries = eachOfSeries$1;
      exports3.forEachOfLimit = eachOfLimit$2;
      exports3.inject = reduce$1;
      exports3.foldl = reduce$1;
      exports3.foldr = reduceRight;
      exports3.select = filter$1;
      exports3.selectLimit = filterLimit$1;
      exports3.selectSeries = filterSeries$1;
      exports3.wrapSync = asyncify;
      exports3.during = whilst$1;
      exports3.doDuring = doWhilst$1;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream10 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList3 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream10();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy4();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex4();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex4();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream2, cb) {
      var er = new Error("write after end");
      stream2.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream2.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream2.emit("error", err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable4();
    var Writable = require_stream_writable4();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../node_modules/lazystream/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder4 = __commonJS({
  "../node_modules/lazystream/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream10();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList3();
    var destroyImpl = require_destroy4();
    var StringDecoder;
    util.inherits(Readable2, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex4();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder4().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex4();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream2.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream2.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            stream2.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream2.emit("data", chunk);
        stream2.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder4().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream2);
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream2);
        else
          emitReadable_(stream2);
      }
    }
    function emitReadable_(stream2) {
      debug("emit readable");
      stream2.emit("readable");
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream2.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var Duplex = require_stream_duplex4();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream2._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream2.push(null);
    }
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform4();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/readable.js
var require_readable4 = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable4();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable4();
      exports2.Duplex = require_stream_duplex4();
      exports2.Transform = require_stream_transform4();
      exports2.PassThrough = require_stream_passthrough4();
    }
  }
});

// ../node_modules/lazystream/node_modules/readable-stream/passthrough.js
var require_passthrough = __commonJS({
  "../node_modules/lazystream/node_modules/readable-stream/passthrough.js"(exports2, module2) {
    module2.exports = require_readable4().PassThrough;
  }
});

// ../node_modules/lazystream/lib/lazystream.js
var require_lazystream = __commonJS({
  "../node_modules/lazystream/lib/lazystream.js"(exports2, module2) {
    var util = require("util");
    var PassThrough = require_passthrough();
    module2.exports = {
      Readable: Readable2,
      Writable
    };
    util.inherits(Readable2, PassThrough);
    util.inherits(Writable, PassThrough);
    function beforeFirstCall(instance, method, callback) {
      instance[method] = function() {
        delete instance[method];
        callback.apply(this, arguments);
        return this[method].apply(this, arguments);
      };
    }
    function Readable2(fn, options) {
      if (!(this instanceof Readable2))
        return new Readable2(fn, options);
      PassThrough.call(this, options);
      beforeFirstCall(this, "_read", function() {
        var source = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        source.on("error", emit);
        source.pipe(this);
      });
      this.emit("readable");
    }
    function Writable(fn, options) {
      if (!(this instanceof Writable))
        return new Writable(fn, options);
      PassThrough.call(this, options);
      beforeFirstCall(this, "_write", function() {
        var destination = fn.call(this, options);
        var emit = this.emit.bind(this, "error");
        destination.on("error", emit);
        this.pipe(destination);
      });
      this.emit("writable");
    }
  }
});

// ../node_modules/normalize-path/index.js
var require_normalize_path = __commonJS({
  "../node_modules/normalize-path/index.js"(exports2, module2) {
    module2.exports = function(path, stripTrailing) {
      if (typeof path !== "string") {
        throw new TypeError("expected path to be a string");
      }
      if (path === "\\" || path === "/")
        return "/";
      var len = path.length;
      if (len <= 1)
        return path;
      var prefix = "";
      if (len > 4 && path[3] === "\\") {
        var ch = path[2];
        if ((ch === "?" || ch === ".") && path.slice(0, 2) === "\\\\") {
          path = path.slice(2);
          prefix = "//";
        }
      }
      var segs = path.split(/[/\\]+/);
      if (stripTrailing !== false && segs[segs.length - 1] === "") {
        segs.pop();
      }
      return prefix + segs.join("/");
    };
  }
});

// ../node_modules/lodash.defaults/index.js
var require_lodash2 = __commonJS({
  "../node_modules/lodash.defaults/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module2.exports = defaults;
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream11 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList4 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer2().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream11();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy5();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex5();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream2, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_2) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex5();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream2, cb) {
      var er = new Error("write after end");
      stream2.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream2, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream2.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream2, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream2, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream2, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream2._writev(chunk, state.onwrite);
      else
        stream2._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream2, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream2, state);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
      } else {
        cb(er);
        stream2._writableState.errorEmitted = true;
        stream2.emit("error", er);
        finishMaybe(stream2, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream2, er) {
      var state = stream2._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream2, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream2, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream2, state, finished, cb);
        } else {
          afterWrite(stream2, state, finished, cb);
        }
      }
    }
    function afterWrite(stream2, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream2, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream2, state);
    }
    function onwriteDrain(stream2, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream2.emit("drain");
      }
    }
    function clearBuffer(stream2, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream2._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream2, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream2, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream2, state) {
      stream2._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream2.emit("error", err);
        }
        state.prefinished = true;
        stream2.emit("prefinish");
        finishMaybe(stream2, state);
      });
    }
    function prefinish(stream2, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream2._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream2, state);
        } else {
          state.prefinished = true;
          stream2.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream2, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream2, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream2.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream2, state, cb) {
      state.ending = true;
      finishMaybe(stream2, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream2.once("finish", cb);
      }
      state.ended = true;
      stream2.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var Readable2 = require_stream_readable5();
    var Writable = require_stream_writable5();
    util.inherits(Duplex, Readable2);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable2.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// ../node_modules/archiver-utils/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable2;
    var isArray = require_isarray();
    var Duplex;
    Readable2.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream11();
    var Buffer2 = require_safe_buffer2().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList4();
    var destroyImpl = require_destroy5();
    var StringDecoder;
    util.inherits(Readable2, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream2) {
      Duplex = Duplex || require_stream_duplex5();
      options = options || {};
      var isDuplex = stream2 instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder5().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable2(options) {
      Duplex = Duplex || require_stream_duplex5();
      if (!(this instanceof Readable2))
        return new Readable2(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable2.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable2.prototype.destroy = destroyImpl.destroy;
    Readable2.prototype._undestroy = destroyImpl.undestroy;
    Readable2.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable2.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable2.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream2, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream2._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream2, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream2.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream2.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream2, state, chunk, true);
          } else if (state.ended) {
            stream2.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream2, state, chunk, false);
              else
                maybeReadMore(stream2, state);
            } else {
              addChunk(stream2, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream2, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream2.emit("data", chunk);
        stream2.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream2);
      }
      maybeReadMore(stream2, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable2.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable2.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder5().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable2.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream2, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream2);
    }
    function emitReadable(stream2) {
      var state = stream2._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream2);
        else
          emitReadable_(stream2);
      }
    }
    function emitReadable_(stream2) {
      debug("emit readable");
      stream2.emit("readable");
      flow(stream2);
    }
    function maybeReadMore(stream2, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream2, state);
      }
    }
    function maybeReadMore_(stream2, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream2.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable2.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable2.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable2.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable2.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable2.prototype.addListener = Readable2.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable2.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream2, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream2, state);
      }
    }
    function resume_(stream2, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream2.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream2.emit("resume");
      flow(stream2);
      if (state.flowing && !state.reading)
        stream2.read(0);
    }
    Readable2.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream2) {
      var state = stream2._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream2.read() !== null) {
      }
    }
    Readable2.prototype.wrap = function(stream2) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream2.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream2.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream2.pause();
        }
      });
      for (var i in stream2) {
        if (this[i] === void 0 && typeof stream2[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream2[method].apply(stream2, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream2.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream2.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable2.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable2._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream2) {
      var state = stream2._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream2);
      }
    }
    function endReadableNT(state, stream2) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream2.readable = false;
        stream2.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform2;
    var Duplex = require_stream_duplex5();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(Transform2, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform2(options) {
      if (!(this instanceof Transform2))
        return new Transform2(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform2.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform2.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform2.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform2.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform2.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream2, er, data) {
      if (er)
        return stream2.emit("error", er);
      if (data != null)
        stream2.push(data);
      if (stream2._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream2._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream2.push(null);
    }
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform2 = require_stream_transform5();
    var util = Object.create(require_util3());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform2);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform2.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// ../node_modules/archiver-utils/node_modules/readable-stream/readable.js
var require_readable5 = __commonJS({
  "../node_modules/archiver-utils/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable5();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable5();
      exports2.Duplex = require_stream_duplex5();
      exports2.Transform = require_stream_transform5();
      exports2.PassThrough = require_stream_passthrough5();
    }
  }
});

// ../node_modules/lodash.flatten/index.js
var require_lodash3 = __commonJS({
  "../node_modules/lodash.flatten/index.js"(exports2, module2) {
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function flatten(array) {
      var length = array ? array.length : 0;
      return length ? baseFlatten(array, 1) : [];
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = flatten;
  }
});

// ../node_modules/lodash.difference/index.js
var require_lodash4 = __commonJS({
  "../node_modules/lodash.difference/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      } else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var valuesIndex = valuesLength;
            while (valuesIndex--) {
              if (values[valuesIndex] === computed) {
                continue outer;
              }
            }
            result.push(value);
          } else if (!includes(values, computed, comparator)) {
            result.push(value);
          }
        }
      return result;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
    });
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    module2.exports = difference;
  }
});

// ../node_modules/lodash.union/index.js
var require_lodash5 = __commonJS({
  "../node_modules/lodash.union/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayIncludes(array, value) {
      var length = array ? array.length : 0;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
    var Symbol2 = root.Symbol;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeMax = Math.max;
    var Map2 = getNative(root, "Map");
    var Set2 = getNative(root, "Set");
    var nativeCreate = getNative(Object, "create");
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty2.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values) {
      return new Set2(values);
    };
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty2.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function noop() {
    }
    module2.exports = union;
  }
});

// ../node_modules/lodash.isplainobject/index.js
var require_lodash6 = __commonJS({
  "../node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// ../node_modules/archiver-utils/file.js
var require_file2 = __commonJS({
  "../node_modules/archiver-utils/file.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var path = require("path");
    var flatten = require_lodash3();
    var difference = require_lodash4();
    var union = require_lodash5();
    var isPlainObject = require_lodash6();
    var glob = require_glob();
    var file = module2.exports = {};
    var pathSeparatorRe = /[\/\\]/g;
    var processPatterns = function(patterns, fn) {
      var result = [];
      flatten(patterns).forEach(function(pattern) {
        var exclusion = pattern.indexOf("!") === 0;
        if (exclusion) {
          pattern = pattern.slice(1);
        }
        var matches = fn(pattern);
        if (exclusion) {
          result = difference(result, matches);
        } else {
          result = union(result, matches);
        }
      });
      return result;
    };
    file.exists = function() {
      var filepath = path.join.apply(path, arguments);
      return fs.existsSync(filepath);
    };
    file.expand = function(...args) {
      var options = isPlainObject(args[0]) ? args.shift() : {};
      var patterns = Array.isArray(args[0]) ? args[0] : args;
      if (patterns.length === 0) {
        return [];
      }
      var matches = processPatterns(patterns, function(pattern) {
        return glob.sync(pattern, options);
      });
      if (options.filter) {
        matches = matches.filter(function(filepath) {
          filepath = path.join(options.cwd || "", filepath);
          try {
            if (typeof options.filter === "function") {
              return options.filter(filepath);
            } else {
              return fs.statSync(filepath)[options.filter]();
            }
          } catch (e) {
            return false;
          }
        });
      }
      return matches;
    };
    file.expandMapping = function(patterns, destBase, options) {
      options = Object.assign({
        rename: function(destBase2, destPath) {
          return path.join(destBase2 || "", destPath);
        }
      }, options);
      var files = [];
      var fileByDest = {};
      file.expand(options, patterns).forEach(function(src) {
        var destPath = src;
        if (options.flatten) {
          destPath = path.basename(destPath);
        }
        if (options.ext) {
          destPath = destPath.replace(/(\.[^\/]*)?$/, options.ext);
        }
        var dest = options.rename(destBase, destPath, options);
        if (options.cwd) {
          src = path.join(options.cwd, src);
        }
        dest = dest.replace(pathSeparatorRe, "/");
        src = src.replace(pathSeparatorRe, "/");
        if (fileByDest[dest]) {
          fileByDest[dest].src.push(src);
        } else {
          files.push({
            src: [src],
            dest
          });
          fileByDest[dest] = files[files.length - 1];
        }
      });
      return files;
    };
    file.normalizeFilesArray = function(data) {
      var files = [];
      data.forEach(function(obj) {
        var prop;
        if ("src" in obj || "dest" in obj) {
          files.push(obj);
        }
      });
      if (files.length === 0) {
        return [];
      }
      files = _(files).chain().forEach(function(obj) {
        if (!("src" in obj) || !obj.src) {
          return;
        }
        if (Array.isArray(obj.src)) {
          obj.src = flatten(obj.src);
        } else {
          obj.src = [obj.src];
        }
      }).map(function(obj) {
        var expandOptions = Object.assign({}, obj);
        delete expandOptions.src;
        delete expandOptions.dest;
        if (obj.expand) {
          return file.expandMapping(obj.src, obj.dest, expandOptions).map(function(mapObj) {
            var result2 = Object.assign({}, obj);
            result2.orig = Object.assign({}, obj);
            result2.src = mapObj.src;
            result2.dest = mapObj.dest;
            ["expand", "cwd", "flatten", "rename", "ext"].forEach(function(prop) {
              delete result2[prop];
            });
            return result2;
          });
        }
        var result = Object.assign({}, obj);
        result.orig = Object.assign({}, obj);
        if ("src" in result) {
          Object.defineProperty(result, "src", {
            enumerable: true,
            get: function fn() {
              var src;
              if (!("result" in fn)) {
                src = obj.src;
                src = Array.isArray(src) ? flatten(src) : [src];
                fn.result = file.expand(expandOptions, src);
              }
              return fn.result;
            }
          });
        }
        if ("dest" in result) {
          result.dest = obj.dest;
        }
        return result;
      }).flatten().value();
      return files;
    };
  }
});

// ../node_modules/archiver-utils/index.js
var require_archiver_utils = __commonJS({
  "../node_modules/archiver-utils/index.js"(exports2, module2) {
    var fs = require_graceful_fs();
    var path = require("path");
    var nutil = require("util");
    var lazystream = require_lazystream();
    var normalizePath = require_normalize_path();
    var defaults = require_lodash2();
    var Stream = require("stream").Stream;
    var PassThrough = require_readable5().PassThrough;
    var utils = module2.exports = {};
    utils.file = require_file2();
    utils.collectStream = function(source, callback) {
      var collection = [];
      var size = 0;
      source.on("error", callback);
      source.on("data", function(chunk) {
        collection.push(chunk);
        size += chunk.length;
      });
      source.on("end", function() {
        var buf = new Buffer(size);
        var offset = 0;
        collection.forEach(function(data) {
          data.copy(buf, offset);
          offset += data.length;
        });
        callback(null, buf);
      });
    };
    utils.dateify = function(dateish) {
      dateish = dateish || new Date();
      if (dateish instanceof Date) {
        dateish = dateish;
      } else if (typeof dateish === "string") {
        dateish = new Date(dateish);
      } else {
        dateish = new Date();
      }
      return dateish;
    };
    utils.defaults = function(object, source, guard) {
      var args = arguments;
      args[0] = args[0] || {};
      return defaults(...args);
    };
    utils.isStream = function(source) {
      return source instanceof Stream;
    };
    utils.lazyReadStream = function(filepath) {
      return new lazystream.Readable(function() {
        return fs.createReadStream(filepath);
      });
    };
    utils.normalizeInputSource = function(source) {
      if (source === null) {
        return new Buffer(0);
      } else if (typeof source === "string") {
        return new Buffer(source);
      } else if (utils.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
      }
      return source;
    };
    utils.sanitizePath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
    };
    utils.trailingSlashIt = function(str) {
      return str.slice(-1) !== "/" ? str + "/" : str;
    };
    utils.unixifyPath = function(filepath) {
      return normalizePath(filepath, false).replace(/^\w+:/, "");
    };
    utils.walkdir = function(dirpath, base, callback) {
      var results = [];
      if (typeof base === "function") {
        callback = base;
        base = dirpath;
      }
      fs.readdir(dirpath, function(err, list) {
        var i = 0;
        var file;
        var filepath;
        if (err) {
          return callback(err);
        }
        (function next() {
          file = list[i++];
          if (!file) {
            return callback(null, results);
          }
          filepath = path.join(dirpath, file);
          fs.stat(filepath, function(err2, stats) {
            results.push({
              path: filepath,
              relative: path.relative(base, filepath).replace(/\\/g, "/"),
              stats
            });
            if (stats && stats.isDirectory()) {
              utils.walkdir(filepath, base, function(err3, res) {
                res.forEach(function(dirEntry) {
                  results.push(dirEntry);
                });
                next();
              });
            } else {
              next();
            }
          });
        })();
      });
    };
  }
});

// ../node_modules/archiver/lib/error.js
var require_error2 = __commonJS({
  "../node_modules/archiver/lib/error.js"(exports2, module2) {
    var util = require("util");
    var ERROR_CODES = {
      "ABORTED": "archive was aborted",
      "DIRECTORYDIRPATHREQUIRED": "diretory dirpath argument must be a non-empty string value",
      "DIRECTORYFUNCTIONINVALIDDATA": "invalid data returned by directory custom data function",
      "ENTRYNAMEREQUIRED": "entry name must be a non-empty string value",
      "FILEFILEPATHREQUIRED": "file filepath argument must be a non-empty string value",
      "FINALIZING": "archive already finalizing",
      "QUEUECLOSED": "queue closed",
      "NOENDMETHOD": "no suitable finalize/end method defined by module",
      "DIRECTORYNOTSUPPORTED": "support for directory entries not defined by module",
      "FORMATSET": "archive format already set",
      "INPUTSTEAMBUFFERREQUIRED": "input source must be valid Stream or Buffer instance",
      "MODULESET": "module already set",
      "SYMLINKNOTSUPPORTED": "support for symlink entries not defined by module",
      "SYMLINKFILEPATHREQUIRED": "symlink filepath argument must be a non-empty string value",
      "SYMLINKTARGETREQUIRED": "symlink target argument must be a non-empty string value",
      "ENTRYNOTSUPPORTED": "entry not supported"
    };
    function ArchiverError(code, data) {
      Error.captureStackTrace(this, this.constructor);
      this.message = ERROR_CODES[code] || code;
      this.code = code;
      this.data = data;
    }
    util.inherits(ArchiverError, Error);
    exports2 = module2.exports = ArchiverError;
  }
});

// ../node_modules/archiver/lib/core.js
var require_core = __commonJS({
  "../node_modules/archiver/lib/core.js"(exports2, module2) {
    var fs = require("fs");
    var glob = require_readdir_glob();
    var async = require_async6();
    var path = require("path");
    var util = require_archiver_utils();
    var inherits = require("util").inherits;
    var ArchiverError = require_error2();
    var Transform2 = require_readable().Transform;
    var win32 = process.platform === "win32";
    var Archiver = function(format, options) {
      if (!(this instanceof Archiver)) {
        return new Archiver(format, options);
      }
      if (typeof format !== "string") {
        options = format;
        format = "zip";
      }
      options = this.options = util.defaults(options, {
        highWaterMark: 1024 * 1024,
        statConcurrency: 4
      });
      Transform2.call(this, options);
      this._format = false;
      this._module = false;
      this._pending = 0;
      this._pointer = 0;
      this._entriesCount = 0;
      this._entriesProcessedCount = 0;
      this._fsEntriesTotalBytes = 0;
      this._fsEntriesProcessedBytes = 0;
      this._queue = async.queue(this._onQueueTask.bind(this), 1);
      this._queue.drain(this._onQueueDrain.bind(this));
      this._statQueue = async.queue(this._onStatQueueTask.bind(this), options.statConcurrency);
      this._statQueue.drain(this._onQueueDrain.bind(this));
      this._state = {
        aborted: false,
        finalize: false,
        finalizing: false,
        finalized: false,
        modulePiped: false
      };
      this._streams = [];
    };
    inherits(Archiver, Transform2);
    Archiver.prototype._abort = function() {
      this._state.aborted = true;
      this._queue.kill();
      this._statQueue.kill();
      if (this._queue.idle()) {
        this._shutdown();
      }
    };
    Archiver.prototype._append = function(filepath, data) {
      data = data || {};
      var task = {
        source: null,
        filepath
      };
      if (!data.name) {
        data.name = filepath;
      }
      data.sourcePath = filepath;
      task.data = data;
      this._entriesCount++;
      if (data.stats && data.stats instanceof fs.Stats) {
        task = this._updateQueueTaskWithStats(task, data.stats);
        if (task) {
          if (data.stats.size) {
            this._fsEntriesTotalBytes += data.stats.size;
          }
          this._queue.push(task);
        }
      } else {
        this._statQueue.push(task);
      }
    };
    Archiver.prototype._finalize = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
      }
      this._state.finalizing = true;
      this._moduleFinalize();
      this._state.finalizing = false;
      this._state.finalized = true;
    };
    Archiver.prototype._maybeFinalize = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return false;
      }
      if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
        return true;
      }
      return false;
    };
    Archiver.prototype._moduleAppend = function(source, data, callback) {
      if (this._state.aborted) {
        callback();
        return;
      }
      this._module.append(source, data, function(err) {
        this._task = null;
        if (this._state.aborted) {
          this._shutdown();
          return;
        }
        if (err) {
          this.emit("error", err);
          setImmediate(callback);
          return;
        }
        this.emit("entry", data);
        this._entriesProcessedCount++;
        if (data.stats && data.stats.size) {
          this._fsEntriesProcessedBytes += data.stats.size;
        }
        this.emit("progress", {
          entries: {
            total: this._entriesCount,
            processed: this._entriesProcessedCount
          },
          fs: {
            totalBytes: this._fsEntriesTotalBytes,
            processedBytes: this._fsEntriesProcessedBytes
          }
        });
        setImmediate(callback);
      }.bind(this));
    };
    Archiver.prototype._moduleFinalize = function() {
      if (typeof this._module.finalize === "function") {
        this._module.finalize();
      } else if (typeof this._module.end === "function") {
        this._module.end();
      } else {
        this.emit("error", new ArchiverError("NOENDMETHOD"));
      }
    };
    Archiver.prototype._modulePipe = function() {
      this._module.on("error", this._onModuleError.bind(this));
      this._module.pipe(this);
      this._state.modulePiped = true;
    };
    Archiver.prototype._moduleSupports = function(key) {
      if (!this._module.supports || !this._module.supports[key]) {
        return false;
      }
      return this._module.supports[key];
    };
    Archiver.prototype._moduleUnpipe = function() {
      this._module.unpipe(this);
      this._state.modulePiped = false;
    };
    Archiver.prototype._normalizeEntryData = function(data, stats) {
      data = util.defaults(data, {
        type: "file",
        name: null,
        date: null,
        mode: null,
        prefix: null,
        sourcePath: null,
        stats: false
      });
      if (stats && data.stats === false) {
        data.stats = stats;
      }
      var isDir = data.type === "directory";
      if (data.name) {
        if (typeof data.prefix === "string" && data.prefix !== "") {
          data.name = data.prefix + "/" + data.name;
          data.prefix = null;
        }
        data.name = util.sanitizePath(data.name);
        if (data.type !== "symlink" && data.name.slice(-1) === "/") {
          isDir = true;
          data.type = "directory";
        } else if (isDir) {
          data.name += "/";
        }
      }
      if (typeof data.mode === "number") {
        if (win32) {
          data.mode &= 511;
        } else {
          data.mode &= 4095;
        }
      } else if (data.stats && data.mode === null) {
        if (win32) {
          data.mode = data.stats.mode & 511;
        } else {
          data.mode = data.stats.mode & 4095;
        }
        if (win32 && isDir) {
          data.mode = 493;
        }
      } else if (data.mode === null) {
        data.mode = isDir ? 493 : 420;
      }
      if (data.stats && data.date === null) {
        data.date = data.stats.mtime;
      } else {
        data.date = util.dateify(data.date);
      }
      return data;
    };
    Archiver.prototype._onModuleError = function(err) {
      this.emit("error", err);
    };
    Archiver.prototype._onQueueDrain = function() {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        return;
      }
      if (this._state.finalize && this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
      }
    };
    Archiver.prototype._onQueueTask = function(task, callback) {
      var fullCallback = () => {
        if (task.data.callback) {
          task.data.callback();
        }
        callback();
      };
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        fullCallback();
        return;
      }
      this._task = task;
      this._moduleAppend(task.source, task.data, fullCallback);
    };
    Archiver.prototype._onStatQueueTask = function(task, callback) {
      if (this._state.finalizing || this._state.finalized || this._state.aborted) {
        callback();
        return;
      }
      fs.lstat(task.filepath, function(err, stats) {
        if (this._state.aborted) {
          setImmediate(callback);
          return;
        }
        if (err) {
          this._entriesCount--;
          this.emit("warning", err);
          setImmediate(callback);
          return;
        }
        task = this._updateQueueTaskWithStats(task, stats);
        if (task) {
          if (stats.size) {
            this._fsEntriesTotalBytes += stats.size;
          }
          this._queue.push(task);
        }
        setImmediate(callback);
      }.bind(this));
    };
    Archiver.prototype._shutdown = function() {
      this._moduleUnpipe();
      this.end();
    };
    Archiver.prototype._transform = function(chunk, encoding, callback) {
      if (chunk) {
        this._pointer += chunk.length;
      }
      callback(null, chunk);
    };
    Archiver.prototype._updateQueueTaskWithStats = function(task, stats) {
      if (stats.isFile()) {
        task.data.type = "file";
        task.data.sourceType = "stream";
        task.source = util.lazyReadStream(task.filepath);
      } else if (stats.isDirectory() && this._moduleSupports("directory")) {
        task.data.name = util.trailingSlashIt(task.data.name);
        task.data.type = "directory";
        task.data.sourcePath = util.trailingSlashIt(task.filepath);
        task.data.sourceType = "buffer";
        task.source = Buffer.concat([]);
      } else if (stats.isSymbolicLink() && this._moduleSupports("symlink")) {
        var linkPath = fs.readlinkSync(task.filepath);
        var dirName = path.dirname(task.filepath);
        task.data.type = "symlink";
        task.data.linkname = path.relative(dirName, path.resolve(dirName, linkPath));
        task.data.sourceType = "buffer";
        task.source = Buffer.concat([]);
      } else {
        if (stats.isDirectory()) {
          this.emit("warning", new ArchiverError("DIRECTORYNOTSUPPORTED", task.data));
        } else if (stats.isSymbolicLink()) {
          this.emit("warning", new ArchiverError("SYMLINKNOTSUPPORTED", task.data));
        } else {
          this.emit("warning", new ArchiverError("ENTRYNOTSUPPORTED", task.data));
        }
        return null;
      }
      task.data = this._normalizeEntryData(task.data, stats);
      return task;
    };
    Archiver.prototype.abort = function() {
      if (this._state.aborted || this._state.finalized) {
        return this;
      }
      this._abort();
      return this;
    };
    Archiver.prototype.append = function(source, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      data = this._normalizeEntryData(data);
      if (typeof data.name !== "string" || data.name.length === 0) {
        this.emit("error", new ArchiverError("ENTRYNAMEREQUIRED"));
        return this;
      }
      if (data.type === "directory" && !this._moduleSupports("directory")) {
        this.emit("error", new ArchiverError("DIRECTORYNOTSUPPORTED", { name: data.name }));
        return this;
      }
      source = util.normalizeInputSource(source);
      if (Buffer.isBuffer(source)) {
        data.sourceType = "buffer";
      } else if (util.isStream(source)) {
        data.sourceType = "stream";
      } else {
        this.emit("error", new ArchiverError("INPUTSTEAMBUFFERREQUIRED", { name: data.name }));
        return this;
      }
      this._entriesCount++;
      this._queue.push({
        data,
        source
      });
      return this;
    };
    Archiver.prototype.directory = function(dirpath, destpath, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof dirpath !== "string" || dirpath.length === 0) {
        this.emit("error", new ArchiverError("DIRECTORYDIRPATHREQUIRED"));
        return this;
      }
      this._pending++;
      if (destpath === false) {
        destpath = "";
      } else if (typeof destpath !== "string") {
        destpath = dirpath;
      }
      var dataFunction = false;
      if (typeof data === "function") {
        dataFunction = data;
        data = {};
      } else if (typeof data !== "object") {
        data = {};
      }
      var globOptions = {
        stat: true,
        dot: true
      };
      function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
      }
      function onGlobError(err) {
        this.emit("error", err);
      }
      function onGlobMatch(match) {
        globber.pause();
        var ignoreMatch = false;
        var entryData = Object.assign({}, data);
        entryData.name = match.relative;
        entryData.prefix = destpath;
        entryData.stats = match.stat;
        entryData.callback = globber.resume.bind(globber);
        try {
          if (dataFunction) {
            entryData = dataFunction(entryData);
            if (entryData === false) {
              ignoreMatch = true;
            } else if (typeof entryData !== "object") {
              throw new ArchiverError("DIRECTORYFUNCTIONINVALIDDATA", { dirpath });
            }
          }
        } catch (e) {
          this.emit("error", e);
          return;
        }
        if (ignoreMatch) {
          globber.resume();
          return;
        }
        this._append(match.absolute, entryData);
      }
      var globber = glob(dirpath, globOptions);
      globber.on("error", onGlobError.bind(this));
      globber.on("match", onGlobMatch.bind(this));
      globber.on("end", onGlobEnd.bind(this));
      return this;
    };
    Archiver.prototype.file = function(filepath, data) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("FILEFILEPATHREQUIRED"));
        return this;
      }
      this._append(filepath, data);
      return this;
    };
    Archiver.prototype.glob = function(pattern, options, data) {
      this._pending++;
      options = util.defaults(options, {
        stat: true,
        pattern
      });
      function onGlobEnd() {
        this._pending--;
        this._maybeFinalize();
      }
      function onGlobError(err) {
        this.emit("error", err);
      }
      function onGlobMatch(match) {
        globber.pause();
        var entryData = Object.assign({}, data);
        entryData.callback = globber.resume.bind(globber);
        entryData.stats = match.stat;
        entryData.name = match.relative;
        this._append(match.absolute, entryData);
      }
      var globber = glob(options.cwd || ".", options);
      globber.on("error", onGlobError.bind(this));
      globber.on("match", onGlobMatch.bind(this));
      globber.on("end", onGlobEnd.bind(this));
      return this;
    };
    Archiver.prototype.finalize = function() {
      if (this._state.aborted) {
        var abortedError = new ArchiverError("ABORTED");
        this.emit("error", abortedError);
        return Promise.reject(abortedError);
      }
      if (this._state.finalize) {
        var finalizingError = new ArchiverError("FINALIZING");
        this.emit("error", finalizingError);
        return Promise.reject(finalizingError);
      }
      this._state.finalize = true;
      if (this._pending === 0 && this._queue.idle() && this._statQueue.idle()) {
        this._finalize();
      }
      var self2 = this;
      return new Promise(function(resolve2, reject2) {
        var errored;
        self2._module.on("end", function() {
          if (!errored) {
            resolve2();
          }
        });
        self2._module.on("error", function(err) {
          errored = true;
          reject2(err);
        });
      });
    };
    Archiver.prototype.setFormat = function(format) {
      if (this._format) {
        this.emit("error", new ArchiverError("FORMATSET"));
        return this;
      }
      this._format = format;
      return this;
    };
    Archiver.prototype.setModule = function(module3) {
      if (this._state.aborted) {
        this.emit("error", new ArchiverError("ABORTED"));
        return this;
      }
      if (this._state.module) {
        this.emit("error", new ArchiverError("MODULESET"));
        return this;
      }
      this._module = module3;
      this._modulePipe();
      return this;
    };
    Archiver.prototype.symlink = function(filepath, target, mode) {
      if (this._state.finalize || this._state.aborted) {
        this.emit("error", new ArchiverError("QUEUECLOSED"));
        return this;
      }
      if (typeof filepath !== "string" || filepath.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKFILEPATHREQUIRED"));
        return this;
      }
      if (typeof target !== "string" || target.length === 0) {
        this.emit("error", new ArchiverError("SYMLINKTARGETREQUIRED", { filepath }));
        return this;
      }
      if (!this._moduleSupports("symlink")) {
        this.emit("error", new ArchiverError("SYMLINKNOTSUPPORTED", { filepath }));
        return this;
      }
      var data = {};
      data.type = "symlink";
      data.name = filepath.replace(/\\/g, "/");
      data.linkname = target.replace(/\\/g, "/");
      data.sourceType = "buffer";
      if (typeof mode === "number") {
        data.mode = mode;
      }
      this._entriesCount++;
      this._queue.push({
        data,
        source: Buffer.concat([])
      });
      return this;
    };
    Archiver.prototype.pointer = function() {
      return this._pointer;
    };
    Archiver.prototype.use = function(plugin) {
      this._streams.push(plugin);
      return this;
    };
    module2.exports = Archiver;
  }
});

// ../node_modules/compress-commons/lib/archivers/archive-entry.js
var require_archive_entry = __commonJS({
  "../node_modules/compress-commons/lib/archivers/archive-entry.js"(exports2, module2) {
    var ArchiveEntry = module2.exports = function() {
    };
    ArchiveEntry.prototype.getName = function() {
    };
    ArchiveEntry.prototype.getSize = function() {
    };
    ArchiveEntry.prototype.getLastModifiedDate = function() {
    };
    ArchiveEntry.prototype.isDirectory = function() {
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/zip/util.js
var require_util6 = __commonJS({
  "../node_modules/compress-commons/lib/archivers/zip/util.js"(exports2, module2) {
    var util = module2.exports = {};
    util.dateToDos = function(d, forceLocalTime) {
      forceLocalTime = forceLocalTime || false;
      var year = forceLocalTime ? d.getFullYear() : d.getUTCFullYear();
      if (year < 1980) {
        return 2162688;
      } else if (year >= 2044) {
        return 2141175677;
      }
      var val = {
        year,
        month: forceLocalTime ? d.getMonth() : d.getUTCMonth(),
        date: forceLocalTime ? d.getDate() : d.getUTCDate(),
        hours: forceLocalTime ? d.getHours() : d.getUTCHours(),
        minutes: forceLocalTime ? d.getMinutes() : d.getUTCMinutes(),
        seconds: forceLocalTime ? d.getSeconds() : d.getUTCSeconds()
      };
      return val.year - 1980 << 25 | val.month + 1 << 21 | val.date << 16 | val.hours << 11 | val.minutes << 5 | val.seconds / 2;
    };
    util.dosToDate = function(dos) {
      return new Date((dos >> 25 & 127) + 1980, (dos >> 21 & 15) - 1, dos >> 16 & 31, dos >> 11 & 31, dos >> 5 & 63, (dos & 31) << 1);
    };
    util.fromDosTime = function(buf) {
      return util.dosToDate(buf.readUInt32LE(0));
    };
    util.getEightBytes = function(v) {
      var buf = Buffer.alloc(8);
      buf.writeUInt32LE(v % 4294967296, 0);
      buf.writeUInt32LE(v / 4294967296 | 0, 4);
      return buf;
    };
    util.getShortBytes = function(v) {
      var buf = Buffer.alloc(2);
      buf.writeUInt16LE((v & 65535) >>> 0, 0);
      return buf;
    };
    util.getShortBytesValue = function(buf, offset) {
      return buf.readUInt16LE(offset);
    };
    util.getLongBytes = function(v) {
      var buf = Buffer.alloc(4);
      buf.writeUInt32LE((v & 4294967295) >>> 0, 0);
      return buf;
    };
    util.getLongBytesValue = function(buf, offset) {
      return buf.readUInt32LE(offset);
    };
    util.toDosTime = function(d) {
      return util.getLongBytes(util.dateToDos(d));
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js
var require_general_purpose_bit = __commonJS({
  "../node_modules/compress-commons/lib/archivers/zip/general-purpose-bit.js"(exports2, module2) {
    var zipUtil = require_util6();
    var DATA_DESCRIPTOR_FLAG = 1 << 3;
    var ENCRYPTION_FLAG = 1 << 0;
    var NUMBER_OF_SHANNON_FANO_TREES_FLAG = 1 << 2;
    var SLIDING_DICTIONARY_SIZE_FLAG = 1 << 1;
    var STRONG_ENCRYPTION_FLAG = 1 << 6;
    var UFT8_NAMES_FLAG = 1 << 11;
    var GeneralPurposeBit = module2.exports = function() {
      if (!(this instanceof GeneralPurposeBit)) {
        return new GeneralPurposeBit();
      }
      this.descriptor = false;
      this.encryption = false;
      this.utf8 = false;
      this.numberOfShannonFanoTrees = 0;
      this.strongEncryption = false;
      this.slidingDictionarySize = 0;
      return this;
    };
    GeneralPurposeBit.prototype.encode = function() {
      return zipUtil.getShortBytes((this.descriptor ? DATA_DESCRIPTOR_FLAG : 0) | (this.utf8 ? UFT8_NAMES_FLAG : 0) | (this.encryption ? ENCRYPTION_FLAG : 0) | (this.strongEncryption ? STRONG_ENCRYPTION_FLAG : 0));
    };
    GeneralPurposeBit.prototype.parse = function(buf, offset) {
      var flag = zipUtil.getShortBytesValue(buf, offset);
      var gbp = new GeneralPurposeBit();
      gbp.useDataDescriptor((flag & DATA_DESCRIPTOR_FLAG) !== 0);
      gbp.useUTF8ForNames((flag & UFT8_NAMES_FLAG) !== 0);
      gbp.useStrongEncryption((flag & STRONG_ENCRYPTION_FLAG) !== 0);
      gbp.useEncryption((flag & ENCRYPTION_FLAG) !== 0);
      gbp.setSlidingDictionarySize((flag & SLIDING_DICTIONARY_SIZE_FLAG) !== 0 ? 8192 : 4096);
      gbp.setNumberOfShannonFanoTrees((flag & NUMBER_OF_SHANNON_FANO_TREES_FLAG) !== 0 ? 3 : 2);
      return gbp;
    };
    GeneralPurposeBit.prototype.setNumberOfShannonFanoTrees = function(n) {
      this.numberOfShannonFanoTrees = n;
    };
    GeneralPurposeBit.prototype.getNumberOfShannonFanoTrees = function() {
      return this.numberOfShannonFanoTrees;
    };
    GeneralPurposeBit.prototype.setSlidingDictionarySize = function(n) {
      this.slidingDictionarySize = n;
    };
    GeneralPurposeBit.prototype.getSlidingDictionarySize = function() {
      return this.slidingDictionarySize;
    };
    GeneralPurposeBit.prototype.useDataDescriptor = function(b) {
      this.descriptor = b;
    };
    GeneralPurposeBit.prototype.usesDataDescriptor = function() {
      return this.descriptor;
    };
    GeneralPurposeBit.prototype.useEncryption = function(b) {
      this.encryption = b;
    };
    GeneralPurposeBit.prototype.usesEncryption = function() {
      return this.encryption;
    };
    GeneralPurposeBit.prototype.useStrongEncryption = function(b) {
      this.strongEncryption = b;
    };
    GeneralPurposeBit.prototype.usesStrongEncryption = function() {
      return this.strongEncryption;
    };
    GeneralPurposeBit.prototype.useUTF8ForNames = function(b) {
      this.utf8 = b;
    };
    GeneralPurposeBit.prototype.usesUTF8ForNames = function() {
      return this.utf8;
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/zip/unix-stat.js
var require_unix_stat = __commonJS({
  "../node_modules/compress-commons/lib/archivers/zip/unix-stat.js"(exports2, module2) {
    module2.exports = {
      PERM_MASK: 4095,
      FILE_TYPE_FLAG: 61440,
      LINK_FLAG: 40960,
      FILE_FLAG: 32768,
      DIR_FLAG: 16384,
      DEFAULT_LINK_PERM: 511,
      DEFAULT_DIR_PERM: 493,
      DEFAULT_FILE_PERM: 420
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/zip/constants.js
var require_constants6 = __commonJS({
  "../node_modules/compress-commons/lib/archivers/zip/constants.js"(exports2, module2) {
    module2.exports = {
      WORD: 4,
      DWORD: 8,
      EMPTY: Buffer.alloc(0),
      SHORT: 2,
      SHORT_MASK: 65535,
      SHORT_SHIFT: 16,
      SHORT_ZERO: Buffer.from(Array(2)),
      LONG: 4,
      LONG_ZERO: Buffer.from(Array(4)),
      MIN_VERSION_INITIAL: 10,
      MIN_VERSION_DATA_DESCRIPTOR: 20,
      MIN_VERSION_ZIP64: 45,
      VERSION_MADEBY: 45,
      METHOD_STORED: 0,
      METHOD_DEFLATED: 8,
      PLATFORM_UNIX: 3,
      PLATFORM_FAT: 0,
      SIG_LFH: 67324752,
      SIG_DD: 134695760,
      SIG_CFH: 33639248,
      SIG_EOCD: 101010256,
      SIG_ZIP64_EOCD: 101075792,
      SIG_ZIP64_EOCD_LOC: 117853008,
      ZIP64_MAGIC_SHORT: 65535,
      ZIP64_MAGIC: 4294967295,
      ZIP64_EXTRA_ID: 1,
      ZLIB_NO_COMPRESSION: 0,
      ZLIB_BEST_SPEED: 1,
      ZLIB_BEST_COMPRESSION: 9,
      ZLIB_DEFAULT_COMPRESSION: -1,
      MODE_MASK: 4095,
      DEFAULT_FILE_MODE: 33188,
      DEFAULT_DIR_MODE: 16877,
      EXT_FILE_ATTR_DIR: 1106051088,
      EXT_FILE_ATTR_FILE: 2175008800,
      S_IFMT: 61440,
      S_IFIFO: 4096,
      S_IFCHR: 8192,
      S_IFDIR: 16384,
      S_IFBLK: 24576,
      S_IFREG: 32768,
      S_IFLNK: 40960,
      S_IFSOCK: 49152,
      S_DOS_A: 32,
      S_DOS_D: 16,
      S_DOS_V: 8,
      S_DOS_S: 4,
      S_DOS_H: 2,
      S_DOS_R: 1
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js
var require_zip_archive_entry = __commonJS({
  "../node_modules/compress-commons/lib/archivers/zip/zip-archive-entry.js"(exports2, module2) {
    var inherits = require("util").inherits;
    var normalizePath = require_normalize_path();
    var ArchiveEntry = require_archive_entry();
    var GeneralPurposeBit = require_general_purpose_bit();
    var UnixStat = require_unix_stat();
    var constants = require_constants6();
    var zipUtil = require_util6();
    var ZipArchiveEntry = module2.exports = function(name) {
      if (!(this instanceof ZipArchiveEntry)) {
        return new ZipArchiveEntry(name);
      }
      ArchiveEntry.call(this);
      this.platform = constants.PLATFORM_FAT;
      this.method = -1;
      this.name = null;
      this.size = 0;
      this.csize = 0;
      this.gpb = new GeneralPurposeBit();
      this.crc = 0;
      this.time = -1;
      this.minver = constants.MIN_VERSION_INITIAL;
      this.mode = -1;
      this.extra = null;
      this.exattr = 0;
      this.inattr = 0;
      this.comment = null;
      if (name) {
        this.setName(name);
      }
    };
    inherits(ZipArchiveEntry, ArchiveEntry);
    ZipArchiveEntry.prototype.getCentralDirectoryExtra = function() {
      return this.getExtra();
    };
    ZipArchiveEntry.prototype.getComment = function() {
      return this.comment !== null ? this.comment : "";
    };
    ZipArchiveEntry.prototype.getCompressedSize = function() {
      return this.csize;
    };
    ZipArchiveEntry.prototype.getCrc = function() {
      return this.crc;
    };
    ZipArchiveEntry.prototype.getExternalAttributes = function() {
      return this.exattr;
    };
    ZipArchiveEntry.prototype.getExtra = function() {
      return this.extra !== null ? this.extra : constants.EMPTY;
    };
    ZipArchiveEntry.prototype.getGeneralPurposeBit = function() {
      return this.gpb;
    };
    ZipArchiveEntry.prototype.getInternalAttributes = function() {
      return this.inattr;
    };
    ZipArchiveEntry.prototype.getLastModifiedDate = function() {
      return this.getTime();
    };
    ZipArchiveEntry.prototype.getLocalFileDataExtra = function() {
      return this.getExtra();
    };
    ZipArchiveEntry.prototype.getMethod = function() {
      return this.method;
    };
    ZipArchiveEntry.prototype.getName = function() {
      return this.name;
    };
    ZipArchiveEntry.prototype.getPlatform = function() {
      return this.platform;
    };
    ZipArchiveEntry.prototype.getSize = function() {
      return this.size;
    };
    ZipArchiveEntry.prototype.getTime = function() {
      return this.time !== -1 ? zipUtil.dosToDate(this.time) : -1;
    };
    ZipArchiveEntry.prototype.getTimeDos = function() {
      return this.time !== -1 ? this.time : 0;
    };
    ZipArchiveEntry.prototype.getUnixMode = function() {
      return this.platform !== constants.PLATFORM_UNIX ? 0 : this.getExternalAttributes() >> constants.SHORT_SHIFT & constants.SHORT_MASK;
    };
    ZipArchiveEntry.prototype.getVersionNeededToExtract = function() {
      return this.minver;
    };
    ZipArchiveEntry.prototype.setComment = function(comment) {
      if (Buffer.byteLength(comment) !== comment.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
      }
      this.comment = comment;
    };
    ZipArchiveEntry.prototype.setCompressedSize = function(size) {
      if (size < 0) {
        throw new Error("invalid entry compressed size");
      }
      this.csize = size;
    };
    ZipArchiveEntry.prototype.setCrc = function(crc) {
      if (crc < 0) {
        throw new Error("invalid entry crc32");
      }
      this.crc = crc;
    };
    ZipArchiveEntry.prototype.setExternalAttributes = function(attr) {
      this.exattr = attr >>> 0;
    };
    ZipArchiveEntry.prototype.setExtra = function(extra) {
      this.extra = extra;
    };
    ZipArchiveEntry.prototype.setGeneralPurposeBit = function(gpb) {
      if (!(gpb instanceof GeneralPurposeBit)) {
        throw new Error("invalid entry GeneralPurposeBit");
      }
      this.gpb = gpb;
    };
    ZipArchiveEntry.prototype.setInternalAttributes = function(attr) {
      this.inattr = attr;
    };
    ZipArchiveEntry.prototype.setMethod = function(method) {
      if (method < 0) {
        throw new Error("invalid entry compression method");
      }
      this.method = method;
    };
    ZipArchiveEntry.prototype.setName = function(name, prependSlash = false) {
      name = normalizePath(name, false).replace(/^\w+:/, "").replace(/^(\.\.\/|\/)+/, "");
      if (prependSlash) {
        name = `/${name}`;
      }
      if (Buffer.byteLength(name) !== name.length) {
        this.getGeneralPurposeBit().useUTF8ForNames(true);
      }
      this.name = name;
    };
    ZipArchiveEntry.prototype.setPlatform = function(platform) {
      this.platform = platform;
    };
    ZipArchiveEntry.prototype.setSize = function(size) {
      if (size < 0) {
        throw new Error("invalid entry size");
      }
      this.size = size;
    };
    ZipArchiveEntry.prototype.setTime = function(time, forceLocalTime) {
      if (!(time instanceof Date)) {
        throw new Error("invalid entry time");
      }
      this.time = zipUtil.dateToDos(time, forceLocalTime);
    };
    ZipArchiveEntry.prototype.setUnixMode = function(mode) {
      mode |= this.isDirectory() ? constants.S_IFDIR : constants.S_IFREG;
      var extattr = 0;
      extattr |= mode << constants.SHORT_SHIFT | (this.isDirectory() ? constants.S_DOS_D : constants.S_DOS_A);
      this.setExternalAttributes(extattr);
      this.mode = mode & constants.MODE_MASK;
      this.platform = constants.PLATFORM_UNIX;
    };
    ZipArchiveEntry.prototype.setVersionNeededToExtract = function(minver) {
      this.minver = minver;
    };
    ZipArchiveEntry.prototype.isDirectory = function() {
      return this.getName().slice(-1) === "/";
    };
    ZipArchiveEntry.prototype.isUnixSymlink = function() {
      return (this.getUnixMode() & UnixStat.FILE_TYPE_FLAG) === UnixStat.LINK_FLAG;
    };
    ZipArchiveEntry.prototype.isZip64 = function() {
      return this.csize > constants.ZIP64_MAGIC || this.size > constants.ZIP64_MAGIC;
    };
  }
});

// ../node_modules/compress-commons/lib/util/index.js
var require_util7 = __commonJS({
  "../node_modules/compress-commons/lib/util/index.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    var PassThrough = require_readable().PassThrough;
    var util = module2.exports = {};
    util.isStream = function(source) {
      return source instanceof Stream;
    };
    util.normalizeInputSource = function(source) {
      if (source === null) {
        return Buffer.alloc(0);
      } else if (typeof source === "string") {
        return Buffer.from(source);
      } else if (util.isStream(source) && !source._readableState) {
        var normalized = new PassThrough();
        source.pipe(normalized);
        return normalized;
      }
      return source;
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/archive-output-stream.js
var require_archive_output_stream = __commonJS({
  "../node_modules/compress-commons/lib/archivers/archive-output-stream.js"(exports2, module2) {
    var inherits = require("util").inherits;
    var Transform2 = require_readable().Transform;
    var ArchiveEntry = require_archive_entry();
    var util = require_util7();
    var ArchiveOutputStream = module2.exports = function(options) {
      if (!(this instanceof ArchiveOutputStream)) {
        return new ArchiveOutputStream(options);
      }
      Transform2.call(this, options);
      this.offset = 0;
      this._archive = {
        finish: false,
        finished: false,
        processing: false
      };
    };
    inherits(ArchiveOutputStream, Transform2);
    ArchiveOutputStream.prototype._appendBuffer = function(zae, source, callback) {
    };
    ArchiveOutputStream.prototype._appendStream = function(zae, source, callback) {
    };
    ArchiveOutputStream.prototype._emitErrorCallback = function(err) {
      if (err) {
        this.emit("error", err);
      }
    };
    ArchiveOutputStream.prototype._finish = function(ae) {
    };
    ArchiveOutputStream.prototype._normalizeEntry = function(ae) {
    };
    ArchiveOutputStream.prototype._transform = function(chunk, encoding, callback) {
      callback(null, chunk);
    };
    ArchiveOutputStream.prototype.entry = function(ae, source, callback) {
      source = source || null;
      if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
      }
      if (!(ae instanceof ArchiveEntry)) {
        callback(new Error("not a valid instance of ArchiveEntry"));
        return;
      }
      if (this._archive.finish || this._archive.finished) {
        callback(new Error("unacceptable entry after finish"));
        return;
      }
      if (this._archive.processing) {
        callback(new Error("already processing an entry"));
        return;
      }
      this._archive.processing = true;
      this._normalizeEntry(ae);
      this._entry = ae;
      source = util.normalizeInputSource(source);
      if (Buffer.isBuffer(source)) {
        this._appendBuffer(ae, source, callback);
      } else if (util.isStream(source)) {
        this._appendStream(ae, source, callback);
      } else {
        this._archive.processing = false;
        callback(new Error("input source must be valid Stream or Buffer instance"));
        return;
      }
      return this;
    };
    ArchiveOutputStream.prototype.finish = function() {
      if (this._archive.processing) {
        this._archive.finish = true;
        return;
      }
      this._finish();
    };
    ArchiveOutputStream.prototype.getBytesWritten = function() {
      return this.offset;
    };
    ArchiveOutputStream.prototype.write = function(chunk, cb) {
      if (chunk) {
        this.offset += chunk.length;
      }
      return Transform2.prototype.write.call(this, chunk, cb);
    };
  }
});

// ../node_modules/crc-32/crc32.js
var require_crc322 = __commonJS({
  "../node_modules/crc-32/crc32.js"(exports2) {
    var CRC32;
    (function(factory) {
      if (typeof DO_NOT_EXPORT_CRC === "undefined") {
        if (typeof exports2 === "object") {
          factory(exports2);
        } else if (typeof define === "function" && define.amd) {
          define(function() {
            var module3 = {};
            factory(module3);
            return module3;
          });
        } else {
          factory(CRC32 = {});
        }
      } else {
        factory(CRC32 = {});
      }
    })(function(CRC322) {
      CRC322.version = "1.2.0";
      function signed_crc_table() {
        var c = 0, table = new Array(256);
        for (var n = 0; n != 256; ++n) {
          c = n;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
          table[n] = c;
        }
        return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
      }
      var T = signed_crc_table();
      function crc32_bstr(bstr, seed) {
        var C = seed ^ -1, L = bstr.length - 1;
        for (var i = 0; i < L; ) {
          C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
          C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i++)) & 255];
        }
        if (i === L)
          C = C >>> 8 ^ T[(C ^ bstr.charCodeAt(i)) & 255];
        return C ^ -1;
      }
      function crc32_buf(buf, seed) {
        if (buf.length > 1e4)
          return crc32_buf_8(buf, seed);
        var C = seed ^ -1, L = buf.length - 3;
        for (var i = 0; i < L; ) {
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        }
        while (i < L + 3)
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        return C ^ -1;
      }
      function crc32_buf_8(buf, seed) {
        var C = seed ^ -1, L = buf.length - 7;
        for (var i = 0; i < L; ) {
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        }
        while (i < L + 7)
          C = C >>> 8 ^ T[(C ^ buf[i++]) & 255];
        return C ^ -1;
      }
      function crc32_str(str, seed) {
        var C = seed ^ -1;
        for (var i = 0, L = str.length, c, d; i < L; ) {
          c = str.charCodeAt(i++);
          if (c < 128) {
            C = C >>> 8 ^ T[(C ^ c) & 255];
          } else if (c < 2048) {
            C = C >>> 8 ^ T[(C ^ (192 | c >> 6 & 31)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
          } else if (c >= 55296 && c < 57344) {
            c = (c & 1023) + 64;
            d = str.charCodeAt(i++) & 1023;
            C = C >>> 8 ^ T[(C ^ (240 | c >> 8 & 7)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c >> 2 & 63)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | d & 63)) & 255];
          } else {
            C = C >>> 8 ^ T[(C ^ (224 | c >> 12 & 15)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c >> 6 & 63)) & 255];
            C = C >>> 8 ^ T[(C ^ (128 | c & 63)) & 255];
          }
        }
        return C ^ -1;
      }
      CRC322.table = T;
      CRC322.bstr = crc32_bstr;
      CRC322.buf = crc32_buf;
      CRC322.str = crc32_str;
    });
  }
});

// ../node_modules/crc32-stream/lib/crc32-stream.js
var require_crc32_stream = __commonJS({
  "../node_modules/crc32-stream/lib/crc32-stream.js"(exports2, module2) {
    "use strict";
    var { Transform: Transform2 } = require_readable();
    var crc32 = require_crc322();
    var CRC32Stream = class extends Transform2 {
      constructor(options) {
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
      }
      _transform(chunk, encoding, callback) {
        if (chunk) {
          this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
          this.rawSize += chunk.length;
        }
        callback(null, chunk);
      }
      digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
      }
      hex() {
        return this.digest("hex").toUpperCase();
      }
      size() {
        return this.rawSize;
      }
    };
    module2.exports = CRC32Stream;
  }
});

// ../node_modules/crc32-stream/lib/deflate-crc32-stream.js
var require_deflate_crc32_stream = __commonJS({
  "../node_modules/crc32-stream/lib/deflate-crc32-stream.js"(exports2, module2) {
    "use strict";
    var { DeflateRaw } = require("zlib");
    var crc32 = require_crc322();
    var DeflateCRC32Stream = class extends DeflateRaw {
      constructor(options) {
        super(options);
        this.checksum = Buffer.allocUnsafe(4);
        this.checksum.writeInt32BE(0, 0);
        this.rawSize = 0;
        this.compressedSize = 0;
      }
      push(chunk, encoding) {
        if (chunk) {
          this.compressedSize += chunk.length;
        }
        return super.push(chunk, encoding);
      }
      _transform(chunk, encoding, callback) {
        if (chunk) {
          this.checksum = crc32.buf(chunk, this.checksum) >>> 0;
          this.rawSize += chunk.length;
        }
        super._transform(chunk, encoding, callback);
      }
      digest(encoding) {
        const checksum = Buffer.allocUnsafe(4);
        checksum.writeUInt32BE(this.checksum >>> 0, 0);
        return encoding ? checksum.toString(encoding) : checksum;
      }
      hex() {
        return this.digest("hex").toUpperCase();
      }
      size(compressed = false) {
        if (compressed) {
          return this.compressedSize;
        } else {
          return this.rawSize;
        }
      }
    };
    module2.exports = DeflateCRC32Stream;
  }
});

// ../node_modules/crc32-stream/lib/index.js
var require_lib4 = __commonJS({
  "../node_modules/crc32-stream/lib/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CRC32Stream: require_crc32_stream(),
      DeflateCRC32Stream: require_deflate_crc32_stream()
    };
  }
});

// ../node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js
var require_zip_archive_output_stream = __commonJS({
  "../node_modules/compress-commons/lib/archivers/zip/zip-archive-output-stream.js"(exports2, module2) {
    var inherits = require("util").inherits;
    var crc32 = require_buffer_crc32();
    var { CRC32Stream } = require_lib4();
    var { DeflateCRC32Stream } = require_lib4();
    var ArchiveOutputStream = require_archive_output_stream();
    var ZipArchiveEntry = require_zip_archive_entry();
    var GeneralPurposeBit = require_general_purpose_bit();
    var constants = require_constants6();
    var util = require_util7();
    var zipUtil = require_util6();
    var ZipArchiveOutputStream = module2.exports = function(options) {
      if (!(this instanceof ZipArchiveOutputStream)) {
        return new ZipArchiveOutputStream(options);
      }
      options = this.options = this._defaults(options);
      ArchiveOutputStream.call(this, options);
      this._entry = null;
      this._entries = [];
      this._archive = {
        centralLength: 0,
        centralOffset: 0,
        comment: "",
        finish: false,
        finished: false,
        processing: false,
        forceZip64: options.forceZip64,
        forceLocalTime: options.forceLocalTime
      };
    };
    inherits(ZipArchiveOutputStream, ArchiveOutputStream);
    ZipArchiveOutputStream.prototype._afterAppend = function(ae) {
      this._entries.push(ae);
      if (ae.getGeneralPurposeBit().usesDataDescriptor()) {
        this._writeDataDescriptor(ae);
      }
      this._archive.processing = false;
      this._entry = null;
      if (this._archive.finish && !this._archive.finished) {
        this._finish();
      }
    };
    ZipArchiveOutputStream.prototype._appendBuffer = function(ae, source, callback) {
      if (source.length === 0) {
        ae.setMethod(constants.METHOD_STORED);
      }
      var method = ae.getMethod();
      if (method === constants.METHOD_STORED) {
        ae.setSize(source.length);
        ae.setCompressedSize(source.length);
        ae.setCrc(crc32.unsigned(source));
      }
      this._writeLocalFileHeader(ae);
      if (method === constants.METHOD_STORED) {
        this.write(source);
        this._afterAppend(ae);
        callback(null, ae);
        return;
      } else if (method === constants.METHOD_DEFLATED) {
        this._smartStream(ae, callback).end(source);
        return;
      } else {
        callback(new Error("compression method " + method + " not implemented"));
        return;
      }
    };
    ZipArchiveOutputStream.prototype._appendStream = function(ae, source, callback) {
      ae.getGeneralPurposeBit().useDataDescriptor(true);
      ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
      this._writeLocalFileHeader(ae);
      var smart = this._smartStream(ae, callback);
      source.once("error", function(err) {
        smart.emit("error", err);
        smart.end();
      });
      source.pipe(smart);
    };
    ZipArchiveOutputStream.prototype._defaults = function(o) {
      if (typeof o !== "object") {
        o = {};
      }
      if (typeof o.zlib !== "object") {
        o.zlib = {};
      }
      if (typeof o.zlib.level !== "number") {
        o.zlib.level = constants.ZLIB_BEST_SPEED;
      }
      o.forceZip64 = !!o.forceZip64;
      o.forceLocalTime = !!o.forceLocalTime;
      return o;
    };
    ZipArchiveOutputStream.prototype._finish = function() {
      this._archive.centralOffset = this.offset;
      this._entries.forEach(function(ae) {
        this._writeCentralFileHeader(ae);
      }.bind(this));
      this._archive.centralLength = this.offset - this._archive.centralOffset;
      if (this.isZip64()) {
        this._writeCentralDirectoryZip64();
      }
      this._writeCentralDirectoryEnd();
      this._archive.processing = false;
      this._archive.finish = true;
      this._archive.finished = true;
      this.end();
    };
    ZipArchiveOutputStream.prototype._normalizeEntry = function(ae) {
      if (ae.getMethod() === -1) {
        ae.setMethod(constants.METHOD_DEFLATED);
      }
      if (ae.getMethod() === constants.METHOD_DEFLATED) {
        ae.getGeneralPurposeBit().useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_DATA_DESCRIPTOR);
      }
      if (ae.getTime() === -1) {
        ae.setTime(new Date(), this._archive.forceLocalTime);
      }
      ae._offsets = {
        file: 0,
        data: 0,
        contents: 0
      };
    };
    ZipArchiveOutputStream.prototype._smartStream = function(ae, callback) {
      var deflate = ae.getMethod() === constants.METHOD_DEFLATED;
      var process2 = deflate ? new DeflateCRC32Stream(this.options.zlib) : new CRC32Stream();
      var error = null;
      function handleStuff() {
        var digest = process2.digest().readUInt32BE(0);
        ae.setCrc(digest);
        ae.setSize(process2.size());
        ae.setCompressedSize(process2.size(true));
        this._afterAppend(ae);
        callback(error, ae);
      }
      process2.once("end", handleStuff.bind(this));
      process2.once("error", function(err) {
        error = err;
      });
      process2.pipe(this, { end: false });
      return process2;
    };
    ZipArchiveOutputStream.prototype._writeCentralDirectoryEnd = function() {
      var records = this._entries.length;
      var size = this._archive.centralLength;
      var offset = this._archive.centralOffset;
      if (this.isZip64()) {
        records = constants.ZIP64_MAGIC_SHORT;
        size = constants.ZIP64_MAGIC;
        offset = constants.ZIP64_MAGIC;
      }
      this.write(zipUtil.getLongBytes(constants.SIG_EOCD));
      this.write(constants.SHORT_ZERO);
      this.write(constants.SHORT_ZERO);
      this.write(zipUtil.getShortBytes(records));
      this.write(zipUtil.getShortBytes(records));
      this.write(zipUtil.getLongBytes(size));
      this.write(zipUtil.getLongBytes(offset));
      var comment = this.getComment();
      var commentLength = Buffer.byteLength(comment);
      this.write(zipUtil.getShortBytes(commentLength));
      this.write(comment);
    };
    ZipArchiveOutputStream.prototype._writeCentralDirectoryZip64 = function() {
      this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD));
      this.write(zipUtil.getEightBytes(44));
      this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
      this.write(zipUtil.getShortBytes(constants.MIN_VERSION_ZIP64));
      this.write(constants.LONG_ZERO);
      this.write(constants.LONG_ZERO);
      this.write(zipUtil.getEightBytes(this._entries.length));
      this.write(zipUtil.getEightBytes(this._entries.length));
      this.write(zipUtil.getEightBytes(this._archive.centralLength));
      this.write(zipUtil.getEightBytes(this._archive.centralOffset));
      this.write(zipUtil.getLongBytes(constants.SIG_ZIP64_EOCD_LOC));
      this.write(constants.LONG_ZERO);
      this.write(zipUtil.getEightBytes(this._archive.centralOffset + this._archive.centralLength));
      this.write(zipUtil.getLongBytes(1));
    };
    ZipArchiveOutputStream.prototype._writeCentralFileHeader = function(ae) {
      var gpb = ae.getGeneralPurposeBit();
      var method = ae.getMethod();
      var offsets = ae._offsets;
      var size = ae.getSize();
      var compressedSize = ae.getCompressedSize();
      if (ae.isZip64() || offsets.file > constants.ZIP64_MAGIC) {
        size = constants.ZIP64_MAGIC;
        compressedSize = constants.ZIP64_MAGIC;
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
        var extraBuf = Buffer.concat([
          zipUtil.getShortBytes(constants.ZIP64_EXTRA_ID),
          zipUtil.getShortBytes(24),
          zipUtil.getEightBytes(ae.getSize()),
          zipUtil.getEightBytes(ae.getCompressedSize()),
          zipUtil.getEightBytes(offsets.file)
        ], 28);
        ae.setExtra(extraBuf);
      }
      this.write(zipUtil.getLongBytes(constants.SIG_CFH));
      this.write(zipUtil.getShortBytes(ae.getPlatform() << 8 | constants.VERSION_MADEBY));
      this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
      this.write(gpb.encode());
      this.write(zipUtil.getShortBytes(method));
      this.write(zipUtil.getLongBytes(ae.getTimeDos()));
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      this.write(zipUtil.getLongBytes(compressedSize));
      this.write(zipUtil.getLongBytes(size));
      var name = ae.getName();
      var comment = ae.getComment();
      var extra = ae.getCentralDirectoryExtra();
      if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
        comment = Buffer.from(comment);
      }
      this.write(zipUtil.getShortBytes(name.length));
      this.write(zipUtil.getShortBytes(extra.length));
      this.write(zipUtil.getShortBytes(comment.length));
      this.write(constants.SHORT_ZERO);
      this.write(zipUtil.getShortBytes(ae.getInternalAttributes()));
      this.write(zipUtil.getLongBytes(ae.getExternalAttributes()));
      if (offsets.file > constants.ZIP64_MAGIC) {
        this.write(zipUtil.getLongBytes(constants.ZIP64_MAGIC));
      } else {
        this.write(zipUtil.getLongBytes(offsets.file));
      }
      this.write(name);
      this.write(extra);
      this.write(comment);
    };
    ZipArchiveOutputStream.prototype._writeDataDescriptor = function(ae) {
      this.write(zipUtil.getLongBytes(constants.SIG_DD));
      this.write(zipUtil.getLongBytes(ae.getCrc()));
      if (ae.isZip64()) {
        this.write(zipUtil.getEightBytes(ae.getCompressedSize()));
        this.write(zipUtil.getEightBytes(ae.getSize()));
      } else {
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
      }
    };
    ZipArchiveOutputStream.prototype._writeLocalFileHeader = function(ae) {
      var gpb = ae.getGeneralPurposeBit();
      var method = ae.getMethod();
      var name = ae.getName();
      var extra = ae.getLocalFileDataExtra();
      if (ae.isZip64()) {
        gpb.useDataDescriptor(true);
        ae.setVersionNeededToExtract(constants.MIN_VERSION_ZIP64);
      }
      if (gpb.usesUTF8ForNames()) {
        name = Buffer.from(name);
      }
      ae._offsets.file = this.offset;
      this.write(zipUtil.getLongBytes(constants.SIG_LFH));
      this.write(zipUtil.getShortBytes(ae.getVersionNeededToExtract()));
      this.write(gpb.encode());
      this.write(zipUtil.getShortBytes(method));
      this.write(zipUtil.getLongBytes(ae.getTimeDos()));
      ae._offsets.data = this.offset;
      if (gpb.usesDataDescriptor()) {
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
        this.write(constants.LONG_ZERO);
      } else {
        this.write(zipUtil.getLongBytes(ae.getCrc()));
        this.write(zipUtil.getLongBytes(ae.getCompressedSize()));
        this.write(zipUtil.getLongBytes(ae.getSize()));
      }
      this.write(zipUtil.getShortBytes(name.length));
      this.write(zipUtil.getShortBytes(extra.length));
      this.write(name);
      this.write(extra);
      ae._offsets.contents = this.offset;
    };
    ZipArchiveOutputStream.prototype.getComment = function(comment) {
      return this._archive.comment !== null ? this._archive.comment : "";
    };
    ZipArchiveOutputStream.prototype.isZip64 = function() {
      return this._archive.forceZip64 || this._entries.length > constants.ZIP64_MAGIC_SHORT || this._archive.centralLength > constants.ZIP64_MAGIC || this._archive.centralOffset > constants.ZIP64_MAGIC;
    };
    ZipArchiveOutputStream.prototype.setComment = function(comment) {
      this._archive.comment = comment;
    };
  }
});

// ../node_modules/compress-commons/lib/compress-commons.js
var require_compress_commons = __commonJS({
  "../node_modules/compress-commons/lib/compress-commons.js"(exports2, module2) {
    module2.exports = {
      ArchiveEntry: require_archive_entry(),
      ZipArchiveEntry: require_zip_archive_entry(),
      ArchiveOutputStream: require_archive_output_stream(),
      ZipArchiveOutputStream: require_zip_archive_output_stream()
    };
  }
});

// ../node_modules/zip-stream/index.js
var require_zip_stream = __commonJS({
  "../node_modules/zip-stream/index.js"(exports2, module2) {
    var inherits = require("util").inherits;
    var ZipArchiveOutputStream = require_compress_commons().ZipArchiveOutputStream;
    var ZipArchiveEntry = require_compress_commons().ZipArchiveEntry;
    var util = require_archiver_utils();
    var ZipStream = module2.exports = function(options) {
      if (!(this instanceof ZipStream)) {
        return new ZipStream(options);
      }
      options = this.options = options || {};
      options.zlib = options.zlib || {};
      ZipArchiveOutputStream.call(this, options);
      if (typeof options.level === "number" && options.level >= 0) {
        options.zlib.level = options.level;
        delete options.level;
      }
      if (!options.forceZip64 && typeof options.zlib.level === "number" && options.zlib.level === 0) {
        options.store = true;
      }
      options.namePrependSlash = options.namePrependSlash || false;
      if (options.comment && options.comment.length > 0) {
        this.setComment(options.comment);
      }
    };
    inherits(ZipStream, ZipArchiveOutputStream);
    ZipStream.prototype._normalizeFileData = function(data) {
      data = util.defaults(data, {
        type: "file",
        name: null,
        namePrependSlash: this.options.namePrependSlash,
        linkname: null,
        date: null,
        mode: null,
        store: this.options.store,
        comment: ""
      });
      var isDir = data.type === "directory";
      var isSymlink = data.type === "symlink";
      if (data.name) {
        data.name = util.sanitizePath(data.name);
        if (!isSymlink && data.name.slice(-1) === "/") {
          isDir = true;
          data.type = "directory";
        } else if (isDir) {
          data.name += "/";
        }
      }
      if (isDir || isSymlink) {
        data.store = true;
      }
      data.date = util.dateify(data.date);
      return data;
    };
    ZipStream.prototype.entry = function(source, data, callback) {
      if (typeof callback !== "function") {
        callback = this._emitErrorCallback.bind(this);
      }
      data = this._normalizeFileData(data);
      if (data.type !== "file" && data.type !== "directory" && data.type !== "symlink") {
        callback(new Error(data.type + " entries not currently supported"));
        return;
      }
      if (typeof data.name !== "string" || data.name.length === 0) {
        callback(new Error("entry name must be a non-empty string value"));
        return;
      }
      if (data.type === "symlink" && typeof data.linkname !== "string") {
        callback(new Error("entry linkname must be a non-empty string value when type equals symlink"));
        return;
      }
      var entry = new ZipArchiveEntry(data.name);
      entry.setTime(data.date, this.options.forceLocalTime);
      if (data.namePrependSlash) {
        entry.setName(data.name, true);
      }
      if (data.store) {
        entry.setMethod(0);
      }
      if (data.comment.length > 0) {
        entry.setComment(data.comment);
      }
      if (data.type === "symlink" && typeof data.mode !== "number") {
        data.mode = 40960;
      }
      if (typeof data.mode === "number") {
        if (data.type === "symlink") {
          data.mode |= 40960;
        }
        entry.setUnixMode(data.mode);
      }
      if (data.type === "symlink" && typeof data.linkname === "string") {
        source = Buffer.from(data.linkname);
      }
      return ZipArchiveOutputStream.prototype.entry.call(this, entry, source, callback);
    };
    ZipStream.prototype.finalize = function() {
      this.finish();
    };
  }
});

// ../node_modules/archiver/lib/plugins/zip.js
var require_zip = __commonJS({
  "../node_modules/archiver/lib/plugins/zip.js"(exports2, module2) {
    var engine = require_zip_stream();
    var util = require_archiver_utils();
    var Zip = function(options) {
      if (!(this instanceof Zip)) {
        return new Zip(options);
      }
      options = this.options = util.defaults(options, {
        comment: "",
        forceUTC: false,
        namePrependSlash: false,
        store: false
      });
      this.supports = {
        directory: true,
        symlink: true
      };
      this.engine = new engine(options);
    };
    Zip.prototype.append = function(source, data, callback) {
      this.engine.entry(source, data, callback);
    };
    Zip.prototype.finalize = function() {
      this.engine.finalize();
    };
    Zip.prototype.on = function() {
      return this.engine.on.apply(this.engine, arguments);
    };
    Zip.prototype.pipe = function() {
      return this.engine.pipe.apply(this.engine, arguments);
    };
    Zip.prototype.unpipe = function() {
      return this.engine.unpipe.apply(this.engine, arguments);
    };
    module2.exports = Zip;
  }
});

// ../node_modules/bl/BufferList.js
var require_BufferList5 = __commonJS({
  "../node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    BufferList._init = function _init(buf) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    };
    BufferList.prototype._new = function _new(buf) {
      return new BufferList(buf);
    };
    BufferList.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList.prototype.slice = function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList.prototype.toString = function toString(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList.prototype.consume = function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    };
    BufferList.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList.prototype.append = function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    };
    BufferList.prototype._appendBuffer = function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    };
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    };
    BufferList.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList;
  }
});

// ../node_modules/bl/bl.js
var require_bl2 = __commonJS({
  "../node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList5();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }.bind(this);
        this.on("pipe", function onPipe(src) {
          src.on("error", piper);
        });
        this.on("unpipe", function onUnpipe(src) {
          src.removeListener("error", piper);
        });
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = function _new(callback) {
      return new BufferListStream(callback);
    };
    BufferListStream.prototype._write = function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    };
    BufferListStream.prototype._read = function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    };
    BufferListStream.prototype.end = function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    };
    BufferListStream.prototype._destroy = function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    };
    BufferListStream.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    };
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// ../node_modules/tar-stream/headers.js
var require_headers3 = __commonJS({
  "../node_modules/tar-stream/headers.js"(exports2) {
    var alloc = Buffer.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
    var USTAR_VER = Buffer.from("00", "binary");
    var GNU_MAGIC = Buffer.from("ustar ", "binary");
    var GNU_VER = Buffer.from(" \0", "binary");
    var MASK = parseInt("7777", 8);
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      var sum = 8 * 32;
      for (var i = 0; i < 148; i++)
        sum += block[i];
      for (var j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    function parse256(buf) {
      var positive;
      if (buf[0] === 128)
        positive = true;
      else if (buf[0] === 255)
        positive = false;
      else
        return null;
      var tuple = [];
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i];
        if (positive)
          tuple.push(byte);
        else
          tuple.push(255 - byte);
      }
      var sum = 0;
      var l = tuple.length;
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length) {
      val = val.slice(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32)
          offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
    };
    var addLength = function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer.from(result);
    };
    exports2.decodePax = function(buf) {
      var result = {};
      while (buf.length) {
        var i = 0;
        while (i < buf.length && buf[i] !== 32)
          i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len)
          return result;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result;
    };
    exports2.encode = function(opts) {
      var buf = alloc(512);
      var name = opts.name;
      var prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/")
        name += "/";
      if (Buffer.byteLength(name) !== name.length)
        return null;
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100)
        return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf.write(opts.linkname, 157);
      USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
      USTAR_VER.copy(buf, VERSION_OFFSET);
      if (opts.uname)
        buf.write(opts.uname, 265);
      if (opts.gname)
        buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf.write(prefix, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      var c = cksum(buf);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
        if (buf[345])
          name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
      } else {
        if (!allowUnknownFormat) {
          throw new Error("Invalid tar header: unknown format.");
        }
      }
      if (typeflag === 0 && name && name[name.length - 1] === "/")
        typeflag = 5;
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// ../node_modules/tar-stream/extract.js
var require_extract2 = __commonJS({
  "../node_modules/tar-stream/extract.js"(exports2, module2) {
    var util = require("util");
    var bl = require_bl2();
    var headers = require_headers3();
    var Writable = require_readable().Writable;
    var PassThrough = require_readable().PassThrough;
    var noop = function() {
    };
    var overflow = function(size) {
      size &= 511;
      return size && 512 - size;
    };
    var emptyStream = function(self2, offset) {
      var s = new Source(self2, offset);
      s.end();
      return s;
    };
    var mixinPax = function(header, pax) {
      if (pax.path)
        header.name = pax.path;
      if (pax.linkpath)
        header.linkname = pax.linkpath;
      if (pax.size)
        header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    };
    var Source = function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough.call(this, { autoDestroy: false });
    };
    util.inherits(Source, PassThrough);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = function(opts) {
      if (!(this instanceof Extract))
        return new Extract(opts);
      Writable.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b = self2._buffer;
      var oncontinue = function() {
        self2._continue();
      };
      var onunlock = function(err) {
        self2._locked = false;
        if (err)
          return self2.destroy(err);
        if (!self2._stream)
          oncontinue();
      };
      var onstreamend = function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain)
          self2._parse(drain, ondrain);
        else
          self2._parse(512, onheader);
        if (!self2._locked)
          oncontinue();
      };
      var ondrain = function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      };
      var onpaxglobalheader = function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
      };
      var onpaxheader = function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b.slice(0, size));
        if (self2._paxGlobal)
          self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
        b.consume(size);
        onstreamend();
      };
      var ongnulongpath = function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var ongnulonglinkpath = function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      };
      var onheader = function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
        } catch (err) {
          self2.emit("error", err);
        }
        b.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      };
      this._onheader = onheader;
      this._parse(512, onheader);
    };
    util.inherits(Extract, Writable);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream)
        this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed)
        return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader)
        this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed)
        return;
      var cb = this._cb;
      this._cb = noop;
      if (this._overflow)
        this._write(this._overflow, void 0, cb);
      else
        cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed)
        return;
      var s = this._stream;
      var b = this._buffer;
      var missing = this._missing;
      if (data.length)
        this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s)
          return s.write(data, cb);
        b.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s)
        s.end(data);
      else
        b.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial)
        return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  }
});

// ../node_modules/tar-stream/pack.js
var require_pack2 = __commonJS({
  "../node_modules/tar-stream/pack.js"(exports2, module2) {
    var constants = require_fs_constants();
    var eos = require_end_of_stream2();
    var inherits = require_inherits();
    var alloc = Buffer.alloc;
    var Readable2 = require_readable().Readable;
    var Writable = require_readable().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var headers = require_headers3();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc(1024);
    var noop = function() {
    };
    var overflow = function(self2, size) {
      size &= 511;
      if (size)
        self2.push(END_OF_TAR.slice(0, 512 - size));
    };
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    var Sink = function(to) {
      Writable.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    };
    inherits(Sink, Writable);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data))
        return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = function() {
      Writable.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder("utf-8");
      this._destroyed = false;
    };
    inherits(LinkSink, Writable);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = function() {
      Writable.call(this);
      this._destroyed = false;
    };
    inherits(Void, Writable);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed)
        return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = function(opts) {
      if (!(this instanceof Pack))
        return new Pack(opts);
      Readable2.call(this, opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    };
    inherits(Pack, Readable2);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream)
        throw new Error("already piping an entry");
      if (this._finalized || this._destroyed)
        return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback)
        callback = noop;
      var self2 = this;
      if (!header.size || header.type === "symlink")
        header.size = 0;
      if (!header.type)
        header.type = modeToType(header.mode);
      if (!header.mode)
        header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid)
        header.uid = 0;
      if (!header.gid)
        header.gid = 0;
      if (!header.mtime)
        header.mtime = new Date();
      if (typeof buffer === "string")
        buffer = Buffer.from(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        var ok = this.push(buffer);
        overflow(self2, header.size);
        if (ok)
          process.nextTick(callback);
        else
          this._drain = callback;
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing)
          self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized)
        return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      if (err)
        this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy)
        this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n) {
      var drain = this._drain;
      this._drain = noop;
      drain();
    };
    module2.exports = Pack;
  }
});

// ../node_modules/tar-stream/index.js
var require_tar_stream2 = __commonJS({
  "../node_modules/tar-stream/index.js"(exports2) {
    exports2.extract = require_extract2();
    exports2.pack = require_pack2();
  }
});

// ../node_modules/archiver/lib/plugins/tar.js
var require_tar = __commonJS({
  "../node_modules/archiver/lib/plugins/tar.js"(exports2, module2) {
    var zlib = require("zlib");
    var engine = require_tar_stream2();
    var util = require_archiver_utils();
    var Tar = function(options) {
      if (!(this instanceof Tar)) {
        return new Tar(options);
      }
      options = this.options = util.defaults(options, {
        gzip: false
      });
      if (typeof options.gzipOptions !== "object") {
        options.gzipOptions = {};
      }
      this.supports = {
        directory: true,
        symlink: true
      };
      this.engine = engine.pack(options);
      this.compressor = false;
      if (options.gzip) {
        this.compressor = zlib.createGzip(options.gzipOptions);
        this.compressor.on("error", this._onCompressorError.bind(this));
      }
    };
    Tar.prototype._onCompressorError = function(err) {
      this.engine.emit("error", err);
    };
    Tar.prototype.append = function(source, data, callback) {
      var self2 = this;
      data.mtime = data.date;
      function append(err, sourceBuffer) {
        if (err) {
          callback(err);
          return;
        }
        self2.engine.entry(data, sourceBuffer, function(err2) {
          callback(err2, data);
        });
      }
      if (data.sourceType === "buffer") {
        append(null, source);
      } else if (data.sourceType === "stream" && data.stats) {
        data.size = data.stats.size;
        var entry = self2.engine.entry(data, function(err) {
          callback(err, data);
        });
        source.pipe(entry);
      } else if (data.sourceType === "stream") {
        util.collectStream(source, append);
      }
    };
    Tar.prototype.finalize = function() {
      this.engine.finalize();
    };
    Tar.prototype.on = function() {
      return this.engine.on.apply(this.engine, arguments);
    };
    Tar.prototype.pipe = function(destination, options) {
      if (this.compressor) {
        return this.engine.pipe.apply(this.engine, [this.compressor]).pipe(destination, options);
      } else {
        return this.engine.pipe.apply(this.engine, arguments);
      }
    };
    Tar.prototype.unpipe = function() {
      if (this.compressor) {
        return this.compressor.unpipe.apply(this.compressor, arguments);
      } else {
        return this.engine.unpipe.apply(this.engine, arguments);
      }
    };
    module2.exports = Tar;
  }
});

// ../node_modules/archiver/lib/plugins/json.js
var require_json2 = __commonJS({
  "../node_modules/archiver/lib/plugins/json.js"(exports2, module2) {
    var inherits = require("util").inherits;
    var Transform2 = require_readable().Transform;
    var crc32 = require_buffer_crc32();
    var util = require_archiver_utils();
    var Json = function(options) {
      if (!(this instanceof Json)) {
        return new Json(options);
      }
      options = this.options = util.defaults(options, {});
      Transform2.call(this, options);
      this.supports = {
        directory: true,
        symlink: true
      };
      this.files = [];
    };
    inherits(Json, Transform2);
    Json.prototype._transform = function(chunk, encoding, callback) {
      callback(null, chunk);
    };
    Json.prototype._writeStringified = function() {
      var fileString = JSON.stringify(this.files);
      this.write(fileString);
    };
    Json.prototype.append = function(source, data, callback) {
      var self2 = this;
      data.crc32 = 0;
      function onend(err, sourceBuffer) {
        if (err) {
          callback(err);
          return;
        }
        data.size = sourceBuffer.length || 0;
        data.crc32 = crc32.unsigned(sourceBuffer);
        self2.files.push(data);
        callback(null, data);
      }
      if (data.sourceType === "buffer") {
        onend(null, source);
      } else if (data.sourceType === "stream") {
        util.collectStream(source, onend);
      }
    };
    Json.prototype.finalize = function() {
      this._writeStringified();
      this.end();
    };
    module2.exports = Json;
  }
});

// ../node_modules/archiver/index.js
var require_archiver = __commonJS({
  "../node_modules/archiver/index.js"(exports2, module2) {
    var Archiver = require_core();
    var formats = {};
    var vending = function(format, options) {
      return vending.create(format, options);
    };
    vending.create = function(format, options) {
      if (formats[format]) {
        var instance = new Archiver(format, options);
        instance.setFormat(format);
        instance.setModule(new formats[format](options));
        return instance;
      } else {
        throw new Error("create(" + format + "): format not registered");
      }
    };
    vending.registerFormat = function(format, module3) {
      if (formats[format]) {
        throw new Error("register(" + format + "): format already registered");
      }
      if (typeof module3 !== "function") {
        throw new Error("register(" + format + "): format module invalid");
      }
      if (typeof module3.prototype.append !== "function" || typeof module3.prototype.finalize !== "function") {
        throw new Error("register(" + format + "): format module missing methods");
      }
      formats[format] = module3;
    };
    vending.isRegisteredFormat = function(format) {
      if (formats[format]) {
        return true;
      }
      return false;
    };
    vending.registerFormat("zip", require_zip());
    vending.registerFormat("tar", require_tar());
    vending.registerFormat("json", require_json2());
    module2.exports = vending;
  }
});

// ../node_modules/throat/index.js
var require_throat = __commonJS({
  "../node_modules/throat/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(PromiseArgument) {
      var Promise2;
      function throat(size, fn) {
        var queue = new Queue();
        function run(fn2, self2, args) {
          if (size) {
            size--;
            var result = new Promise2(function(resolve2) {
              resolve2(fn2.apply(self2, args));
            });
            result.then(release, release);
            return result;
          } else {
            return new Promise2(function(resolve2) {
              queue.push(new Delayed(resolve2, fn2, self2, args));
            });
          }
        }
        function release() {
          size++;
          if (!queue.isEmpty()) {
            var next = queue.shift();
            next.resolve(run(next.fn, next.self, next.args));
          }
        }
        if (typeof size === "function") {
          var temp = fn;
          fn = size;
          size = temp;
        }
        if (typeof size !== "number") {
          throw new TypeError("Expected throat size to be a number but got " + typeof size);
        }
        if (fn !== void 0 && typeof fn !== "function") {
          throw new TypeError("Expected throat fn to be a function but got " + typeof fn);
        }
        if (typeof fn === "function") {
          return function() {
            var args = [];
            for (var i = 0; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            return run(fn, this, args);
          };
        } else {
          return function(fn2) {
            if (typeof fn2 !== "function") {
              throw new TypeError("Expected throat fn to be a function but got " + typeof fn2);
            }
            var args = [];
            for (var i = 1; i < arguments.length; i++) {
              args.push(arguments[i]);
            }
            return run(fn2, this, args);
          };
        }
      }
      if (arguments.length === 1 && typeof PromiseArgument === "function") {
        Promise2 = PromiseArgument;
        return throat;
      } else {
        Promise2 = module2.exports.Promise;
        if (typeof Promise2 !== "function") {
          throw new Error("You must provide a Promise polyfill for this library to work in older environments");
        }
        return throat(arguments[0], arguments[1]);
      }
    };
    module2.exports.default = module2.exports;
    if (typeof Promise === "function") {
      module2.exports.Promise = Promise;
    }
    function Delayed(resolve2, fn, self2, args) {
      this.resolve = resolve2;
      this.fn = fn;
      this.self = self2 || null;
      this.args = args;
    }
    function Queue() {
      this._s1 = [];
      this._s2 = [];
    }
    Queue.prototype.push = function(value) {
      this._s1.push(value);
    };
    Queue.prototype.shift = function() {
      var s2 = this._s2;
      if (s2.length === 0) {
        var s1 = this._s1;
        if (s1.length === 0) {
          return;
        }
        this._s1 = s2;
        s2 = this._s2 = s1.reverse();
      }
      return s2.pop();
    };
    Queue.prototype.isEmpty = function() {
      return !this._s1.length && !this._s2.length;
    };
  }
});

// ../node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "../node_modules/run-parallel-limit/index.js"(exports2, module2) {
    module2.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (err)
          isErrored = true;
        if (--pending === 0 || err) {
          done(err);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// ../node_modules/@serverless/platform-client/src/utils.js
var require_utils9 = __commonJS({
  "../node_modules/@serverless/platform-client/src/utils.js"(exports2, module2) {
    "use strict";
    var Axios = require_axios2();
    var traverse = require_traverse();
    var minimatch = require_minimatch();
    var utils = {};
    var sleep = async (wait) => new Promise((resolve2) => setTimeout(() => resolve2(), wait));
    var request = async (options) => {
      const requestOptions = {
        url: options.endpoint,
        method: options.method || "POST",
        headers: {
          "Content-Type": "application/json"
        },
        data: options.data
      };
      if (options.accessKey) {
        requestOptions.headers.authorization = `Bearer ${options.accessKey}`;
      }
      if (options.headers) {
        requestOptions.headers = __spreadValues(__spreadValues({}, requestOptions.headers), options.headers);
      }
      try {
        const axios = Axios.create();
        const res = await axios(requestOptions);
        return res.data;
      } catch (error) {
        if (error.response && error.response.data) {
          const data = error.response.data;
          let message;
          let name;
          if (data.message) {
            ({ message } = data);
            name = data.name || null;
          } else if (data.errorMessage) {
            name = "Error";
            message = data.errorMessage;
          } else if (data.errors && data.errors.length) {
            message = data.errors.map((e) => e.message).join(", ");
            name = data.errors.map((e) => e.name).join(", ");
          }
          const err = new Error(message);
          err.statusCode = data.statusCode || error.response.status || null;
          err.name = name;
          err.details = data.details || null;
          err.url = error.response.config.url || null;
          throw err;
        }
        throw error;
      }
    };
    var resolveInputEnvVariables = (inputs) => {
      const regex = /\${(\w*:?[\w\d.-]+)}/g;
      let variableResolved = false;
      const resolvedInputs = traverse(inputs).forEach(function(value) {
        const matches = typeof value === "string" ? value.match(regex) : null;
        if (matches) {
          let newValue = value;
          for (const match of matches) {
            if (/\${env:(\w*[\w.-_]+)}/g.test(match)) {
              const referencedPropertyPath = match.substring(2, match.length - 1).split(":");
              newValue = process.env[referencedPropertyPath[1]];
              variableResolved = true;
            }
          }
          this.update(newValue);
        }
      });
      if (variableResolved) {
        return resolveInputEnvVariables(resolvedInputs);
      }
      return resolvedInputs;
    };
    utils.sleep = sleep;
    utils.request = request;
    utils.resolveInputEnvVariables = resolveInputEnvVariables;
    if (typeof window === "undefined") {
      const crypto = require("crypto");
      const path = require("path");
      const fs = require("fs");
      const ignore = require_ignore();
      const AdmZip = require_adm_zip();
      const { parseUrl } = require("url");
      const https = require("https");
      const HttpsProxyAgent = require_dist5();
      const archiver = require_archiver();
      const throat = require_throat();
      const fg = require_out4();
      const runParallelLimit = require_run_parallel_limit();
      const httpsAgent = new https.Agent({
        keepAlive: true
      });
      const axios = Axios.create({
        httpsAgent
      });
      axios.defaults.headers.common = {};
      axios.defaults.headers.put = {};
      axios.defaults.headers.get = {};
      const axiosConfig = {
        maxContentLength: Infinity,
        maxBodyLength: Infinity
      };
      const getAgent = () => {
        const proxy = process.env.proxy || process.env.HTTP_PROXY || process.env.http_proxy || process.env.HTTPS_PROXY || process.env.https_proxy;
        const agentOptions = {};
        if (proxy) {
          Object.assign(agentOptions, parseUrl(proxy));
        }
        const ca = process.env.ca || process.env.HTTPS_CA || process.env.https_ca;
        let caCerts = [];
        if (ca) {
          const caArr = ca.split(",");
          caCerts = caCerts.concat(caArr.map((cert) => cert.replace(/\\n/g, "\n")));
        }
        const cafile = process.env.cafile || process.env.HTTPS_CAFILE || process.env.https_cafile;
        if (cafile) {
          const caPathArr = cafile.split(",");
          caCerts = caCerts.concat(caPathArr.map((cafilePath) => fs.readFileSync(cafilePath.trim())));
        }
        if (caCerts.length > 0) {
          Object.assign(agentOptions, {
            rejectUnauthorized: true,
            ca: caCerts
          });
        }
        if (proxy) {
          return new HttpsProxyAgent(agentOptions);
        } else if (agentOptions.ca) {
          return new https.Agent(agentOptions);
        }
        return void 0;
      };
      const readFiles = async (input, exclude = []) => {
        const inputPath = path.resolve(input);
        const base = path.resolve(process.cwd(), input);
        const files = [];
        let totalSize = 0;
        const readDir = async (dir) => {
          const items = await fs.promises.readdir(dir);
          itemIteration:
            for (const item of items) {
              const itemPath = path.resolve(dir, item);
              const relativeItemPath = path.relative(base, itemPath);
              for (const excludeItem of exclude) {
                if (minimatch(relativeItemPath, excludeItem, { nocase: true, dot: true })) {
                  continue itemIteration;
                }
              }
              const fsItem = await fs.promises.stat(itemPath);
              if (fsItem.isDirectory()) {
                await readDir(itemPath);
              } else {
                totalSize += fsItem.size;
                files.push({ path: relativeItemPath, mode: fsItem.mode });
              }
            }
        };
        await readDir(inputPath);
        return { files, totalSize };
      };
      const resolveGitignoreFilter = async (servicePath) => {
        const gitIgnoreContent = await (async () => {
          try {
            return await fs.promises.readFile(path.resolve(servicePath, ".gitignore"));
          } catch (error) {
            if (error.code === "ENOENT")
              return null;
            throw error;
          }
        })();
        if (!gitIgnoreContent)
          return null;
        const ig = ignore().add(String(gitIgnoreContent).split(/[\r\n]+/));
        return (filePath) => !ig.ignores(filePath);
      };
      const zip = async (inputDirPath, { outputFilePath, includeContent, exclude, shouldFilterByGitignore }) => {
        const archive = archiver("zip", {
          zlib: { level: 9 }
        });
        const [{ files }, gitignoreFilter] = await Promise.all([
          readFiles(inputDirPath, exclude),
          shouldFilterByGitignore && resolveGitignoreFilter(inputDirPath)
        ]);
        function addFileToArchive(file) {
          return new Promise((resolve2) => {
            if (gitignoreFilter && !gitignoreFilter(file.path))
              return;
            const stream2 = fs.createReadStream(path.resolve(inputDirPath, file.path));
            const mode = file.mode & 64 ? 493 : 420;
            archive.append(stream2, {
              name: file.path,
              mode,
              date: new Date(0)
            });
            stream2.on("close", () => resolve2());
          });
        }
        return new Promise((resolve2, reject2) => {
          const output = fs.createWriteStream(outputFilePath);
          output.on("open", async () => {
            try {
              archive.pipe(output);
              await Promise.all(files.map(throat(10, addFileToArchive)));
              if (includeContent) {
                for (const file of includeContent) {
                  archive.append(Buffer.alloc(file.fileContent.length, file.fileContent), {
                    name: file.fileName,
                    date: new Date(0)
                  });
                }
              }
              archive.finalize();
            } catch (err) {
              archive.destroy(err);
            }
          });
          output.on("close", () => resolve2(outputFilePath));
          output.on("error", (err) => reject2(err));
          archive.on("error", (err) => reject2(err));
        });
      };
      const unzip = async (inputZipPath, removeZip) => {
        const destPath = path.join("/tmp", Math.random().toString(36).substring(6));
        const unzipper = new AdmZip(inputZipPath);
        unzipper.extractAllTo(destPath, true);
        if (removeZip) {
          fs.rmdirSync(inputZipPath);
        }
        return destPath;
      };
      const fileExistsSync = (filePath) => {
        try {
          const stats = fs.lstatSync(filePath);
          return stats.isFile();
        } catch (e) {
          return false;
        }
      };
      const getFilesToUpload = (map = {}, previousMap = {}, options) => {
        const filesToUpload = [];
        if (options.force) {
          return Object.keys(map);
        }
        Object.keys(map).forEach((filePath) => {
          if (!previousMap[filePath] || previousMap[filePath] !== map[filePath]) {
            filesToUpload.push(filePath);
          }
        });
        return filesToUpload;
      };
      const getFilesToDelete = (map = {}, previousMap = {}) => {
        const filesToDelete = [];
        Object.keys(previousMap).forEach((filePath) => {
          if (!map[filePath]) {
            filesToDelete.push(filePath);
          }
        });
        return filesToDelete;
      };
      const getPreviousMap = async (previousMapDownloadUrl) => {
        try {
          return (await axios.get(previousMapDownloadUrl, null, axiosConfig)).data;
        } catch (e) {
          return void 0;
        }
      };
      const preCache = async (sdk, { orgName, stageName, appName, instanceName }, options) => {
        const res = await request({
          endpoint: `${sdk.getDomain("engine")}/preCache`,
          accessKey: sdk.accessKey,
          method: "POST",
          data: { orgName, stageName, appName, instanceName }
        });
        if (!options.force) {
          res.previousMap = await getPreviousMap(res.previousMapDownloadUrl);
        }
        return res;
      };
      const getFilesAndMap = async (inputs) => {
        const { srcOriginal } = inputs;
        const { src } = inputs;
        let exclude = [
          ".git",
          "package-lock.json",
          "node_modules/serverless",
          "node_modules/aws-sdk/**/*.d.ts",
          "node_modules/aws-sdk/**/*.examples.json",
          "node_modules/aws-sdk/**/*.md",
          "node_modules/aws-sdk/dist",
          "node_modules/aws-sdk/dist-tools",
          "node_modules/aws-sdk/scripts"
        ];
        if (typeof srcOriginal === "object" && srcOriginal.exclude) {
          exclude = exclude.concat(srcOriginal.exclude);
        }
        const files = {};
        const map = {};
        let bytes = 0;
        await new Promise(async (resolve2, reject2) => {
          const filesPaths = await fg("**/*", { cwd: src, ignore: exclude });
          const tasks = filesPaths.map((filePath) => {
            return (callback) => {
              const absoluteFilePath = path.resolve(src, filePath);
              fs.readFile(absoluteFilePath, (readErr, file) => {
                if (readErr) {
                  callback(readErr);
                  return;
                }
                fs.stat(absoluteFilePath, (statErr, stat) => {
                  if (statErr) {
                    callback(statErr);
                    return;
                  }
                  bytes += stat.size;
                  files[filePath] = {
                    file,
                    stat
                  };
                  map[filePath] = crypto.createHash("md5").update(file).digest("hex");
                  callback();
                });
              });
            };
          });
          runParallelLimit(tasks, 2048, (err) => {
            if (err) {
              reject2(err);
            } else {
              resolve2();
            }
          });
        });
        return { map, files, bytes };
      };
      const zipChanges = async (filesToUpload, filesToDelete, map, files) => {
        if (filesToUpload.length === 0 && filesToDelete.length === 0) {
          return null;
        }
        const archive = new AdmZip();
        if (filesToDelete.length !== 0) {
          const filesToDeleteContent = JSON.stringify(filesToDelete);
          archive.addFile("deleted.files", Buffer.alloc(filesToDeleteContent.length, filesToDeleteContent));
        }
        const mapContent = JSON.stringify(map);
        archive.addFile("src.map", Buffer.alloc(mapContent.length, mapContent));
        for (const filePath of filesToUpload) {
          const mode = files[filePath].stat.mode & 64 ? 493 : 420;
          archive.addFile(filePath, files[filePath].file, null, mode);
        }
        return archive.toBuffer();
      };
      const cache = async (sdk, instance, options) => {
        const [{ map, files, bytes }, { previousMap, changesUploadUrl, srcDownloadUrl }] = await Promise.all([getFilesAndMap(instance.inputs), preCache(sdk, instance, options)]);
        const filesToUpload = getFilesToUpload(map, previousMap, options);
        const filesToDelete = getFilesToDelete(map, previousMap, options);
        if (filesToUpload.length !== 0 || filesToDelete.length !== 0) {
          options.cacheOutdated = true;
          const zipBuffer = await zipChanges(filesToUpload, filesToDelete, map, files);
          await axios.put(changesUploadUrl, zipBuffer, axiosConfig);
        } else {
          options.cacheOutdated = false;
        }
        return { srcDownloadUrl, bytes };
      };
      utils.getAgent = getAgent;
      utils.zip = zip;
      utils.unzip = unzip;
      utils.fileExistsSync = fileExistsSync;
      utils.cache = cache;
    }
    module2.exports = utils;
  }
});

// ../node_modules/@serverless/platform-client/src/resources.js
var require_resources = __commonJS({
  "../node_modules/@serverless/platform-client/src/resources.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var getUser = async (sdk) => {
      const endpoint = `${sdk.getDomain("core")}/core/me`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getUserMeta = async (sdk) => {
      const endpoint = `${sdk.getDomain("core")}/core/users/meta`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var saveUserMeta = async (sdk, newMeta = {}) => {
      const existingMeta = await getUserMeta(sdk);
      newMeta = Object.assign(existingMeta || {}, newMeta);
      const endpoint = `${sdk.getDomain("core")}/core/users/meta`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: newMeta
      });
    };
    var validateUserAndOrgName = async (sdk, userAndOrgName) => {
      const endpoint = `${sdk.getDomain("core")}/core/validate/tenants`;
      const res = await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          ownerUserName: userAndOrgName,
          title: userAndOrgName,
          tenantName: userAndOrgName
        }
      });
      if (res && res.validationErrors && res.validationErrors.length) {
        return res.validationErrors;
      }
      return null;
    };
    var createOrg = async (sdk, userAndOrgName) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          ownerUserName: userAndOrgName,
          title: userAndOrgName,
          tenantName: userAndOrgName
        }
      });
    };
    var createUserAndOrg = async (sdk, userAndOrgName) => {
      return await createOrg(sdk, userAndOrgName);
    };
    var getOrgByName = async (sdk, orgName) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var listOrgs = async (sdk, username) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants?userName=${username}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var createApp = async (sdk, orgName = null, app = {}) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          tenantName: orgName,
          appName: app.name,
          title: app.name,
          description: app.description,
          deploymentProfiles: app.deploymentProfiles
        }
      });
    };
    var updateApp = async (sdk, orgName = null, app = {}) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${app.name}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "PATCH",
        data: {
          appName: app.name,
          title: app.name,
          description: app.description,
          deploymentProfiles: app.deploymentProfiles
        }
      });
    };
    var deleteApp = async (sdk, orgName = null, appName = null) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "DELETE"
      });
    };
    var listApps = async (sdk, orgName = null) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var createInitToken = async (sdk, orgName = null, data) => {
      const endpoint = `${sdk.getDomain("core")}/core/initTokens`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: __spreadValues({
          tenantName: orgName
        }, data)
      });
    };
    var getInitToken = async (sdk, tokenUid) => {
      const endpoint = `${sdk.getDomain("core")}/core/initTokens/${tokenUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getProviders = async (sdk, orgUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var createProvider = async (sdk, orgUid, data) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data
      });
    };
    var getProvider = async (sdk, orgUid, providerUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers/${providerUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var updateProvider = async (sdk, orgUid, providerUid, data) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers/${providerUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "PUT",
        data
      });
    };
    var setDefaultProvider = async (sdk, orgUid, providerUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers/${providerUid}/set-default`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST"
      });
    };
    var unsetDefaultProvider = async (sdk, orgUid, providerUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers/${providerUid}/set-default/?isDefault=false`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST"
      });
    };
    var deleteProvider = async (sdk, orgUid, providerUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/providers/${providerUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "DELETE"
      });
    };
    var createProviderLink = async (sdk, orgUid, linkType, linkUid, providerUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          providerUid
        }
      });
    };
    var deleteProviderLink = async (sdk, orgUid, linkType, linkUid, providerUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}/providers/${providerUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "DELETE"
      });
    };
    var getProvidersByLink = async (sdk, orgUid, linkType, linkUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getProvidersByOrgServiceInstance = async (sdk, orgUid, serviceUid, instanceUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/services/${encodeURI(serviceUid)}/instances/${encodeURI(instanceUid)}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getAllowedProviders = async (sdk) => {
      const endpoint = `${sdk.getDomain("providers")}/providers`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var createParam = async (sdk, orgUid, linkType, linkUid, data) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}/params`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data
      });
    };
    var deleteParam = async (sdk, orgUid, linkType, linkUid, paramUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}/params/${paramUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "DELETE"
      });
    };
    var updateParam = async (sdk, orgUid, linkType, linkUid, paramUid, data) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}/params/${paramUid}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "PUT",
        data
      });
    };
    var getParams = async (sdk, orgUid, linkType, linkUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/${linkType}s/${encodeURI(linkUid)}/params`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getParamsByOrgServiceInstance = async (sdk, orgUid, serviceUid, instanceUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/services/${encodeURI(serviceUid)}/instances/${encodeURI(instanceUid)}/params`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getParamsAndProvidersByOrgServiceInstance = async (sdk, orgUid, serviceUid, instanceUid) => {
      const endpoint = `${sdk.getDomain("providers")}/orgs/${orgUid}/services/${encodeURI(serviceUid)}/instances/${encodeURI(instanceUid)}/params-and-providers`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    module2.exports = {
      getUser,
      getUserMeta,
      saveUserMeta,
      validateUserAndOrgName,
      createUserAndOrg,
      createOrg,
      getOrgByName,
      listOrgs,
      createApp,
      updateApp,
      deleteApp,
      listApps,
      createInitToken,
      getInitToken,
      getProviders,
      getProvider,
      getProvidersByOrgServiceInstance,
      createProvider,
      updateProvider,
      setDefaultProvider,
      unsetDefaultProvider,
      deleteProvider,
      createProviderLink,
      deleteProviderLink,
      getProvidersByLink,
      getAllowedProviders,
      createParam,
      deleteParam,
      getParams,
      updateParam,
      getParamsByOrgServiceInstance,
      getParamsAndProvidersByOrgServiceInstance
    };
  }
});

// ../node_modules/@serverless/platform-client/src/Connection.js
var require_Connection = __commonJS({
  "../node_modules/@serverless/platform-client/src/Connection.js"(exports2, module2) {
    "use strict";
    var WS = require_node3();
    var Connection = class {
      constructor(sdk) {
        this.sdk = sdk;
        this.connection = null;
        this.context = {};
      }
      isConnected() {
        return !!this.connection;
      }
      async connect(options) {
        const self2 = this;
        if (options.orgName) {
          this.sdk.context.orgName = options.orgName;
        }
        if (options.orgUid) {
          this.sdk.context.orgUid = options.orgUid;
        }
        if (!this.sdk.context.orgName && !this.sdk.context.orgUid) {
          throw new Error('You must specify an "orgName" or "orgUid" to connect');
        }
        options.filter = options.filter || {};
        options.filter.stageName = options.filter.stageName ? options.filter.stageName.trim() : null;
        options.filter.appName = options.filter.appName ? options.filter.appName.trim() : null;
        options.filter.instanceName = options.filter.instanceName ? options.filter.instanceName.trim() : null;
        options.filter.events = options.filter.events || ["*"];
        let queryParams = "?";
        queryParams += `accessKey=${this.sdk.accessKey}&`;
        if (this.sdk.context.orgName) {
          queryParams += `orgName=${this.sdk.context.orgName}&`;
        }
        if (this.sdk.context.orgUid) {
          queryParams += `orgUid=${this.sdk.context.orgUid}&`;
        }
        queryParams += `filter=${encodeURIComponent(JSON.stringify(options.filter))}&`;
        const domain = this.sdk.getDomain("events-streaming") + queryParams;
        this.connection = new WS(domain);
        if (options.onEvent) {
          this.connection.onmessage = (message) => {
            message = message && message.data ? message.data : null;
            if (typeof message === "string") {
              message = JSON.parse(message);
            }
            return options.onEvent(message);
          };
        }
        this.connection.onclose = (closeEvent) => {
          clearInterval(this.pingInterval);
          this.pingInterval = null;
          if (closeEvent.code !== 1e3) {
            return self2.connect(options);
          }
          if (options.onDisconnect) {
            return options.onDisconnect(closeEvent);
          }
          return null;
        };
        return new Promise((resolve2, reject2) => {
          if (options.onError) {
            self2.connection.onerror = options.onError;
          } else {
            self2.connection.onerror = (error) => {
              return reject2(new Error(`Unexpected Serverless Platform Streaming Error: ${error.message}`));
            };
          }
          self2.connection.onopen = () => {
            if (this.connection.ping) {
              this.pingInterval = setInterval(() => {
                this.pingTimeout = setTimeout(() => {
                  clearInterval(this.pingInterval);
                  this.pingInterval = null;
                  this.connection.terminate();
                  this.connection = null;
                }, 500);
                if (this.connection) {
                  this.connection.ping();
                }
              }, 1e3);
              this.connection.on("pong", () => {
                clearTimeout(this.pingTimeout);
                this.pingTimeout = null;
              });
            }
            return resolve2();
          };
        });
      }
      send(data) {
        this.connection.send(data);
      }
      disconnect(code) {
        if (this.connection) {
          if (this.pingInterval) {
            clearTimeout(this.pingInterval);
            this.pingInterval = null;
          }
          if (this.pingTimeout) {
            clearTimeout(this.pingTimeout);
            this.pingTimeout = null;
          }
          this.connection.close(code || 1e3);
          this.connection = null;
        }
      }
    };
    module2.exports = Connection;
  }
});

// ../node_modules/@serverless/platform-client/src/registry.js
var require_registry = __commonJS({
  "../node_modules/@serverless/platform-client/src/registry.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var { tmpdir } = require("os");
    var axios = require_axios2();
    var utils = require_utils9();
    var validateAndFormat = (registryPackageRaw) => {
      const registryPackage = Object.assign({}, registryPackageRaw);
      if (!registryPackage.name) {
        throw new Error("The 'name' property is required");
      }
      if (!registryPackage.version) {
        throw new Error("The 'version' property is required");
      }
      if (registryPackage.version === "dev") {
        registryPackage.version = "0.0.0-dev";
      }
      if (registryPackage.org) {
        registryPackage.orgName = registryPackage.org;
        delete registryPackage.org;
      }
      if (!registryPackage.orgName) {
        throw new Error("'orgName' is required");
      }
      if (!registryPackage.src) {
        throw new Error("'src' is required");
      }
      if (!registryPackage.type) {
        throw new Error("'type' is required");
      }
      if (registryPackage.providers) {
        registryPackage.types = registryPackage.types || {};
        registryPackage.types.providers = registryPackage.providers;
        delete registryPackage.providers;
      }
      if (registryPackage.actions) {
        registryPackage.types = registryPackage.types || {};
        registryPackage.types.actions = registryPackage.actions;
        delete registryPackage.actions;
      }
      return registryPackage;
    };
    var omit = (content, propsToOmit = []) => {
      for (const prop of propsToOmit) {
        const omitRegex = new RegExp(`^${prop}\\s*:\\s+.*$`, "m");
        content = content.replace(omitRegex, () => "");
      }
      return content.replace(/(\r\n|\r|\n){2,}/g, "$1\n");
    };
    var getConfigFile = async (directoryPath, propsToOmit) => {
      const directoryName = path.basename(directoryPath);
      directoryPath = path.resolve(directoryPath);
      const ymlFilePath = path.join(directoryPath, "serverless.yml");
      const yamlFilePath = path.join(directoryPath, "serverless.yaml");
      const jsonFilePath = path.join(directoryPath, "serverless.json");
      let filePath;
      if (utils.fileExistsSync(ymlFilePath)) {
        filePath = ymlFilePath;
      }
      if (utils.fileExistsSync(yamlFilePath)) {
        filePath = yamlFilePath;
      }
      if (utils.fileExistsSync(jsonFilePath)) {
        filePath = jsonFilePath;
      }
      if (!filePath) {
        return null;
      }
      const fileName = path.join(directoryName, path.basename(filePath));
      const fileContent = await fs.promises.readFile(filePath, "utf-8");
      const configFile = {};
      configFile.fileName = fileName;
      configFile.fileContent = omit(fileContent, propsToOmit);
      return configFile;
    };
    var isDirectory = (fileOrDirPath) => {
      return fs.statSync(fileOrDirPath).isDirectory();
    };
    var getConfigFiles = async (root) => {
      const configFilesPromises = [];
      const propsToOmit = [
        "org",
        "app",
        "service",
        "stage",
        "description",
        "keywords",
        "repo",
        "license",
        "service"
      ];
      const filesOrDirNames = await fs.promises.readdir(root);
      for (const fileOrDirName of filesOrDirNames) {
        const fileOrDirPath = path.join(root, fileOrDirName);
        if (!fileOrDirName.startsWith(".") && isDirectory(fileOrDirPath)) {
          configFilesPromises.push(getConfigFile(fileOrDirPath, propsToOmit));
        }
      }
      const configFiles = (await Promise.all(configFilesPromises)).filter((file) => file !== null);
      const rootConfigFile = await getConfigFile(root, propsToOmit);
      if (rootConfigFile) {
        rootConfigFile.fileName = path.basename(rootConfigFile.fileName);
        if (configFiles.length !== 0) {
          rootConfigFile.doNotInclude = true;
        }
        configFiles.push(rootConfigFile);
      }
      return configFiles;
    };
    var zipPackage = async (registryPackage) => {
      const outputFilePath = path.join(tmpdir(), `${Math.random().toString(36).substring(6)}.zip`);
      let includeContent = [];
      let exclude = [];
      if (registryPackage.type === "component") {
        includeContent.push({
          fileName: "_handler.js",
          fileContent: "const { handler } = require('@serverless/core');module.exports.handler = handler;"
        });
      } else {
        exclude.push("**/serverless.template.yml");
        exclude.push("**/node_modules/**");
        exclude.push("**/.env");
        exclude.push("**/.env.*");
        exclude.push("**/.git/**");
      }
      const configFiles = await getConfigFiles(registryPackage.src);
      const configFilesToInclude = configFiles.filter((packageConfigFile) => !packageConfigFile.doNotInclude);
      includeContent = includeContent.concat(configFilesToInclude);
      const configFilesToExclude = configFiles.map((packageConfigFile) => packageConfigFile.fileName);
      exclude = exclude.concat(configFilesToExclude);
      await utils.zip(registryPackage.src, {
        outputFilePath,
        exclude,
        includeContent,
        shouldFilterByGitignore: registryPackage.type === "template"
      });
      return outputFilePath;
    };
    var publish = async (sdk, registryPackage) => {
      registryPackage = validateAndFormat(registryPackage);
      const preResponse = await utils.request({
        endpoint: `${sdk.getDomain("registry")}/packages/prePublish`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: registryPackage
      });
      const { packageUploadUrl, packageKey } = preResponse;
      const registryPackagePath = await zipPackage(registryPackage);
      const request = axios.create();
      request.defaults.headers.common = {};
      request.defaults.headers.put = {};
      const file = fs.readFileSync(registryPackagePath);
      const config = {
        maxContentLength: Infinity,
        maxBodyLength: Infinity
      };
      await request.put(packageUploadUrl, file, config);
      return utils.request({
        endpoint: `${sdk.getDomain("registry")}/packages/postPublish`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: {
          orgName: registryPackage.orgName,
          packageKey
        }
      });
    };
    var unpublish = async (sdk, { name, version, org }) => {
      const endpoint = `${sdk.getDomain("registry")}/packages/${name}/${version}`;
      return utils.request({
        endpoint,
        accessKey: sdk.accessKey,
        method: "DELETE",
        headers: {
          org
        }
      });
    };
    var get = async (sdk, name, version) => {
      let endpoint = `${sdk.getDomain("registry")}/packages`;
      if (name) {
        endpoint = `${endpoint}/${name}`;
      }
      if (version) {
        endpoint = `${endpoint}/${version}`;
      }
      const data = await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
      delete data.componentName;
      delete data.component;
      delete data.componentDefinition;
      if (data.type === "template") {
        delete data.version;
        delete data.versions;
      }
      return data;
    };
    module2.exports = {
      get,
      publish,
      unpublish
    };
  }
});

// ../node_modules/@serverless/platform-client/src/instance.js
var require_instance = __commonJS({
  "../node_modules/@serverless/platform-client/src/instance.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var exec = require("child_process").exec;
    var utils = require_utils9();
    var generateId = (orgUid, stageName, appUid, instanceName) => {
      if (!orgUid || !stageName || !appUid || !instanceName) {
        throw new Error("'orgUid' 'stageName' 'appUid' and 'instanceName' are required");
      }
      return `${orgUid}.${stageName}.${appUid}.${instanceName}`;
    };
    var create = (orgName = null, stageName = null, appName = null, instanceName = null, instanceStatus = "inactive") => {
      if (!orgName || !stageName || !appName || !instanceName) {
        throw new Error("'orgName' 'stageName' 'appName' and 'instanceName' are required");
      }
      const instance = {};
      instance.orgName = orgName;
      instance.appName = appName;
      instance.stageName = stageName;
      instance.instanceName = instanceName;
      instance.componentName = null;
      instance.componentVersion = null;
      instance.inputs = {};
      instance.outputs = {};
      instance.state = {};
      instance.description = null;
      instance.instanceStatus = instanceStatus;
      instance.deploymentError = null;
      instance.deploymentErrorStack = null;
      instance.lastAction = null;
      instance.createdAt = Date.now();
      instance.updatedAt = Date.now();
      instance.lastDeployedAt = null;
      instance.lastActionAt = null;
      instance.instanceMetrics = {};
      instance.instanceMetrics.actions = 0;
      instance.instanceMetrics.deployments = 0;
      instance.instanceMetrics.removes = 0;
      instance.instanceMetrics.errors = 0;
      return instance;
    };
    var validateAndFormat = (rawInstance) => {
      const instance = JSON.parse(JSON.stringify(rawInstance));
      if (instance.org) {
        instance.orgName = instance.org;
        delete instance.org;
      }
      if (instance.stage) {
        instance.stageName = instance.stage;
        delete instance.stage;
      }
      if (instance.app) {
        instance.appName = instance.app;
        delete instance.app;
      }
      if (instance.name) {
        instance.instanceName = instance.name;
        delete instance.name;
      }
      if (!instance.orgName || !instance.stageName || !instance.appName || !instance.instanceName) {
        throw new Error("'orgName' 'stageName' 'appName' and 'instanceName' are required");
      }
      if (instance.component) {
        instance.componentName = instance.component.includes("@") ? instance.component.split("@")[0] : instance.component;
        instance.componentVersion = instance.component.includes("@") ? instance.component.split("@")[1] : "";
        delete instance.component;
      }
      if (!instance.componentName) {
        throw new Error("'componentName' is required");
      }
      if (!instance.inputs) {
        instance.inputs = {};
      }
      return instance;
    };
    var save = async (sdk, instance = {}) => {
      instance = validateAndFormat(instance);
      return utils.request({
        endpoint: `${sdk.getDomain("engine")}/saveInstance`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: {
          instance
        }
      });
    };
    var getByName = async (sdk, orgName = null, stageName = null, appName = null, instanceName = null) => {
      return utils.request({
        endpoint: `${sdk.getDomain("engine")}/getInstance`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: {
          orgName,
          appName,
          stageName,
          instanceName
        }
      });
    };
    var listByOrgName = async (sdk, orgName = null, orgUid = null) => {
      return utils.request({
        endpoint: `${sdk.getDomain("engine")}/listInstances`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: {
          orgName,
          orgUid
        }
      });
    };
    var preRunSrcHook = async (src) => {
      if (typeof src === "object" && src.hook && src.dist) {
        const options = { cwd: src.src, env: src.env };
        return new Promise((resolve2, reject2) => {
          exec(src.hook, options, (err) => {
            if (err) {
              return reject2(new Error(`Failed running "src.hook": "${src.hook}" due to the following error: ${err.message}`));
            }
            return resolve2(src.dist);
          });
        });
      } else if (typeof src === "object" && src.src) {
        src = path.resolve(src.src);
      } else if (typeof src === "string") {
        src = path.resolve(src);
      }
      return src;
    };
    var run = async (sdk, method = {}, instanceData = {}, options = {}) => {
      let instance = JSON.parse(JSON.stringify(instanceData));
      if (!method) {
        throw new Error('A "method" argument is required');
      }
      instance = validateAndFormat(instanceData);
      let size;
      if (instance.inputs.src) {
        let p = instance.inputs.src;
        if (typeof p !== "string" && p.dist) {
          p = p.dist;
        } else if (typeof p !== "string" && p.src) {
          p = p.src;
        }
        if (instance.inputs.src) {
          instance.inputs.srcOriginal = JSON.parse(JSON.stringify(instance.inputs.src));
        }
        instance.inputs.src = await preRunSrcHook(instance.inputs.src);
        if (process.argv.includes("--force")) {
          options.force = true;
        }
        const { srcDownloadUrl, bytes } = await utils.cache(sdk, instance, options);
        if (bytes > 2e8) {
          throw new Error("Your code size must be less than 200MB.  Try using Webpack, Parcel, or AWS Lambda layers to reduce your code size.");
        }
        instance.inputs.src = srcDownloadUrl;
        size = bytes;
      }
      return utils.request({
        endpoint: `${sdk.getDomain("engine")}/run`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: {
          method,
          instance,
          options,
          size
        }
      });
    };
    var runFinish = async (sdk, method = null, instance = {}, meta = {}) => {
      return utils.request({
        endpoint: `${sdk.getDomain("engine")}/runFinish`,
        accessKey: sdk.accessKey,
        method: "POST",
        data: {
          method,
          instance,
          meta
        }
      });
    };
    var deploy = async (sdk, instance, options) => {
      options.timeout = options.timeout || 24e4;
      options.interval = options.interval || 500;
      const startedAt = Date.now();
      await run(sdk, "deploy", instance, options);
      const poll = async () => {
        if (Date.now() - options.timeout > startedAt) {
          throw new Error(`Request timed out after ${options.timeout / 6e4} minutes`);
        }
        let instanceRecord = await getByName(sdk, instance.orgName || instance.org, instance.stageName || instance.stage, instance.appName || instance.app, instance.instanceName || instance.name);
        instanceRecord = instanceRecord.instance;
        if (instanceRecord.instanceStatus === "active") {
          return instanceRecord;
        } else if (instanceRecord.instanceStatus === "error") {
          const error = new Error(instanceRecord.deploymentError);
          error.stack = instanceRecord.deploymentErrorStack;
          throw error;
        }
        await utils.sleep(options.interval);
        return poll();
      };
      return poll();
    };
    var remove = async (sdk, instance, options) => {
      options.timeout = options.timeout || 6e4;
      options.interval = options.interval || 500;
      const startedAt = Date.now();
      await run(sdk, "remove", instance, options);
      const poll = async () => {
        if (Date.now() - options.timeout > startedAt) {
          throw new Error(`Request timed out after ${options.timeout / 1e3} seconds`);
        }
        let instanceRecord = await getByName(sdk, instance.orgName || instance.org, instance.stageName || instance.stage, instance.appName || instance.app, instance.instanceName || instance.name);
        instanceRecord = instanceRecord.instance;
        if (instanceRecord.instanceStatus === "inactive") {
          return instanceRecord;
        } else if (instanceRecord.instanceStatus === "error") {
          const error = new Error(instanceRecord.deploymentError);
          error.stack = instanceRecord.deploymentErrorStack;
          throw error;
        }
        await utils.sleep(options.interval);
        return poll();
      };
      return poll();
    };
    module2.exports = {
      generateId,
      validateAndFormat,
      create,
      save,
      getByName,
      listByOrgName,
      run,
      runFinish,
      deploy,
      remove
    };
  }
});

// ../node_modules/@serverless/platform-client/src/events.js
var require_events = __commonJS({
  "../node_modules/@serverless/platform-client/src/events.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    function validate(event) {
      if (!event) {
        throw new Error('An "event" is required');
      }
      if (typeof event !== "object") {
        throw new Error('The "event" argument must be an object');
      }
      const validateObject = ({ event: type }) => {
        if (!type || typeof type !== "string") {
          throw new Error('The "event" property containing the event type is required and must be a string');
        }
      };
      if (Array.isArray(event)) {
        if (!event.length) {
          throw new Error("Event batch must be non empty");
        }
        let orgUid;
        let orgName;
        event.forEach((object) => {
          validateObject(object);
          if (orgUid && (object.org_uid || object.orgUid) && orgUid !== (object.org_uid || object.orgUid)) {
            throw new Error("All events in batch must belong to the same org uid");
          }
          if (orgName && (object.org_name || object.orgName) && orgName !== (object.org_name || object.orgName)) {
            throw new Error("All events in batch must belong to the same org name");
          }
          orgUid = object.org_uid || object.orgUid || orgUid;
          orgName = object.org_name || object.orgName || orgName;
        });
        if (orgUid) {
          event[0].orgUid = event[0].org_uid = orgUid;
        }
        if (orgName) {
          event[0].orgName = event[0].org_name = orgName;
        }
      } else {
        validateObject(event);
      }
      return event;
    }
    function transform(event, context, accessKey) {
      const safeEvent = (object) => ({
        event: object.event.trim(),
        user_uid: object.user_uid || object.userUid,
        stage_name: object.stage_name || object.stageName,
        app_name: object.app_name || object.appName,
        instance_name: object.instance_name || object.instanceName,
        component_name: object.component_name || object.componentName,
        component_version: object.component_version || object.componentVersion,
        data: object.data || {},
        created: object.created || Date.now()
      });
      let transformed;
      if (Array.isArray(event)) {
        const safe = safeEvent({
          event: "batch",
          data: event.map((object) => safeEvent(object))
        });
        transformed = __spreadProps(__spreadValues({}, safe), {
          org_uid: event[0].orgUid || context.orgUid,
          org_name: event[0].orgName || context.orgName,
          stage_name: context.stageName,
          app_name: context.appName,
          instance_name: context.instanceName,
          component_name: context.componentName,
          component_version: context.componentVersion
        });
      } else {
        const safe = safeEvent(event);
        transformed = __spreadProps(__spreadValues({}, safe), {
          org_uid: event.org_uid || event.orgUid || context.orgUid,
          org_name: event.org_name || event.orgName || context.orgName,
          stage_name: safe.stage_name || context.stageName,
          app_name: safe.app_name || context.appName,
          instance_name: safe.instance_name || context.instanceName,
          component_name: safe.component_name || context.componentName,
          component_version: safe.component_version || context.componentVersion
        });
      }
      if (!transformed.org_name && !transformed.org_uid) {
        throw new Error("Both event and SDK context are missing an org uid or name");
      }
      return __spreadProps(__spreadValues({}, transformed), {
        access_key: accessKey
      });
    }
    module2.exports.send = (event, connection, context, accessKey) => {
      const safe = transform(validate(event), context, accessKey);
      if (!connection || !connection.isConnected()) {
        throw new Error("You are not currently connected to the Serverless Platform.");
      }
      connection.send(JSON.stringify(safe));
    };
    module2.exports.publish = (event, domain, context, accessKey) => {
      return utils.request({
        endpoint: `${domain}/publish`,
        accessKey,
        method: "POST",
        data: transform(validate(event), context)
      });
    };
    module2.exports.get = (eventUid, domain, accessKey) => {
      return utils.request({
        endpoint: `${domain}/events/${eventUid}`,
        accessKey,
        method: "GET"
      });
    };
    module2.exports.list = (domain, context, accessKey, options = {}) => {
      const {
        org_name: orgName = null,
        org_uid: orgUid = null,
        event = "*",
        limit = 10,
        created,
        starting_after: startingAfter
      } = options;
      const params = new URLSearchParams({ event, limit });
      if (orgUid) {
        params.append("org_uid", orgUid);
      } else if (orgName) {
        params.append("org_name", orgName);
      } else if (context.orgUid) {
        params.append("org_uid", context.orgUid);
      } else if (context.orgName) {
        params.append("org_name", context.orgName);
      }
      if (!params.has("org_uid") && !params.has("org_name")) {
        throw new Error("Must pass in options or set SDK context for `org_uid`/`org_name`");
      }
      if (created) {
        if (new Set(["number", "string"]).has(typeof created)) {
          params.append("created.gt", created);
        } else if (typeof event !== "object") {
          let valid = false;
          for (const comparator of ["gt", "gte", "lt", "lte"]) {
            if (created[comparator]) {
              params.append(`created.${comparator}`, created[comparator]);
              valid = true;
              break;
            }
          }
          if (!valid) {
            throw new Error("The 'created' dictionary parameter must have one of [gt|gte|lt|lte] set");
          }
        } else {
          throw new Error("The 'created' parameter must be either a integer Unix timestamp or a dictionary");
        }
      }
      if (startingAfter) {
        params.append("starting_after", startingAfter);
      }
      return utils.request({
        endpoint: `${domain}/events?${params.toString()}`,
        accessKey,
        method: "GET"
      });
    };
  }
});

// ../node_modules/@serverless/platform-client/src/webhooks.js
var require_webhooks = __commonJS({
  "../node_modules/@serverless/platform-client/src/webhooks.js"(exports2, module2) {
    "use strict";
    var querystring = require("querystring");
    var utils = require_utils9();
    var register = (sdk, url, options = {}) => {
      if (!options.org_uid && !sdk.context.orgUid && !options.org_name && !sdk.context.orgName) {
        throw new Error("Must pass in options or set SDK context for `org_uid`/`org_name`");
      }
      return utils.request({
        endpoint: `${sdk.getDomain("event-webhooks")}/webhooks`,
        method: "POST",
        accessKey: sdk.accessKey,
        data: {
          url,
          org_uid: options.org_uid || sdk.context.orgUid,
          org_name: options.org_name || sdk.context.orgName,
          description: options.description,
          filter: options.filter
        }
      });
    };
    var list = (sdk, startingAfter, limit) => {
      return utils.request({
        endpoint: `${sdk.getDomain("event-webhooks")}/webhooks?${querystring.stringify({
          org_uid: sdk.context.orgUid,
          org_name: sdk.context.orgName,
          starting_after: startingAfter,
          limit
        })}`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var get = (sdk, uid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("event-webhooks")}/webhooks/${uid}`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var update = (sdk, uid, updates) => {
      return utils.request({
        endpoint: `${sdk.getDomain("event-webhooks")}/webhooks/${uid}`,
        method: "POST",
        data: {
          url: updates.url,
          description: updates.description,
          filter: updates.filter,
          status: updates.status
        },
        accessKey: sdk.accessKey
      });
    };
    var remove = (sdk, uid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("event-webhooks")}/webhooks/${uid}`,
        method: "DELETE",
        accessKey: sdk.accessKey
      });
    };
    module2.exports = {
      register,
      list,
      get,
      update,
      remove
    };
  }
});

// ../node_modules/@serverless/platform-client/src/accessKeys.js
var require_accessKeys = __commonJS({
  "../node_modules/@serverless/platform-client/src/accessKeys.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var create = (sdk, orgName, userName, accessKeyName) => {
      if (!sdk.accessKey) {
        throw new Error('An "accessKey" is required to create other Access Keys.');
      }
      if (!orgName) {
        throw new Error('An "orgName" is required to determine which Serverless Organization you would like to create an Access Key for.');
      }
      if (!userName) {
        throw new Error('A "userName" is required to determine which User within the Serverless Organization you would like to create an Access Key for.');
      }
      if (!accessKeyName) {
        throw new Error('An "accessKeyName" is required to name this Serverless Organization Access Key.');
      }
      return utils.request({
        endpoint: `${sdk.getDomain("core")}/core/tenants/${orgName}/accessKeys`,
        method: "POST",
        accessKey: sdk.accessKey,
        data: {
          userName,
          title: accessKeyName
        }
      });
    };
    var list = (sdk, orgName) => {
      if (!sdk.accessKey) {
        throw new Error('An "accessKey" is required to list Access Keys.');
      }
      if (!orgName) {
        throw new Error('An "orgName" is required to determine which Serverless Organization you would like to list Access Keys.');
      }
      return utils.request({
        endpoint: `${sdk.getDomain("core")}/core/tenants/${orgName}/accessKeys`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var remove = (sdk, orgName, uid) => {
      if (!sdk.accessKey) {
        throw new Error('An "accessKey" is required to destroy Access Keys.');
      }
      if (!orgName) {
        throw new Error('An "orgName" is required to determine which Serverless Organization has the Access Key you would like to destroy.');
      }
      if (!uid) {
        throw new Error('A "uid" is required to determine which Serverless Organization Access Key you would like to destroy.');
      }
      return utils.request({
        endpoint: `${sdk.getDomain("core")}/core/tenants/${orgName}/accessKeys/${uid}`,
        method: "DELETE",
        accessKey: sdk.accessKey
      });
    };
    var get = async (sdk) => {
      const response = await utils.request({
        endpoint: `${sdk.getDomain("core")}/core/tenants/accessKey/meta`,
        method: "GET",
        accessKey: sdk.accessKey
      });
      return response.result;
    };
    module2.exports = {
      create,
      list,
      remove,
      get
    };
  }
});

// ../node_modules/@serverless/platform-client/src/connections.js
var require_connections = __commonJS({
  "../node_modules/@serverless/platform-client/src/connections.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var create = (sdk, orgUid, providerUid, accountAlias) => {
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/connections`,
        method: "POST",
        accessKey: sdk.accessKey,
        data: {
          providerUid,
          accountAlias
        }
      });
    };
    var list = (sdk, orgUid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/connections`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var get = (sdk, orgUid, connectionUid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/connections/${connectionUid}`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var getByOrgAndAccountAlias = (sdk, orgUid, accountAlias) => {
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/connectionAlias/${accountAlias}`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var update = (sdk, orgUid, connectionUid, providerUid, accountAlias, status) => {
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/connections/${connectionUid}`,
        method: "PUT",
        accessKey: sdk.accessKey,
        data: {
          providerUid,
          accountAlias,
          status
        }
      });
    };
    var remove = (sdk, orgUid, connectionUid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/connections/${connectionUid}`,
        method: "DELETE",
        accessKey: sdk.accessKey
      });
    };
    var syncAll = (sdk, orgUid) => {
      if (!orgUid) {
        throw new Error('An "orgUid" is required.');
      }
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/sync`,
        method: "POST",
        accessKey: sdk.accessKey
      });
    };
    var unsync = (sdk, orgUid, connectionUid) => {
      if (!orgUid) {
        throw new Error('An "orgUid" is required.');
      }
      if (!connectionUid) {
        throw new Error('An "connectionUid" is required.');
      }
      return utils.request({
        endpoint: `${sdk.getDomain("connections")}/orgs/${orgUid}/unsync/${connectionUid}`,
        method: "POST",
        accessKey: sdk.accessKey
      });
    };
    module2.exports = {
      create,
      list,
      get,
      getByOrgAndAccountAlias,
      update,
      remove,
      syncAll,
      unsync
    };
  }
});

// ../node_modules/@serverless/platform-client/src/desktop.js
var require_desktop = __commonJS({
  "../node_modules/@serverless/platform-client/src/desktop.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var createSavedQuery = async (sdk, orgUid, appUid, serviceName, params) => {
      return utils.request({
        endpoint: `${sdk.getDomain("desktop")}/orgs/${orgUid}/apps/${appUid}/services/${serviceName}/savedQueries`,
        method: "POST",
        accessKey: sdk.accessKey,
        data: params
      });
    };
    var getSavedQuery = async (sdk, orgUid, appUid, serviceName, savedQueryUid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("desktop")}/orgs/${orgUid}/apps/${appUid}/services/${serviceName}/savedQueries/${savedQueryUid}`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var updateSavedQuery = async (sdk, orgUid, appUid, serviceName, savedQueryUid, params) => {
      return utils.request({
        endpoint: `${sdk.getDomain("desktop")}/orgs/${orgUid}/apps/${appUid}/services/${serviceName}/savedQueries/${savedQueryUid}`,
        method: "PUT",
        accessKey: sdk.accessKey,
        data: params
      });
    };
    var deleteSavedQuery = async (sdk, orgUid, appUid, serviceName, savedQueryUid) => {
      return utils.request({
        endpoint: `${sdk.getDomain("desktop")}/orgs/${orgUid}/apps/${appUid}/services/${serviceName}/savedQueries/${savedQueryUid}`,
        method: "DELETE",
        accessKey: sdk.accessKey
      });
    };
    var listSavedQueries = async (sdk, orgUid, appUid, serviceName) => {
      return utils.request({
        endpoint: `${sdk.getDomain("desktop")}/orgs/${orgUid}/apps/${appUid}/services/${serviceName}/savedQueries`,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    module2.exports = {
      createSavedQuery,
      getSavedQuery,
      updateSavedQuery,
      deleteSavedQuery,
      listSavedQueries
    };
  }
});

// ../node_modules/@serverless/platform-client/src/sessions.js
var require_sessions = __commonJS({
  "../node_modules/@serverless/platform-client/src/sessions.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var refreshToken = async (sdk, refToken) => {
      return await utils.request({
        endpoint: `${sdk.getDomain("core")}/core/tokens/refresh`,
        method: "POST",
        data: {
          refreshToken: refToken
        }
      });
    };
    module2.exports = {
      refreshToken
    };
  }
});

// ../node_modules/@serverless/platform-client/src/apps.js
var require_apps = __commonJS({
  "../node_modules/@serverless/platform-client/src/apps.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var create = async (sdk, { orgName, app }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications`;
      return utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          tenantName: orgName,
          appName: app.name,
          title: app.name,
          description: app.description,
          deploymentProfiles: app.deploymentProfiles
        }
      });
    };
    var get = async (sdk, { orgName, appName }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}`;
      return utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var update = async (sdk, { orgName, app }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${app.name}`;
      return utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "PATCH",
        data: {
          appName: app.name,
          title: app.name,
          description: app.description,
          deploymentProfiles: app.deploymentProfiles
        }
      });
    };
    var remove = async (sdk, { orgName, appName }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}`;
      return utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "DELETE"
      });
    };
    var list = async (sdk, { orgName }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications`;
      return utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    module2.exports = {
      get,
      create,
      update,
      remove,
      list
    };
  }
});

// ../node_modules/@serverless/platform-client/src/services.js
var require_services = __commonJS({
  "../node_modules/@serverless/platform-client/src/services.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var get = async (sdk, { orgName, appName, serviceName }) => {
      if (!orgName) {
        throw new Error('An "orgName" is required to determine Serverless Organization for service');
      }
      if (!appName) {
        throw new Error('An "appName" is required to determine Serverless Application for service');
      }
      if (!serviceName) {
        throw new Error('A "serviceName" is required to determine which service should be returned');
      }
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}/services/${serviceName}`;
      return utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var getStateVariable = async (sdk, { orgName, appName, serviceName, stageName, regionName, variableName }) => {
      if (!orgName) {
        throw new Error('An "orgName" is required to determine Serverless Organization for service');
      }
      if (!appName) {
        throw new Error('An "appName" is required to determine Serverless Application for service');
      }
      if (!serviceName) {
        throw new Error('A "serviceName" is required to determine Service associated with State Variable');
      }
      if (!stageName) {
        throw new Error('A "stageName" is required to determine stage associated with State Variable');
      }
      if (!regionName) {
        throw new Error('A "regionName" is required to determine region associated with State Variable');
      }
      if (!variableName) {
        throw new Error('A "variableName" is required');
      }
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}/services/${serviceName}/stages/${stageName}/regions/${regionName}/outputs`;
      return utils.request({
        endpoint,
        method: "POST",
        accessKey: sdk.accessKey,
        data: {
          outputName: variableName
        }
      });
    };
    module2.exports = {
      get,
      getStateVariable
    };
  }
});

// ../node_modules/@serverless/platform-client/src/logDestinations.js
var require_logDestinations = __commonJS({
  "../node_modules/@serverless/platform-client/src/logDestinations.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var getOrCreate = async (sdk, { orgUid, appUid, serviceName, stageName, regionName, accountId }) => {
      const endpoint = `${sdk.getDomain("core")}/malt/destinations/create`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          tenantUid: orgUid,
          appUid,
          serviceName,
          stageName,
          regionName,
          accountId
        }
      });
    };
    var remove = async (sdk, { orgUid, appUid, serviceName, stageName, regionName }) => {
      const endpoint = `${sdk.getDomain("core")}/malt/destinations/delete`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          tenantUid: orgUid,
          appUid,
          serviceName,
          stageName,
          regionName
        }
      });
    };
    module2.exports = {
      getOrCreate,
      remove
    };
  }
});

// ../node_modules/@serverless/platform-client/src/deploymentProfiles.js
var require_deploymentProfiles = __commonJS({
  "../node_modules/@serverless/platform-client/src/deploymentProfiles.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var get = async (sdk, { orgName, appName, stageName, serviceName }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}/profileValue`;
      const result = await utils.request({
        endpoint,
        method: "POST",
        accessKey: sdk.accessKey,
        data: {
          stageName,
          serviceName
        }
      });
      if (!result) {
        return { secretValues: [], safeguardsPolicies: [], providerCredentials: null };
      }
      return result;
    };
    var list = async (sdk, { orgName }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/deploymentProfiles`;
      return utils.request({
        endpoint,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    var create = async (sdk, {
      profileName,
      orgName,
      description = "A description was not provided for this profile",
      secrets = [],
      safeguardsPolicies = [],
      providerCredentials = null
    }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/deploymentProfiles`;
      return utils.request({
        endpoint,
        method: "POST",
        accessKey: sdk.accessKey,
        data: {
          name: profileName,
          description,
          secrets,
          safeguardsPolicies,
          providerCredentials
        }
      });
    };
    var setDefault = async (sdk, { appName, orgName, profileUid }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}`;
      return utils.request({
        endpoint,
        method: "PATCH",
        accessKey: sdk.accessKey,
        data: {
          deploymentProfiles: { default: profileUid }
        }
      });
    };
    module2.exports = {
      get,
      list,
      create,
      setDefault
    };
  }
});

// ../node_modules/@serverless/platform-client/src/organizations.js
var require_organizations = __commonJS({
  "../node_modules/@serverless/platform-client/src/organizations.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var create = async (sdk, { orgName, username, email, password }) => {
      if (!orgName) {
        throw new Error('An "orgName" is required to create an organization.');
      }
      const endpoint = `${sdk.getDomain("core")}/core/tenants`;
      return utils.request({
        endpoint,
        method: "POST",
        data: {
          ownerUserName: username || orgName,
          ownerPassword: password,
          ownerEmail: email,
          title: orgName,
          tenantName: orgName
        }
      });
    };
    var get = async (sdk, { orgName }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var list = async (sdk, { username }) => {
      const endpoint = `${sdk.getDomain("core")}/core/tenants?userName=${username}`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    var validate = async (sdk, { orgName, username }) => {
      if (!orgName) {
        throw new Error('An "orgName" is required for validation.');
      }
      const endpoint = `${sdk.getDomain("core")}/core/validate/tenants`;
      const res = await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "POST",
        data: {
          ownerUserName: username || orgName,
          title: orgName,
          tenantName: orgName
        }
      });
      if (res && res.validationErrors && res.validationErrors.length) {
        return res.validationErrors;
      }
      return null;
    };
    module2.exports = {
      get,
      list,
      create,
      validate
    };
  }
});

// ../node_modules/@serverless/platform-client/src/metadata.js
var require_metadata = __commonJS({
  "../node_modules/@serverless/platform-client/src/metadata.js"(exports2, module2) {
    "use strict";
    var utils = require_utils9();
    var get = async (sdk) => {
      const endpoint = `${sdk.getDomain("core")}/core/meta`;
      return await utils.request({
        accessKey: sdk.accessKey,
        endpoint,
        method: "GET"
      });
    };
    module2.exports = {
      get
    };
  }
});

// ../node_modules/@serverless/platform-client/src/frameworkDeployments.js
var require_frameworkDeployments = __commonJS({
  "../node_modules/@serverless/platform-client/src/frameworkDeployments.js"(exports2, module2) {
    "use strict";
    var querystring = require("querystring");
    var utils = require_utils9();
    var create = async (sdk, { orgName, appName, serviceName, stageName, regionName, deploymentData }) => {
      if (!orgName) {
        throw new Error('An "orgName" is required to determine Serverless Organization for service');
      }
      if (!appName) {
        throw new Error('An "appName" is required to determine Serverless Application for service');
      }
      if (!serviceName) {
        throw new Error('A "serviceName" is required to determine which service should be archived');
      }
      if (!stageName) {
        throw new Error('A "stageName" is required');
      }
      if (!regionName) {
        throw new Error('A "regionName" is required');
      }
      if (!deploymentData) {
        throw new Error('A "deploymentData" is required');
      }
      const data = __spreadValues({
        tenantName: orgName,
        appName,
        serviceName,
        stageName,
        regionName
      }, deploymentData);
      const endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}/services/${serviceName}/stages/${stageName}/regions/${regionName}/deployments`;
      return utils.request({
        endpoint,
        method: "POST",
        accessKey: sdk.accessKey,
        data
      });
    };
    var list = async (sdk, { orgName, appName, serviceName, stageName, regionName, cursor }) => {
      if (!orgName) {
        throw new Error('An "orgName" is required to determine Serverless Organization for service');
      }
      if (!appName) {
        throw new Error('An "appName" is required to determine Serverless Application for service');
      }
      if (!serviceName) {
        throw new Error('A "serviceName" is required to determine which service should be archived');
      }
      if (!stageName) {
        throw new Error('A "stageName" is required');
      }
      if (!regionName) {
        throw new Error('A "regionName" is required');
      }
      let endpoint = `${sdk.getDomain("core")}/core/tenants/${orgName}/applications/${appName}/services/${serviceName}/stages/${stageName}/regions/${regionName}/deployments`;
      if (cursor) {
        endpoint += `?${querystring.stringify({ "x-cursor": cursor })}`;
      }
      return utils.request({
        endpoint,
        method: "GET",
        accessKey: sdk.accessKey
      });
    };
    module2.exports = {
      create,
      list
    };
  }
});

// ../node_modules/@serverless/platform-client/src/index.js
var require_src9 = __commonJS({
  "../node_modules/@serverless/platform-client/src/index.js"(exports2, module2) {
    "use strict";
    var WS = require_node3();
    var querystring = require("querystring");
    var jwtDecode = require_lib3();
    var util = require("util");
    var domains = require_domains();
    var resources = require_resources();
    var Connection = require_Connection();
    var registry = require_registry();
    var instance = require_instance();
    var events = require_events();
    var webhooks = require_webhooks();
    var accessKeys = require_accessKeys();
    var connections = require_connections();
    var desktop = require_desktop();
    var sessions = require_sessions();
    var apps = require_apps();
    var services = require_services();
    var utils = require_utils9();
    var logDestinations = require_logDestinations();
    var deploymentProfiles = require_deploymentProfiles();
    var organizations = require_organizations();
    var metadata = require_metadata();
    var frameworkDeployments = require_frameworkDeployments();
    var ServerlessSDK = class {
      constructor(config = {}) {
        this.context = {};
        this.config(config);
        this.domains = domains[this.platformStage];
        this.intercepts = {};
        this.intercepts.logs = [];
        this.intercepts.logsInterval = 200;
        this.session = {
          refreshToken: (refreshToken) => sessions.refreshToken(this, refreshToken)
        };
        this.events = {
          publish: (event) => events.publish(event, this.getDomain("events"), this.context, this.accessKey),
          get: (uid) => events.get(uid, this.getDomain("events"), this.accessKey),
          list: (options = {}) => events.list(this.getDomain("events"), this.context, this.accessKey, options),
          send: (event) => events.send(event, this.connection, this.context, this.accessKey)
        };
        this.frameworkDeployments = {
          create: async (options) => frameworkDeployments.create(this, options),
          list: async (options) => frameworkDeployments.list(this, options)
        };
        this.webhooks = {
          register: (url, options = {}) => webhooks.register(this, url, options),
          list: (options = {}) => {
            const { starting_after: startingAfter, limit = 10 } = options;
            return webhooks.list(this, startingAfter, limit);
          },
          get: (uid) => webhooks.get(this, uid),
          update: (uid, updates) => webhooks.update(this, uid, updates || {}),
          delete: (uid) => webhooks.remove(this, uid)
        };
        this.accessKeys = {
          create: (orgName, userName, accessKeyName) => accessKeys.create(this, orgName, userName, accessKeyName),
          list: (orgName) => accessKeys.list(this, orgName),
          remove: (orgName, uid) => accessKeys.remove(this, orgName, uid),
          get: () => accessKeys.get(this)
        };
        this.connections = {
          create: (orgUid, providerUid, accountAlias) => connections.create(this, orgUid, providerUid, accountAlias),
          list: (orgUid) => connections.list(this, orgUid),
          get: (orgUid, connectionUid) => connections.get(this, orgUid, connectionUid),
          getByOrgAndAccountAlias: (orgUid, accountAlias) => connections.getByOrgAndAccountAlias(this, orgUid, accountAlias),
          update: (orgUid, connectionUid, providerUid, accountAlias, status) => connections.update(this, orgUid, connectionUid, providerUid, accountAlias, status),
          remove: (orgName, connectionUid) => connections.remove(this, orgName, connectionUid),
          syncAll: (orgUid) => connections.syncAll(this, orgUid),
          unsync: (orgUid, connectionUid) => connections.unsync(this, orgUid, connectionUid)
        };
        this.desktop = {
          createSavedQuery: (orgUid, appUid, serviceName, savedQuery) => desktop.createSavedQuery(this, orgUid, appUid, serviceName, savedQuery),
          getSavedQuery: (orgUid, appUid, serviceName, savedQueryUid) => desktop.getSavedQuery(this, orgUid, appUid, serviceName, savedQueryUid),
          updateSavedQuery: (orgUid, appUid, serviceName, savedQueryUid, savedQuery) => desktop.updateSavedQuery(this, orgUid, appUid, serviceName, savedQueryUid, savedQuery),
          deleteSavedQuery: (orgUid, appUid, serviceName, savedQueryUid) => desktop.deleteSavedQuery(this, orgUid, appUid, serviceName, savedQueryUid),
          listSavedQueries: (orgUid, appUid, serviceName) => desktop.listSavedQueries(this, orgUid, appUid, serviceName)
        };
        this.logDestinations = {
          getOrCreate: async (params) => logDestinations.getOrCreate(this, params),
          remove: async (params) => logDestinations.remove(this, params)
        };
        this.deploymentProfiles = {
          get: async (params) => deploymentProfiles.get(this, params),
          create: async (params) => deploymentProfiles.create(this, params),
          list: async (params) => deploymentProfiles.list(this, params),
          setDefault: async (params) => deploymentProfiles.setDefault(this, params)
        };
        this.organizations = {
          get: async (params) => organizations.get(this, params),
          list: async (params) => organizations.list(this, params),
          create: async (params) => organizations.create(this, params),
          validate: async (params) => organizations.validate(this, params)
        };
        this.apps = {
          create: async (params) => apps.create(this, params),
          get: async (params) => apps.get(this, params),
          update: async (params) => apps.update(this, params),
          remove: async (params) => apps.remove(this, params),
          list: async (params) => apps.list(this, params)
        };
        this.metadata = {
          get: async () => metadata.get(this)
        };
        this.services = {
          get: async (params) => services.get(this, params),
          getStateVariable: async (params) => services.getStateVariable(this, params)
        };
      }
      config(config = {}) {
        this.accessKey = config.accessKey || this.accessKey;
        this.platformStage = process.env.SERVERLESS_PLATFORM_STAGE || config.platformStage || "prod";
        config.context = config.context || {};
        this.context.orgUid = config.context.orgUid || this.context.orgUid || null;
        this.context.orgName = config.context.orgName || this.context.orgName || null;
        this.context.stageName = config.context.stageName || this.context.stageName || null;
        this.context.appName = config.context.appName || this.context.appName || null;
        this.context.instanceName = config.context.instanceName || this.context.instanceName || null;
        this.context.componentName = config.context.componentName || this.context.componentName || null;
        this.context.componentVersion = config.context.componentVersion || this.context.componentVersion || null;
      }
      getDomain(serviceName = null) {
        return this.domains[serviceName] || null;
      }
      loginIdentity(config = {}) {
        const loginBrokerUrl = config.loginBrokerUrl ? `${config.loginBrokerUrl}broker` : `${this.getDomain("core")}/login/broker`;
        const ws = new WS(loginBrokerUrl, void 0, {
          followRedirects: true,
          agent: utils.getAgent()
        });
        let resolveTransactionId;
        let rejectTransactionId;
        const transactionId = new Promise((resolve2, reject2) => {
          resolveTransactionId = resolve2;
          rejectTransactionId = reject2;
        });
        let resolveLoginData;
        let rejectLoginData;
        const loginData = new Promise((resolve2, reject2) => {
          resolveLoginData = resolve2;
          rejectLoginData = reject2;
        });
        const sanitizeLoginData = (data) => {
          delete data.event;
          const decoded = jwtDecode(data.id_token);
          return {
            id: decoded.tracking_id || decoded.sub,
            name: decoded.name,
            email: decoded.email,
            username: data.username,
            user_uid: data.user_uid,
            refreshToken: data.refresh_token,
            accessToken: data.access_token,
            idToken: data.id_token,
            expiresAt: data.expires_in ? Date.now() + data.expires_in : data.expires_at
          };
        };
        ws.onmessage = (message) => {
          try {
            const data = JSON.parse(message.data);
            switch (data.event) {
              case "ready":
                resolveTransactionId(data.transactionId);
                break;
              case "fulfilled": {
                const sanitizedLoginData = sanitizeLoginData(data);
                resolveLoginData(sanitizedLoginData);
                ws.close();
                break;
              }
              default:
                throw new Error("Encountered an unexpected message while waiting for login information. Your Serverless Framework or SDK may be out of date.");
            }
          } catch (error) {
            rejectTransactionId(error);
            rejectLoginData(error);
            ws.close();
          }
        };
        ws.onopen = () => {
          ws.send('{"action":"login"}');
        };
        return {
          transactionId,
          loginData
        };
      }
      async login(config = {}) {
        const { transactionId: deferredTransactionId, loginData } = this.loginIdentity(config);
        const transactionId = await deferredTransactionId;
        const auth0Queries = querystring.stringify({
          client: "cli",
          transactionId
        });
        let loginUrl = `${this.getDomain("dashboard")}`;
        loginUrl = `${loginUrl}?${auth0Queries}`;
        return {
          loginUrl,
          loginData
        };
      }
      async getUser() {
        return resources.getUser(this);
      }
      async getUserMeta() {
        return resources.getUserMeta(this);
      }
      async saveUserMeta(userMeta) {
        return resources.saveUserMeta(this, userMeta);
      }
      async validateUserAndOrgName(userAndOrgName) {
        return resources.validateUserAndOrgName(this, userAndOrgName);
      }
      async createUserAndOrg(userAndOrgName) {
        return resources.createUserAndOrg(this, userAndOrgName);
      }
      async createOrg(userAndOrgName) {
        return resources.createOrg(this, userAndOrgName);
      }
      async getOrgByName(orgName) {
        return resources.getOrgByName(this, orgName);
      }
      async listOrgs(username) {
        return resources.listOrgs(this, username);
      }
      async createApp(orgName = null, app = {}) {
        return resources.createApp(this, orgName, app);
      }
      async updateApp(orgName = null, app = {}) {
        return resources.updateApp(this, orgName, app);
      }
      async deleteApp(orgName = null, appName = null) {
        return resources.deleteApp(this, orgName, appName);
      }
      async listApps(orgName = null) {
        return resources.listApps(this, orgName);
      }
      async createInitToken(orgName = null, template = {}) {
        return resources.createInitToken(this, orgName, template);
      }
      async getInitToken(initTokenUid) {
        return resources.getInitToken(this, initTokenUid);
      }
      async createProvider(orgUid, data) {
        return resources.createProvider(this, orgUid, data);
      }
      async updateProvider(orgUid, providerUid, data) {
        return resources.updateProvider(this, orgUid, providerUid, data);
      }
      async setDefaultProvider(orgUid, providerUid) {
        return resources.setDefaultProvider(this, orgUid, providerUid);
      }
      async unsetDefaultProvider(orgUid, providerUid) {
        return resources.unsetDefaultProvider(this, orgUid, providerUid);
      }
      async deleteProvider(orgUid, providerUid) {
        return resources.deleteProvider(this, orgUid, providerUid);
      }
      async createProviderLink(orgUid, linkType, linkUid, providerUid) {
        return resources.createProviderLink(this, orgUid, linkType, linkUid, providerUid);
      }
      async deleteProviderLink(orgUid, linkType, linkUid, providerUid) {
        return resources.deleteProviderLink(this, orgUid, linkType, linkUid, providerUid);
      }
      async getProviders(orgUid) {
        return resources.getProviders(this, orgUid);
      }
      async getProvider(orgUid, providerUid) {
        return resources.getProvider(this, orgUid, providerUid);
      }
      async getProvidersByOrgServiceInstance(orgUid, serviceUid, instanceUid) {
        return resources.getProvidersByOrgServiceInstance(this, orgUid, serviceUid, instanceUid);
      }
      async getProvidersByLink(orgUid, linkType, linkUid) {
        return resources.getProvidersByLink(this, orgUid, linkType, linkUid);
      }
      async getAllowedProviders() {
        return resources.getAllowedProviders(this);
      }
      async createParam(orgUid, linkType, linkUid, data) {
        return resources.createParam(this, orgUid, linkType, linkUid, data);
      }
      async deleteParam(orgUid, linkType, linkUid, paramUid) {
        return resources.deleteParam(this, orgUid, linkType, linkUid, paramUid);
      }
      async updateParam(orgUid, linkType, linkUid, paramUid, data) {
        return resources.updateParam(this, orgUid, linkType, linkUid, paramUid, data);
      }
      async getParams(orgUid, linkType, linkUid) {
        return resources.getParams(this, orgUid, linkType, linkUid);
      }
      async getParamsByOrgServiceInstance(orgUid, serviceUid, instanceUid) {
        return resources.getParamsByOrgServiceInstance(this, orgUid, serviceUid, instanceUid);
      }
      async getParamsAndProvidersByOrgServiceInstance(orgUid, serviceUid, instanceUid) {
        return resources.getParamsAndProvidersByOrgServiceInstance(this, orgUid, serviceUid, instanceUid);
      }
      async connect(options = {}) {
        this.connection = new Connection(this);
        await this.connection.connect(options);
      }
      disconnect() {
        if (this.connection) {
          this.connection.disconnect();
        }
      }
      isConnected() {
        if (!this.connection || !this.connection.isConnected()) {
          return false;
        }
        return true;
      }
      async unpublishFromRegistry(registryPackage = {}) {
        return await registry.unpublish(this, registryPackage);
      }
      async publishToRegistry(registryPackage = {}) {
        return registry.publish(this, registryPackage);
      }
      async getFromRegistry(name = null, version = null) {
        return registry.get(this, name, version);
      }
      generateInstanceId(orgName = null, stageName = null, appUid = null, instanceName = null) {
        return instance.generateId(orgName, stageName, appUid, instanceName);
      }
      validateInstance(instanceToValidate) {
        return instance.validateAndFormat(instanceToValidate);
      }
      createInstance(orgName = null, stageName = null, appName = null, instanceName = null, instanceStatus = "inactive") {
        return instance.create(orgName, stageName, appName, instanceName, instanceStatus);
      }
      async saveInstance(instanceRecord) {
        return instance.save(this, instanceRecord);
      }
      async getInstance(orgName = null, stageName = null, appName = null, instanceName = null) {
        return instance.getByName(this, orgName, stageName, appName, instanceName);
      }
      async listInstances(orgName = null, orgUid) {
        return instance.listByOrgName(this, orgName, orgUid);
      }
      async run(action, instanceData = {}, options = {}) {
        return instance.run(this, action, instanceData, options);
      }
      async runFinish(method = null, instanceData, meta = {}) {
        return instance.runFinish(this, method, instanceData, meta);
      }
      async deploy(instanceData = {}, options = {}) {
        return instance.deploy(this, instanceData, options);
      }
      async remove(instanceData = {}, options = {}) {
        return instance.remove(this, instanceData, options);
      }
      async startInterceptingLogs(eventType = null, context = {}) {
        this.intercepts.logs = [];
        this.intercepts.console = {};
        this.intercepts.console.log = console.log;
        this.intercepts.console.debug = console.debug;
        this.intercepts.console.info = console.info;
        this.intercepts.console.error = console.error;
        this.intercepts.console.warn = console.warn;
        this.intercepts.stdout = {};
        this.intercepts.stdout.write = process.stdout.write.bind(process.stdout);
        this.intercepts.stderr = {};
        this.intercepts.stderr.write = process.stderr.write.bind(process.stderr);
        const self2 = this;
        this.intercepts.publish = async () => {
          if (!self2.intercepts.logs || !self2.intercepts.logs.length) {
            return;
          }
          const logsCopy = self2.intercepts.logs.map((l) => l);
          self2.intercepts.logs = [];
          const evt = { data: __spreadValues({ logs: logsCopy }, context) };
          evt.event = eventType || "instance.logs";
          await self2.events.publish(evt);
        };
        this.intercepts.interval = setInterval(async () => {
          await self2.intercepts.publish();
        }, self2.intercepts.logsInterval);
        let isIntercepting = false;
        const intercept = (type, logs) => {
          const isTopLevel = !isIntercepting;
          if (isTopLevel) {
            isIntercepting = true;
            logs.forEach((l) => {
              if (l === void 0) {
                l = "undefined";
              }
              if (typeof l === "number") {
                l = JSON.stringify(l);
              }
              const log = { type };
              log.createdAt = Date.now();
              log.data = util.inspect(l);
              self2.intercepts.logs.push(log);
            });
          }
          try {
            if (type === "stdout") {
              self2.intercepts.stdout.write(...logs);
            } else if (type === "stderr") {
              self2.intercepts.stderr.write(...logs);
            } else {
              self2.intercepts.console[type].apply(console, logs);
            }
          } finally {
            if (isTopLevel)
              isIntercepting = false;
          }
        };
        console.log = (...args) => {
          intercept("log", args);
        };
        console.debug = (...args) => {
          intercept("debug", args);
        };
        console.info = (...args) => {
          intercept("info", args);
        };
        console.error = (...args) => {
          intercept("error", args);
        };
        console.warn = (...args) => {
          intercept("warn", args);
        };
        process.stdout.write = (...args) => {
          intercept("stdout", args);
        };
        process.stderr.write = (...args) => {
          intercept("stderr", args);
        };
      }
      async stopInterceptingLogs() {
        if (this.intercepts.interval) {
          clearInterval(this.intercepts.interval);
        }
        await this.intercepts.publish();
        this.intercepts.logs = [];
        console.log = this.intercepts.console.log;
        console.debug = this.intercepts.console.debug;
        console.info = this.intercepts.console.info;
        console.error = this.intercepts.console.error;
        console.warn = this.intercepts.console.warn;
        process.stdout.write = this.intercepts.stdout.write;
        process.stderr.write = this.intercepts.stderr.write;
      }
    };
    module2.exports = {
      ServerlessSDK,
      utils
    };
  }
});

// ../node_modules/@babel/runtime/helpers/interopRequireDefault.js
var require_interopRequireDefault = __commonJS({
  "../node_modules/@babel/runtime/helpers/interopRequireDefault.js"(exports2, module2) {
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        "default": obj
      };
    }
    module2.exports = _interopRequireDefault;
    module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
  }
});

// ../node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "../node_modules/regenerator-runtime/runtime.js"(exports2, module2) {
    var runtime = function(exports3) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define2(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define2({}, "");
      } catch (err) {
        define2 = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        generator._invoke = makeInvokeMethod(innerFn, self2, context);
        return generator;
      }
      exports3.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define2(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      define2(Gp, "constructor", GeneratorFunctionPrototype);
      define2(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
      GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define2(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports3.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports3.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define2(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports3.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve2, reject2) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject2(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve2, reject2);
              }, function(err) {
                invoke("throw", err, resolve2, reject2);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve2(result);
            }, function(error) {
              return invoke("throw", error, resolve2, reject2);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve2, reject2) {
              invoke(method, arg, resolve2, reject2);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        this._invoke = enqueue;
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define2(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports3.AsyncIterator = AsyncIterator;
      exports3.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports3.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (method === undefined2) {
          context.delegate = null;
          if (context.method === "throw") {
            if (delegate.iterator["return"]) {
              context.method = "return";
              context.arg = undefined2;
              maybeInvokeDelegate(delegate, context);
              if (context.method === "throw") {
                return ContinueSentinel;
              }
            }
            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define2(Gp, toStringTagSymbol, "Generator");
      define2(Gp, iteratorSymbol, function() {
        return this;
      });
      define2(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports3.keys = function(object) {
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i = -1, next = function next2() {
              while (++i < iterable.length) {
                if (hasOwn.call(iterable, i)) {
                  next2.value = iterable[i];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports3.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports3;
    }(typeof module2 === "object" ? module2.exports : {});
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// ../node_modules/@babel/runtime/regenerator/index.js
var require_regenerator = __commonJS({
  "../node_modules/@babel/runtime/regenerator/index.js"(exports2, module2) {
    module2.exports = require_runtime();
  }
});

// ../node_modules/@babel/runtime/helpers/typeof.js
var require_typeof = __commonJS({
  "../node_modules/@babel/runtime/helpers/typeof.js"(exports2, module2) {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        module2.exports = _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
        module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
      } else {
        module2.exports = _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
        module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
      }
      return _typeof(obj);
    }
    module2.exports = _typeof;
    module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
  }
});

// ../node_modules/@babel/runtime/helpers/asyncToGenerator.js
var require_asyncToGenerator = __commonJS({
  "../node_modules/@babel/runtime/helpers/asyncToGenerator.js"(exports2, module2) {
    function asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value = info.value;
      } catch (error) {
        reject2(error);
        return;
      }
      if (info.done) {
        resolve2(value);
      } else {
        Promise.resolve(value).then(_next, _throw);
      }
    }
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve2, reject2) {
          var gen = fn.apply(self2, args);
          function _next(value) {
            asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "next", value);
          }
          function _throw(err) {
            asyncGeneratorStep(gen, resolve2, reject2, _next, _throw, "throw", err);
          }
          _next(void 0);
        });
      };
    }
    module2.exports = _asyncToGenerator;
    module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
  }
});

// ../node_modules/@babel/runtime/helpers/defineProperty.js
var require_defineProperty = __commonJS({
  "../node_modules/@babel/runtime/helpers/defineProperty.js"(exports2, module2) {
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    module2.exports = _defineProperty;
    module2.exports["default"] = module2.exports, module2.exports.__esModule = true;
  }
});

// ../node_modules/is-retry-allowed/index.js
var require_is_retry_allowed2 = __commonJS({
  "../node_modules/is-retry-allowed/index.js"(exports2, module2) {
    "use strict";
    var denyList = new Set([
      "ENOTFOUND",
      "ENETUNREACH",
      "UNABLE_TO_GET_ISSUER_CERT",
      "UNABLE_TO_GET_CRL",
      "UNABLE_TO_DECRYPT_CERT_SIGNATURE",
      "UNABLE_TO_DECRYPT_CRL_SIGNATURE",
      "UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY",
      "CERT_SIGNATURE_FAILURE",
      "CRL_SIGNATURE_FAILURE",
      "CERT_NOT_YET_VALID",
      "CERT_HAS_EXPIRED",
      "CRL_NOT_YET_VALID",
      "CRL_HAS_EXPIRED",
      "ERROR_IN_CERT_NOT_BEFORE_FIELD",
      "ERROR_IN_CERT_NOT_AFTER_FIELD",
      "ERROR_IN_CRL_LAST_UPDATE_FIELD",
      "ERROR_IN_CRL_NEXT_UPDATE_FIELD",
      "OUT_OF_MEM",
      "DEPTH_ZERO_SELF_SIGNED_CERT",
      "SELF_SIGNED_CERT_IN_CHAIN",
      "UNABLE_TO_GET_ISSUER_CERT_LOCALLY",
      "UNABLE_TO_VERIFY_LEAF_SIGNATURE",
      "CERT_CHAIN_TOO_LONG",
      "CERT_REVOKED",
      "INVALID_CA",
      "PATH_LENGTH_EXCEEDED",
      "INVALID_PURPOSE",
      "CERT_UNTRUSTED",
      "CERT_REJECTED",
      "HOSTNAME_MISMATCH"
    ]);
    module2.exports = (error) => !denyList.has(error && error.code);
  }
});

// ../node_modules/axios-retry/lib/cjs/index.js
var require_cjs = __commonJS({
  "../node_modules/axios-retry/lib/cjs/index.js"(exports2) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isNetworkError = isNetworkError;
    exports2.isRetryableError = isRetryableError;
    exports2.isSafeRequestError = isSafeRequestError;
    exports2.isIdempotentRequestError = isIdempotentRequestError;
    exports2.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
    exports2.exponentialDelay = exponentialDelay;
    exports2.default = axiosRetry;
    var _regenerator = _interopRequireDefault(require_regenerator());
    var _typeof2 = _interopRequireDefault(require_typeof());
    var _asyncToGenerator2 = _interopRequireDefault(require_asyncToGenerator());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _isRetryAllowed = _interopRequireDefault(require_is_retry_allowed2());
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        }
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var namespace = "axios-retry";
    function isNetworkError(error) {
      return !error.response && Boolean(error.code) && error.code !== "ECONNABORTED" && (0, _isRetryAllowed.default)(error);
    }
    var SAFE_HTTP_METHODS = ["get", "head", "options"];
    var IDEMPOTENT_HTTP_METHODS = SAFE_HTTP_METHODS.concat(["put", "delete"]);
    function isRetryableError(error) {
      return error.code !== "ECONNABORTED" && (!error.response || error.response.status >= 500 && error.response.status <= 599);
    }
    function isSafeRequestError(error) {
      if (!error.config) {
        return false;
      }
      return isRetryableError(error) && SAFE_HTTP_METHODS.indexOf(error.config.method) !== -1;
    }
    function isIdempotentRequestError(error) {
      if (!error.config) {
        return false;
      }
      return isRetryableError(error) && IDEMPOTENT_HTTP_METHODS.indexOf(error.config.method) !== -1;
    }
    function isNetworkOrIdempotentRequestError(error) {
      return isNetworkError(error) || isIdempotentRequestError(error);
    }
    function noDelay() {
      return 0;
    }
    function exponentialDelay() {
      var retryNumber = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      var delay = Math.pow(2, retryNumber) * 100;
      var randomSum = delay * 0.2 * Math.random();
      return delay + randomSum;
    }
    function getCurrentState(config) {
      var currentState = config[namespace] || {};
      currentState.retryCount = currentState.retryCount || 0;
      config[namespace] = currentState;
      return currentState;
    }
    function getRequestOptions(config, defaultOptions) {
      return _objectSpread(_objectSpread({}, defaultOptions), config[namespace]);
    }
    function fixConfig(axios, config) {
      if (axios.defaults.agent === config.agent) {
        delete config.agent;
      }
      if (axios.defaults.httpAgent === config.httpAgent) {
        delete config.httpAgent;
      }
      if (axios.defaults.httpsAgent === config.httpsAgent) {
        delete config.httpsAgent;
      }
    }
    function shouldRetry(_x, _x2, _x3, _x4) {
      return _shouldRetry.apply(this, arguments);
    }
    function _shouldRetry() {
      _shouldRetry = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee2(retries, retryCondition, currentState, error) {
        var shouldRetryOrPromise;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                shouldRetryOrPromise = currentState.retryCount < retries && retryCondition(error);
                if (!((0, _typeof2.default)(shouldRetryOrPromise) === "object")) {
                  _context2.next = 11;
                  break;
                }
                _context2.prev = 2;
                _context2.next = 5;
                return shouldRetryOrPromise;
              case 5:
                return _context2.abrupt("return", true);
              case 8:
                _context2.prev = 8;
                _context2.t0 = _context2["catch"](2);
                return _context2.abrupt("return", false);
              case 11:
                return _context2.abrupt("return", shouldRetryOrPromise);
              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, null, [[2, 8]]);
      }));
      return _shouldRetry.apply(this, arguments);
    }
    function axiosRetry(axios, defaultOptions) {
      axios.interceptors.request.use(function(config) {
        var currentState = getCurrentState(config);
        currentState.lastRequestTime = Date.now();
        return config;
      });
      axios.interceptors.response.use(null, /* @__PURE__ */ function() {
        var _ref = (0, _asyncToGenerator2.default)(/* @__PURE__ */ _regenerator.default.mark(function _callee(error) {
          var config, _getRequestOptions, _getRequestOptions$re, retries, _getRequestOptions$re2, retryCondition, _getRequestOptions$re3, retryDelay, _getRequestOptions$sh, shouldResetTimeout, currentState, delay, lastRequestDuration;
          return _regenerator.default.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  config = error.config;
                  if (config) {
                    _context.next = 3;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject(error));
                case 3:
                  _getRequestOptions = getRequestOptions(config, defaultOptions), _getRequestOptions$re = _getRequestOptions.retries, retries = _getRequestOptions$re === void 0 ? 3 : _getRequestOptions$re, _getRequestOptions$re2 = _getRequestOptions.retryCondition, retryCondition = _getRequestOptions$re2 === void 0 ? isNetworkOrIdempotentRequestError : _getRequestOptions$re2, _getRequestOptions$re3 = _getRequestOptions.retryDelay, retryDelay = _getRequestOptions$re3 === void 0 ? noDelay : _getRequestOptions$re3, _getRequestOptions$sh = _getRequestOptions.shouldResetTimeout, shouldResetTimeout = _getRequestOptions$sh === void 0 ? false : _getRequestOptions$sh;
                  currentState = getCurrentState(config);
                  _context.next = 7;
                  return shouldRetry(retries, retryCondition, currentState, error);
                case 7:
                  if (!_context.sent) {
                    _context.next = 14;
                    break;
                  }
                  currentState.retryCount += 1;
                  delay = retryDelay(currentState.retryCount, error);
                  fixConfig(axios, config);
                  if (!shouldResetTimeout && config.timeout && currentState.lastRequestTime) {
                    lastRequestDuration = Date.now() - currentState.lastRequestTime;
                    config.timeout = Math.max(config.timeout - lastRequestDuration - delay, 1);
                  }
                  config.transformRequest = [function(data) {
                    return data;
                  }];
                  return _context.abrupt("return", new Promise(function(resolve2) {
                    return setTimeout(function() {
                      return resolve2(axios(config));
                    }, delay);
                  }));
                case 14:
                  return _context.abrupt("return", Promise.reject(error));
                case 15:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function(_x5) {
          return _ref.apply(this, arguments);
        };
      }());
    }
    axiosRetry.isNetworkError = isNetworkError;
    axiosRetry.isSafeRequestError = isSafeRequestError;
    axiosRetry.isIdempotentRequestError = isIdempotentRequestError;
    axiosRetry.isNetworkOrIdempotentRequestError = isNetworkOrIdempotentRequestError;
    axiosRetry.exponentialDelay = exponentialDelay;
    axiosRetry.isRetryableError = isRetryableError;
  }
});

// ../node_modules/axios-retry/index.js
var require_axios_retry = __commonJS({
  "../node_modules/axios-retry/index.js"(exports2, module2) {
    var axiosRetry = require_cjs().default;
    module2.exports = axiosRetry;
    module2.exports.default = axiosRetry;
  }
});

// src/utils/request.js
var require_request = __commonJS({
  "src/utils/request.js"(exports2, module2) {
    "use strict";
    var https = require("https");
    var Axios = require_axios2();
    var axiosRetry = require_axios_retry();
    var { version } = require_package2();
    var httpsAgent = new https.Agent({ keepAlive: true });
    var axios = Axios.create({
      httpsAgent
    });
    axiosRetry(axios, {
      retries: 10,
      retryDelay: axiosRetry.exponentialDelay,
      retryCondition: (error) => {
        const status = error.response && error.response.status || "unknown";
        const message = error.response && error.response.data && error.response.data.message || "unknown";
        const retryable = axiosRetry.isNetworkOrIdempotentRequestError(error) || status === 429 || status === 503;
        if (retryable && process.env.SLS_DEBUG) {
          console.log(`Received error status ${status}, message ${message}, retrying...`);
        }
        return retryable;
      }
    });
    axios.defaults.headers.common = {};
    axios.defaults.headers.put = {};
    axios.defaults.headers.get = {};
    module2.exports = async (options = {}) => {
      const root = options.root || process.env.SERVERLESS_CLOUD_ENDPOINT;
      const { accessKey, method = "POST", params, headers = {}, body, endpoint } = options;
      const { url = `${root}${endpoint}`, responseType } = options;
      if (accessKey) {
        headers.Authorization = `Bearer ${accessKey}`;
      }
      if (body && endpoint) {
        headers["Content-Type"] = "application/json";
      }
      if (endpoint) {
        headers["User-Agent"] = `cli/${version}`;
      }
      const requestOptions = {
        url,
        method,
        headers,
        params,
        data: body,
        maxContentLength: Infinity,
        maxBodyLength: Infinity
      };
      if (responseType) {
        requestOptions.responseType = responseType;
      }
      try {
        const res = await axios(requestOptions);
        return res.data;
      } catch (error) {
        if (error.response && error.response.data) {
          const err = new Error(error.response.data.message);
          err.statusCode = error.response.data.statusCode || error.response.status || null;
          err.name = error.response.data.name || null;
          throw err;
        }
        throw error;
      }
    };
  }
});

// src/models/User.js
var require_User = __commonJS({
  "src/models/User.js"(exports2, module2) {
    "use strict";
    var configUtils = require_config();
    var accountUtils = require_account();
    var { ServerlessSDK } = require_src9();
    var request = require_request();
    var sleep = async (ms) => new Promise((res) => setTimeout(res, ms));
    var User = class {
      constructor() {
        this.sdk = new ServerlessSDK();
        this.load();
      }
      load() {
        const user = configUtils.getLoggedInUser();
        if (!user)
          return;
        this.userId = user.userId;
        this.username = user.username;
        this.refreshToken = user.refreshToken;
        this.token = user.idToken;
        this.accessKeys = user.accessKeys;
      }
      isLoggedIn() {
        if (this._isValidUserIdSet()) {
          return true;
        }
        this.load();
        if (this._isValidUserIdSet()) {
          return true;
        }
        return false;
      }
      async getToken() {
        if (!this.isLoggedIn()) {
          return null;
        }
        await accountUtils.refreshToken(this.sdk);
        this.load();
        return this.token;
      }
      async getDefaultOrgName() {
        if (!this.isLoggedIn()) {
          return null;
        }
        const orgsList = await this.listOrgs();
        const defaultOrg = orgsList.find((org) => org.role === "owner");
        return defaultOrg.orgName;
      }
      async restoreOrgLogin(loginToken) {
        const initTokenResult = await this.sdk.getInitToken(`sf_${loginToken}`);
        const userId = initTokenResult.userUid;
        const refreshToken = initTokenResult.template.commands[0];
        const loginDataToSaveInConfig = {
          userId,
          users: {
            [userId]: {
              userId,
              username: initTokenResult.userName,
              dashboard: {
                username: initTokenResult.userName,
                idToken: initTokenResult.idToken,
                refreshToken
              }
            }
          }
        };
        configUtils.set(loginDataToSaveInConfig);
        return initTokenResult.tenantName;
      }
      async listOrgs() {
        if (!this.isLoggedIn()) {
          return null;
        }
        this.sdk.config({ accessKey: await this.getToken() });
        return await this.sdk.organizations.list({ username: this.username });
      }
      async startLogin() {
        const { loginUrl, loginData } = await this.sdk.login();
        this._loginData = loginData;
        const cloudLoginUrl = loginUrl.replace("app", "cloud");
        return cloudLoginUrl;
      }
      async endLogin() {
        const loginData = await this._loginData;
        if (!(loginData == null ? void 0 : loginData.user_uid)) {
          loginData.user_uid = await this._getUserUid(loginData.idToken);
        }
        const userId = loginData.user_uid;
        const loginDataToSaveInConfig = {
          userId,
          users: {
            [userId]: {
              userId,
              name: loginData.name,
              email: loginData.email,
              username: loginData.username,
              dashboard: {
                refreshToken: loginData.refreshToken,
                accessToken: loginData.accessToken,
                idToken: loginData.idToken,
                expiresAt: loginData.expiresAt,
                username: loginData.username
              }
            }
          }
        };
        configUtils.set(loginDataToSaveInConfig);
      }
      logout() {
        return accountUtils.logout();
      }
      async _getUserUid(idToken) {
        let platformRoot = process.env.SERVERLESS_PLATFORM_STAGE === "dev" ? `https://api.serverless-dev.com` : `https://api.serverless.com`;
        const options = {
          accessKey: idToken,
          method: "GET",
          root: platformRoot,
          endpoint: `/core/me`
        };
        const res = await request(options);
        if (!(res == null ? void 0 : res.userUid)) {
          await sleep(1e3);
          return await this._getUserUid(idToken);
        }
        return res.userUid;
      }
      _isValidUserIdSet() {
        if (this.userId && !this.userId.startsWith("github|")) {
          return true;
        }
        return false;
      }
    };
    module2.exports = User;
  }
});

// ../node_modules/ramda/src/internal/_isPlaceholder.js
var require_isPlaceholder = __commonJS({
  "../node_modules/ramda/src/internal/_isPlaceholder.js"(exports2, module2) {
    function _isPlaceholder(a) {
      return a != null && typeof a === "object" && a["@@functional/placeholder"] === true;
    }
    module2.exports = _isPlaceholder;
  }
});

// ../node_modules/ramda/src/internal/_curry1.js
var require_curry1 = __commonJS({
  "../node_modules/ramda/src/internal/_curry1.js"(exports2, module2) {
    var _isPlaceholder = require_isPlaceholder();
    function _curry1(fn) {
      return function f1(a) {
        if (arguments.length === 0 || _isPlaceholder(a)) {
          return f1;
        } else {
          return fn.apply(this, arguments);
        }
      };
    }
    module2.exports = _curry1;
  }
});

// ../node_modules/ramda/src/always.js
var require_always = __commonJS({
  "../node_modules/ramda/src/always.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var always = /* @__PURE__ */ _curry1(function always2(val) {
      return function() {
        return val;
      };
    });
    module2.exports = always;
  }
});

// ../node_modules/ramda/src/F.js
var require_F = __commonJS({
  "../node_modules/ramda/src/F.js"(exports2, module2) {
    var always = require_always();
    var F = /* @__PURE__ */ always(false);
    module2.exports = F;
  }
});

// ../node_modules/ramda/src/T.js
var require_T = __commonJS({
  "../node_modules/ramda/src/T.js"(exports2, module2) {
    var always = require_always();
    var T = /* @__PURE__ */ always(true);
    module2.exports = T;
  }
});

// ../node_modules/ramda/src/__.js
var require__ = __commonJS({
  "../node_modules/ramda/src/__.js"(exports2, module2) {
    module2.exports = { "@@functional/placeholder": true };
  }
});

// ../node_modules/ramda/src/internal/_curry2.js
var require_curry2 = __commonJS({
  "../node_modules/ramda/src/internal/_curry2.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _isPlaceholder = require_isPlaceholder();
    function _curry2(fn) {
      return function f2(a, b) {
        switch (arguments.length) {
          case 0:
            return f2;
          case 1:
            return _isPlaceholder(a) ? f2 : _curry1(function(_b) {
              return fn(a, _b);
            });
          default:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function(_a) {
              return fn(_a, b);
            }) : _isPlaceholder(b) ? _curry1(function(_b) {
              return fn(a, _b);
            }) : fn(a, b);
        }
      };
    }
    module2.exports = _curry2;
  }
});

// ../node_modules/ramda/src/add.js
var require_add = __commonJS({
  "../node_modules/ramda/src/add.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var add = /* @__PURE__ */ _curry2(function add2(a, b) {
      return Number(a) + Number(b);
    });
    module2.exports = add;
  }
});

// ../node_modules/ramda/src/internal/_concat.js
var require_concat = __commonJS({
  "../node_modules/ramda/src/internal/_concat.js"(exports2, module2) {
    function _concat(set1, set2) {
      set1 = set1 || [];
      set2 = set2 || [];
      var idx;
      var len1 = set1.length;
      var len2 = set2.length;
      var result = [];
      idx = 0;
      while (idx < len1) {
        result[result.length] = set1[idx];
        idx += 1;
      }
      idx = 0;
      while (idx < len2) {
        result[result.length] = set2[idx];
        idx += 1;
      }
      return result;
    }
    module2.exports = _concat;
  }
});

// ../node_modules/ramda/src/internal/_arity.js
var require_arity = __commonJS({
  "../node_modules/ramda/src/internal/_arity.js"(exports2, module2) {
    function _arity(n, fn) {
      switch (n) {
        case 0:
          return function() {
            return fn.apply(this, arguments);
          };
        case 1:
          return function(a0) {
            return fn.apply(this, arguments);
          };
        case 2:
          return function(a0, a1) {
            return fn.apply(this, arguments);
          };
        case 3:
          return function(a0, a1, a2) {
            return fn.apply(this, arguments);
          };
        case 4:
          return function(a0, a1, a2, a3) {
            return fn.apply(this, arguments);
          };
        case 5:
          return function(a0, a1, a2, a3, a4) {
            return fn.apply(this, arguments);
          };
        case 6:
          return function(a0, a1, a2, a3, a4, a5) {
            return fn.apply(this, arguments);
          };
        case 7:
          return function(a0, a1, a2, a3, a4, a5, a6) {
            return fn.apply(this, arguments);
          };
        case 8:
          return function(a0, a1, a2, a3, a4, a5, a6, a7) {
            return fn.apply(this, arguments);
          };
        case 9:
          return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
            return fn.apply(this, arguments);
          };
        case 10:
          return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return fn.apply(this, arguments);
          };
        default:
          throw new Error("First argument to _arity must be a non-negative integer no greater than ten");
      }
    }
    module2.exports = _arity;
  }
});

// ../node_modules/ramda/src/internal/_curryN.js
var require_curryN = __commonJS({
  "../node_modules/ramda/src/internal/_curryN.js"(exports2, module2) {
    var _arity = require_arity();
    var _isPlaceholder = require_isPlaceholder();
    function _curryN(length, received, fn) {
      return function() {
        var combined = [];
        var argsIdx = 0;
        var left = length;
        var combinedIdx = 0;
        while (combinedIdx < received.length || argsIdx < arguments.length) {
          var result;
          if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
            result = received[combinedIdx];
          } else {
            result = arguments[argsIdx];
            argsIdx += 1;
          }
          combined[combinedIdx] = result;
          if (!_isPlaceholder(result)) {
            left -= 1;
          }
          combinedIdx += 1;
        }
        return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
      };
    }
    module2.exports = _curryN;
  }
});

// ../node_modules/ramda/src/curryN.js
var require_curryN2 = __commonJS({
  "../node_modules/ramda/src/curryN.js"(exports2, module2) {
    var _arity = require_arity();
    var _curry1 = require_curry1();
    var _curry2 = require_curry2();
    var _curryN = require_curryN();
    var curryN = /* @__PURE__ */ _curry2(function curryN2(length, fn) {
      if (length === 1) {
        return _curry1(fn);
      }
      return _arity(length, _curryN(length, [], fn));
    });
    module2.exports = curryN;
  }
});

// ../node_modules/ramda/src/addIndex.js
var require_addIndex = __commonJS({
  "../node_modules/ramda/src/addIndex.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry1 = require_curry1();
    var curryN = require_curryN2();
    var addIndex = /* @__PURE__ */ _curry1(function addIndex2(fn) {
      return curryN(fn.length, function() {
        var idx = 0;
        var origFn = arguments[0];
        var list = arguments[arguments.length - 1];
        var args = Array.prototype.slice.call(arguments, 0);
        args[0] = function() {
          var result = origFn.apply(this, _concat(arguments, [idx, list]));
          idx += 1;
          return result;
        };
        return fn.apply(this, args);
      });
    });
    module2.exports = addIndex;
  }
});

// ../node_modules/ramda/src/internal/_curry3.js
var require_curry3 = __commonJS({
  "../node_modules/ramda/src/internal/_curry3.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _curry2 = require_curry2();
    var _isPlaceholder = require_isPlaceholder();
    function _curry3(fn) {
      return function f3(a, b, c) {
        switch (arguments.length) {
          case 0:
            return f3;
          case 1:
            return _isPlaceholder(a) ? f3 : _curry2(function(_b, _c) {
              return fn(a, _b, _c);
            });
          case 2:
            return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function(_a, _c) {
              return fn(_a, b, _c);
            }) : _isPlaceholder(b) ? _curry2(function(_b, _c) {
              return fn(a, _b, _c);
            }) : _curry1(function(_c) {
              return fn(a, b, _c);
            });
          default:
            return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function(_a, _b) {
              return fn(_a, _b, c);
            }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function(_a, _c) {
              return fn(_a, b, _c);
            }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function(_b, _c) {
              return fn(a, _b, _c);
            }) : _isPlaceholder(a) ? _curry1(function(_a) {
              return fn(_a, b, c);
            }) : _isPlaceholder(b) ? _curry1(function(_b) {
              return fn(a, _b, c);
            }) : _isPlaceholder(c) ? _curry1(function(_c) {
              return fn(a, b, _c);
            }) : fn(a, b, c);
        }
      };
    }
    module2.exports = _curry3;
  }
});

// ../node_modules/ramda/src/adjust.js
var require_adjust = __commonJS({
  "../node_modules/ramda/src/adjust.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry3 = require_curry3();
    var adjust = /* @__PURE__ */ _curry3(function adjust2(fn, idx, list) {
      if (idx >= list.length || idx < -list.length) {
        return list;
      }
      var start = idx < 0 ? list.length : 0;
      var _idx = start + idx;
      var _list = _concat(list);
      _list[_idx] = fn(list[_idx]);
      return _list;
    });
    module2.exports = adjust;
  }
});

// ../node_modules/ramda/src/internal/_isArray.js
var require_isArray2 = __commonJS({
  "../node_modules/ramda/src/internal/_isArray.js"(exports2, module2) {
    module2.exports = Array.isArray || function _isArray(val) {
      return val != null && val.length >= 0 && Object.prototype.toString.call(val) === "[object Array]";
    };
  }
});

// ../node_modules/ramda/src/internal/_isTransformer.js
var require_isTransformer = __commonJS({
  "../node_modules/ramda/src/internal/_isTransformer.js"(exports2, module2) {
    function _isTransformer(obj) {
      return typeof obj["@@transducer/step"] === "function";
    }
    module2.exports = _isTransformer;
  }
});

// ../node_modules/ramda/src/internal/_dispatchable.js
var require_dispatchable = __commonJS({
  "../node_modules/ramda/src/internal/_dispatchable.js"(exports2, module2) {
    var _isArray = require_isArray2();
    var _isTransformer = require_isTransformer();
    function _dispatchable(methodNames, xf, fn) {
      return function() {
        if (arguments.length === 0) {
          return fn();
        }
        var args = Array.prototype.slice.call(arguments, 0);
        var obj = args.pop();
        if (!_isArray(obj)) {
          var idx = 0;
          while (idx < methodNames.length) {
            if (typeof obj[methodNames[idx]] === "function") {
              return obj[methodNames[idx]].apply(obj, args);
            }
            idx += 1;
          }
          if (_isTransformer(obj)) {
            var transducer = xf.apply(null, args);
            return transducer(obj);
          }
        }
        return fn.apply(this, arguments);
      };
    }
    module2.exports = _dispatchable;
  }
});

// ../node_modules/ramda/src/internal/_reduced.js
var require_reduced = __commonJS({
  "../node_modules/ramda/src/internal/_reduced.js"(exports2, module2) {
    function _reduced(x) {
      return x && x["@@transducer/reduced"] ? x : {
        "@@transducer/value": x,
        "@@transducer/reduced": true
      };
    }
    module2.exports = _reduced;
  }
});

// ../node_modules/ramda/src/internal/_xfBase.js
var require_xfBase = __commonJS({
  "../node_modules/ramda/src/internal/_xfBase.js"(exports2, module2) {
    module2.exports = {
      init: function() {
        return this.xf["@@transducer/init"]();
      },
      result: function(result) {
        return this.xf["@@transducer/result"](result);
      }
    };
  }
});

// ../node_modules/ramda/src/internal/_xall.js
var require_xall = __commonJS({
  "../node_modules/ramda/src/internal/_xall.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduced = require_reduced();
    var _xfBase = require_xfBase();
    var XAll = /* @__PURE__ */ function() {
      function XAll2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.all = true;
      }
      XAll2.prototype["@@transducer/init"] = _xfBase.init;
      XAll2.prototype["@@transducer/result"] = function(result) {
        if (this.all) {
          result = this.xf["@@transducer/step"](result, true);
        }
        return this.xf["@@transducer/result"](result);
      };
      XAll2.prototype["@@transducer/step"] = function(result, input) {
        if (!this.f(input)) {
          this.all = false;
          result = _reduced(this.xf["@@transducer/step"](result, false));
        }
        return result;
      };
      return XAll2;
    }();
    var _xall = /* @__PURE__ */ _curry2(function _xall2(f, xf) {
      return new XAll(f, xf);
    });
    module2.exports = _xall;
  }
});

// ../node_modules/ramda/src/all.js
var require_all = __commonJS({
  "../node_modules/ramda/src/all.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xall = require_xall();
    var all = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["all"], _xall, function all2(fn, list) {
      var idx = 0;
      while (idx < list.length) {
        if (!fn(list[idx])) {
          return false;
        }
        idx += 1;
      }
      return true;
    }));
    module2.exports = all;
  }
});

// ../node_modules/ramda/src/max.js
var require_max = __commonJS({
  "../node_modules/ramda/src/max.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var max = /* @__PURE__ */ _curry2(function max2(a, b) {
      return b > a ? b : a;
    });
    module2.exports = max;
  }
});

// ../node_modules/ramda/src/internal/_map.js
var require_map2 = __commonJS({
  "../node_modules/ramda/src/internal/_map.js"(exports2, module2) {
    function _map(fn, functor) {
      var idx = 0;
      var len = functor.length;
      var result = Array(len);
      while (idx < len) {
        result[idx] = fn(functor[idx]);
        idx += 1;
      }
      return result;
    }
    module2.exports = _map;
  }
});

// ../node_modules/ramda/src/internal/_isString.js
var require_isString2 = __commonJS({
  "../node_modules/ramda/src/internal/_isString.js"(exports2, module2) {
    function _isString(x) {
      return Object.prototype.toString.call(x) === "[object String]";
    }
    module2.exports = _isString;
  }
});

// ../node_modules/ramda/src/internal/_isArrayLike.js
var require_isArrayLike2 = __commonJS({
  "../node_modules/ramda/src/internal/_isArrayLike.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _isArray = require_isArray2();
    var _isString = require_isString2();
    var _isArrayLike = /* @__PURE__ */ _curry1(function isArrayLike(x) {
      if (_isArray(x)) {
        return true;
      }
      if (!x) {
        return false;
      }
      if (typeof x !== "object") {
        return false;
      }
      if (_isString(x)) {
        return false;
      }
      if (x.nodeType === 1) {
        return !!x.length;
      }
      if (x.length === 0) {
        return true;
      }
      if (x.length > 0) {
        return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
      }
      return false;
    });
    module2.exports = _isArrayLike;
  }
});

// ../node_modules/ramda/src/internal/_xwrap.js
var require_xwrap = __commonJS({
  "../node_modules/ramda/src/internal/_xwrap.js"(exports2, module2) {
    var XWrap = /* @__PURE__ */ function() {
      function XWrap2(fn) {
        this.f = fn;
      }
      XWrap2.prototype["@@transducer/init"] = function() {
        throw new Error("init not implemented on XWrap");
      };
      XWrap2.prototype["@@transducer/result"] = function(acc) {
        return acc;
      };
      XWrap2.prototype["@@transducer/step"] = function(acc, x) {
        return this.f(acc, x);
      };
      return XWrap2;
    }();
    function _xwrap(fn) {
      return new XWrap(fn);
    }
    module2.exports = _xwrap;
  }
});

// ../node_modules/ramda/src/bind.js
var require_bind2 = __commonJS({
  "../node_modules/ramda/src/bind.js"(exports2, module2) {
    var _arity = require_arity();
    var _curry2 = require_curry2();
    var bind = /* @__PURE__ */ _curry2(function bind2(fn, thisObj) {
      return _arity(fn.length, function() {
        return fn.apply(thisObj, arguments);
      });
    });
    module2.exports = bind;
  }
});

// ../node_modules/ramda/src/internal/_reduce.js
var require_reduce = __commonJS({
  "../node_modules/ramda/src/internal/_reduce.js"(exports2, module2) {
    var _isArrayLike = require_isArrayLike2();
    var _xwrap = require_xwrap();
    var bind = require_bind2();
    function _arrayReduce(xf, acc, list) {
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        acc = xf["@@transducer/step"](acc, list[idx]);
        if (acc && acc["@@transducer/reduced"]) {
          acc = acc["@@transducer/value"];
          break;
        }
        idx += 1;
      }
      return xf["@@transducer/result"](acc);
    }
    function _iterableReduce(xf, acc, iter) {
      var step = iter.next();
      while (!step.done) {
        acc = xf["@@transducer/step"](acc, step.value);
        if (acc && acc["@@transducer/reduced"]) {
          acc = acc["@@transducer/value"];
          break;
        }
        step = iter.next();
      }
      return xf["@@transducer/result"](acc);
    }
    function _methodReduce(xf, acc, obj, methodName) {
      return xf["@@transducer/result"](obj[methodName](bind(xf["@@transducer/step"], xf), acc));
    }
    var symIterator = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
    function _reduce(fn, acc, list) {
      if (typeof fn === "function") {
        fn = _xwrap(fn);
      }
      if (_isArrayLike(list)) {
        return _arrayReduce(fn, acc, list);
      }
      if (typeof list["fantasy-land/reduce"] === "function") {
        return _methodReduce(fn, acc, list, "fantasy-land/reduce");
      }
      if (list[symIterator] != null) {
        return _iterableReduce(fn, acc, list[symIterator]());
      }
      if (typeof list.next === "function") {
        return _iterableReduce(fn, acc, list);
      }
      if (typeof list.reduce === "function") {
        return _methodReduce(fn, acc, list, "reduce");
      }
      throw new TypeError("reduce: list must be array or iterable");
    }
    module2.exports = _reduce;
  }
});

// ../node_modules/ramda/src/internal/_xmap.js
var require_xmap = __commonJS({
  "../node_modules/ramda/src/internal/_xmap.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XMap = /* @__PURE__ */ function() {
      function XMap2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XMap2.prototype["@@transducer/init"] = _xfBase.init;
      XMap2.prototype["@@transducer/result"] = _xfBase.result;
      XMap2.prototype["@@transducer/step"] = function(result, input) {
        return this.xf["@@transducer/step"](result, this.f(input));
      };
      return XMap2;
    }();
    var _xmap = /* @__PURE__ */ _curry2(function _xmap2(f, xf) {
      return new XMap(f, xf);
    });
    module2.exports = _xmap;
  }
});

// ../node_modules/ramda/src/internal/_has.js
var require_has = __commonJS({
  "../node_modules/ramda/src/internal/_has.js"(exports2, module2) {
    function _has(prop, obj) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    module2.exports = _has;
  }
});

// ../node_modules/ramda/src/internal/_isArguments.js
var require_isArguments2 = __commonJS({
  "../node_modules/ramda/src/internal/_isArguments.js"(exports2, module2) {
    var _has = require_has();
    var toString = Object.prototype.toString;
    var _isArguments = function() {
      return toString.call(arguments) === "[object Arguments]" ? function _isArguments2(x) {
        return toString.call(x) === "[object Arguments]";
      } : function _isArguments2(x) {
        return _has("callee", x);
      };
    };
    module2.exports = _isArguments;
  }
});

// ../node_modules/ramda/src/keys.js
var require_keys3 = __commonJS({
  "../node_modules/ramda/src/keys.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _has = require_has();
    var _isArguments = require_isArguments2();
    var hasEnumBug = !/* @__PURE__ */ { toString: null }.propertyIsEnumerable("toString");
    var nonEnumerableProps = ["constructor", "valueOf", "isPrototypeOf", "toString", "propertyIsEnumerable", "hasOwnProperty", "toLocaleString"];
    var hasArgsEnumBug = /* @__PURE__ */ function() {
      "use strict";
      return arguments.propertyIsEnumerable("length");
    }();
    var contains = function contains2(list, item) {
      var idx = 0;
      while (idx < list.length) {
        if (list[idx] === item) {
          return true;
        }
        idx += 1;
      }
      return false;
    };
    var _keys = typeof Object.keys === "function" && !hasArgsEnumBug ? function keys2(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    } : function keys2(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, nIdx;
      var ks = [];
      var checkArgsLength = hasArgsEnumBug && _isArguments(obj);
      for (prop in obj) {
        if (_has(prop, obj) && (!checkArgsLength || prop !== "length")) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    };
    var keys = /* @__PURE__ */ _curry1(_keys);
    module2.exports = keys;
  }
});

// ../node_modules/ramda/src/map.js
var require_map3 = __commonJS({
  "../node_modules/ramda/src/map.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _map = require_map2();
    var _reduce = require_reduce();
    var _xmap = require_xmap();
    var curryN = require_curryN2();
    var keys = require_keys3();
    var map = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["fantasy-land/map", "map"], _xmap, function map2(fn, functor) {
      switch (Object.prototype.toString.call(functor)) {
        case "[object Function]":
          return curryN(functor.length, function() {
            return fn.call(this, functor.apply(this, arguments));
          });
        case "[object Object]":
          return _reduce(function(acc, key) {
            acc[key] = fn(functor[key]);
            return acc;
          }, {}, keys(functor));
        default:
          return _map(fn, functor);
      }
    }));
    module2.exports = map;
  }
});

// ../node_modules/ramda/src/path.js
var require_path2 = __commonJS({
  "../node_modules/ramda/src/path.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var path = /* @__PURE__ */ _curry2(function path2(paths, obj) {
      var val = obj;
      var idx = 0;
      while (idx < paths.length) {
        if (val == null) {
          return;
        }
        val = val[paths[idx]];
        idx += 1;
      }
      return val;
    });
    module2.exports = path;
  }
});

// ../node_modules/ramda/src/prop.js
var require_prop = __commonJS({
  "../node_modules/ramda/src/prop.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var path = require_path2();
    var prop = /* @__PURE__ */ _curry2(function prop2(p, obj) {
      return path([p], obj);
    });
    module2.exports = prop;
  }
});

// ../node_modules/ramda/src/pluck.js
var require_pluck = __commonJS({
  "../node_modules/ramda/src/pluck.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var map = require_map3();
    var prop = require_prop();
    var pluck = /* @__PURE__ */ _curry2(function pluck2(p, list) {
      return map(prop(p), list);
    });
    module2.exports = pluck;
  }
});

// ../node_modules/ramda/src/reduce.js
var require_reduce2 = __commonJS({
  "../node_modules/ramda/src/reduce.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var _reduce = require_reduce();
    var reduce = /* @__PURE__ */ _curry3(_reduce);
    module2.exports = reduce;
  }
});

// ../node_modules/ramda/src/allPass.js
var require_allPass = __commonJS({
  "../node_modules/ramda/src/allPass.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var curryN = require_curryN2();
    var max = require_max();
    var pluck = require_pluck();
    var reduce = require_reduce2();
    var allPass = /* @__PURE__ */ _curry1(function allPass2(preds) {
      return curryN(reduce(max, 0, pluck("length", preds)), function() {
        var idx = 0;
        var len = preds.length;
        while (idx < len) {
          if (!preds[idx].apply(this, arguments)) {
            return false;
          }
          idx += 1;
        }
        return true;
      });
    });
    module2.exports = allPass;
  }
});

// ../node_modules/ramda/src/and.js
var require_and = __commonJS({
  "../node_modules/ramda/src/and.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var and = /* @__PURE__ */ _curry2(function and2(a, b) {
      return a && b;
    });
    module2.exports = and;
  }
});

// ../node_modules/ramda/src/internal/_xany.js
var require_xany = __commonJS({
  "../node_modules/ramda/src/internal/_xany.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduced = require_reduced();
    var _xfBase = require_xfBase();
    var XAny = /* @__PURE__ */ function() {
      function XAny2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.any = false;
      }
      XAny2.prototype["@@transducer/init"] = _xfBase.init;
      XAny2.prototype["@@transducer/result"] = function(result) {
        if (!this.any) {
          result = this.xf["@@transducer/step"](result, false);
        }
        return this.xf["@@transducer/result"](result);
      };
      XAny2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f(input)) {
          this.any = true;
          result = _reduced(this.xf["@@transducer/step"](result, true));
        }
        return result;
      };
      return XAny2;
    }();
    var _xany = /* @__PURE__ */ _curry2(function _xany2(f, xf) {
      return new XAny(f, xf);
    });
    module2.exports = _xany;
  }
});

// ../node_modules/ramda/src/any.js
var require_any = __commonJS({
  "../node_modules/ramda/src/any.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xany = require_xany();
    var any = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["any"], _xany, function any2(fn, list) {
      var idx = 0;
      while (idx < list.length) {
        if (fn(list[idx])) {
          return true;
        }
        idx += 1;
      }
      return false;
    }));
    module2.exports = any;
  }
});

// ../node_modules/ramda/src/anyPass.js
var require_anyPass = __commonJS({
  "../node_modules/ramda/src/anyPass.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var curryN = require_curryN2();
    var max = require_max();
    var pluck = require_pluck();
    var reduce = require_reduce2();
    var anyPass = /* @__PURE__ */ _curry1(function anyPass2(preds) {
      return curryN(reduce(max, 0, pluck("length", preds)), function() {
        var idx = 0;
        var len = preds.length;
        while (idx < len) {
          if (preds[idx].apply(this, arguments)) {
            return true;
          }
          idx += 1;
        }
        return false;
      });
    });
    module2.exports = anyPass;
  }
});

// ../node_modules/ramda/src/ap.js
var require_ap = __commonJS({
  "../node_modules/ramda/src/ap.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry2 = require_curry2();
    var _reduce = require_reduce();
    var map = require_map3();
    var ap = /* @__PURE__ */ _curry2(function ap2(applyF, applyX) {
      return typeof applyX["fantasy-land/ap"] === "function" ? applyX["fantasy-land/ap"](applyF) : typeof applyF.ap === "function" ? applyF.ap(applyX) : typeof applyF === "function" ? function(x) {
        return applyF(x)(applyX(x));
      } : _reduce(function(acc, f) {
        return _concat(acc, map(f, applyX));
      }, [], applyF);
    });
    module2.exports = ap;
  }
});

// ../node_modules/ramda/src/internal/_aperture.js
var require_aperture = __commonJS({
  "../node_modules/ramda/src/internal/_aperture.js"(exports2, module2) {
    function _aperture(n, list) {
      var idx = 0;
      var limit = list.length - (n - 1);
      var acc = new Array(limit >= 0 ? limit : 0);
      while (idx < limit) {
        acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
        idx += 1;
      }
      return acc;
    }
    module2.exports = _aperture;
  }
});

// ../node_modules/ramda/src/internal/_xaperture.js
var require_xaperture = __commonJS({
  "../node_modules/ramda/src/internal/_xaperture.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XAperture = /* @__PURE__ */ function() {
      function XAperture2(n, xf) {
        this.xf = xf;
        this.pos = 0;
        this.full = false;
        this.acc = new Array(n);
      }
      XAperture2.prototype["@@transducer/init"] = _xfBase.init;
      XAperture2.prototype["@@transducer/result"] = function(result) {
        this.acc = null;
        return this.xf["@@transducer/result"](result);
      };
      XAperture2.prototype["@@transducer/step"] = function(result, input) {
        this.store(input);
        return this.full ? this.xf["@@transducer/step"](result, this.getCopy()) : result;
      };
      XAperture2.prototype.store = function(input) {
        this.acc[this.pos] = input;
        this.pos += 1;
        if (this.pos === this.acc.length) {
          this.pos = 0;
          this.full = true;
        }
      };
      XAperture2.prototype.getCopy = function() {
        return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
      };
      return XAperture2;
    }();
    var _xaperture = /* @__PURE__ */ _curry2(function _xaperture2(n, xf) {
      return new XAperture(n, xf);
    });
    module2.exports = _xaperture;
  }
});

// ../node_modules/ramda/src/aperture.js
var require_aperture2 = __commonJS({
  "../node_modules/ramda/src/aperture.js"(exports2, module2) {
    var _aperture = require_aperture();
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xaperture = require_xaperture();
    var aperture = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xaperture, _aperture));
    module2.exports = aperture;
  }
});

// ../node_modules/ramda/src/append.js
var require_append = __commonJS({
  "../node_modules/ramda/src/append.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry2 = require_curry2();
    var append = /* @__PURE__ */ _curry2(function append2(el, list) {
      return _concat(list, [el]);
    });
    module2.exports = append;
  }
});

// ../node_modules/ramda/src/apply.js
var require_apply = __commonJS({
  "../node_modules/ramda/src/apply.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var apply = /* @__PURE__ */ _curry2(function apply2(fn, args) {
      return fn.apply(this, args);
    });
    module2.exports = apply;
  }
});

// ../node_modules/ramda/src/values.js
var require_values2 = __commonJS({
  "../node_modules/ramda/src/values.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var keys = require_keys3();
    var values = /* @__PURE__ */ _curry1(function values2(obj) {
      var props = keys(obj);
      var len = props.length;
      var vals = [];
      var idx = 0;
      while (idx < len) {
        vals[idx] = obj[props[idx]];
        idx += 1;
      }
      return vals;
    });
    module2.exports = values;
  }
});

// ../node_modules/ramda/src/applySpec.js
var require_applySpec = __commonJS({
  "../node_modules/ramda/src/applySpec.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var apply = require_apply();
    var curryN = require_curryN2();
    var map = require_map3();
    var max = require_max();
    var pluck = require_pluck();
    var reduce = require_reduce2();
    var values = require_values2();
    var applySpec = /* @__PURE__ */ _curry1(function applySpec2(spec) {
      spec = map(function(v) {
        return typeof v == "function" ? v : applySpec2(v);
      }, spec);
      return curryN(reduce(max, 0, pluck("length", values(spec))), function() {
        var args = arguments;
        return map(function(f) {
          return apply(f, args);
        }, spec);
      });
    });
    module2.exports = applySpec;
  }
});

// ../node_modules/ramda/src/applyTo.js
var require_applyTo = __commonJS({
  "../node_modules/ramda/src/applyTo.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var applyTo = /* @__PURE__ */ _curry2(function applyTo2(x, f) {
      return f(x);
    });
    module2.exports = applyTo;
  }
});

// ../node_modules/ramda/src/ascend.js
var require_ascend = __commonJS({
  "../node_modules/ramda/src/ascend.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var ascend = /* @__PURE__ */ _curry3(function ascend2(fn, a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
    module2.exports = ascend;
  }
});

// ../node_modules/ramda/src/assoc.js
var require_assoc = __commonJS({
  "../node_modules/ramda/src/assoc.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var assoc = /* @__PURE__ */ _curry3(function assoc2(prop, val, obj) {
      var result = {};
      for (var p in obj) {
        result[p] = obj[p];
      }
      result[prop] = val;
      return result;
    });
    module2.exports = assoc;
  }
});

// ../node_modules/ramda/src/internal/_isInteger.js
var require_isInteger = __commonJS({
  "../node_modules/ramda/src/internal/_isInteger.js"(exports2, module2) {
    module2.exports = Number.isInteger || function _isInteger(n) {
      return n << 0 === n;
    };
  }
});

// ../node_modules/ramda/src/isNil.js
var require_isNil = __commonJS({
  "../node_modules/ramda/src/isNil.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var isNil = /* @__PURE__ */ _curry1(function isNil2(x) {
      return x == null;
    });
    module2.exports = isNil;
  }
});

// ../node_modules/ramda/src/assocPath.js
var require_assocPath = __commonJS({
  "../node_modules/ramda/src/assocPath.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var _has = require_has();
    var _isArray = require_isArray2();
    var _isInteger = require_isInteger();
    var assoc = require_assoc();
    var isNil = require_isNil();
    var assocPath = /* @__PURE__ */ _curry3(function assocPath2(path, val, obj) {
      if (path.length === 0) {
        return val;
      }
      var idx = path[0];
      if (path.length > 1) {
        var nextObj = !isNil(obj) && _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
        val = assocPath2(Array.prototype.slice.call(path, 1), val, nextObj);
      }
      if (_isInteger(idx) && _isArray(obj)) {
        var arr = [].concat(obj);
        arr[idx] = val;
        return arr;
      } else {
        return assoc(idx, val, obj);
      }
    });
    module2.exports = assocPath;
  }
});

// ../node_modules/ramda/src/nAry.js
var require_nAry = __commonJS({
  "../node_modules/ramda/src/nAry.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var nAry = /* @__PURE__ */ _curry2(function nAry2(n, fn) {
      switch (n) {
        case 0:
          return function() {
            return fn.call(this);
          };
        case 1:
          return function(a0) {
            return fn.call(this, a0);
          };
        case 2:
          return function(a0, a1) {
            return fn.call(this, a0, a1);
          };
        case 3:
          return function(a0, a1, a2) {
            return fn.call(this, a0, a1, a2);
          };
        case 4:
          return function(a0, a1, a2, a3) {
            return fn.call(this, a0, a1, a2, a3);
          };
        case 5:
          return function(a0, a1, a2, a3, a4) {
            return fn.call(this, a0, a1, a2, a3, a4);
          };
        case 6:
          return function(a0, a1, a2, a3, a4, a5) {
            return fn.call(this, a0, a1, a2, a3, a4, a5);
          };
        case 7:
          return function(a0, a1, a2, a3, a4, a5, a6) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
          };
        case 8:
          return function(a0, a1, a2, a3, a4, a5, a6, a7) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
          };
        case 9:
          return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
          };
        case 10:
          return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
            return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
          };
        default:
          throw new Error("First argument to nAry must be a non-negative integer no greater than ten");
      }
    });
    module2.exports = nAry;
  }
});

// ../node_modules/ramda/src/binary.js
var require_binary = __commonJS({
  "../node_modules/ramda/src/binary.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var nAry = require_nAry();
    var binary = /* @__PURE__ */ _curry1(function binary2(fn) {
      return nAry(2, fn);
    });
    module2.exports = binary;
  }
});

// ../node_modules/ramda/src/internal/_isFunction.js
var require_isFunction2 = __commonJS({
  "../node_modules/ramda/src/internal/_isFunction.js"(exports2, module2) {
    function _isFunction(x) {
      return Object.prototype.toString.call(x) === "[object Function]";
    }
    module2.exports = _isFunction;
  }
});

// ../node_modules/ramda/src/liftN.js
var require_liftN = __commonJS({
  "../node_modules/ramda/src/liftN.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduce = require_reduce();
    var ap = require_ap();
    var curryN = require_curryN2();
    var map = require_map3();
    var liftN = /* @__PURE__ */ _curry2(function liftN2(arity, fn) {
      var lifted = curryN(arity, fn);
      return curryN(arity, function() {
        return _reduce(ap, map(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
      });
    });
    module2.exports = liftN;
  }
});

// ../node_modules/ramda/src/lift.js
var require_lift = __commonJS({
  "../node_modules/ramda/src/lift.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var liftN = require_liftN();
    var lift = /* @__PURE__ */ _curry1(function lift2(fn) {
      return liftN(fn.length, fn);
    });
    module2.exports = lift;
  }
});

// ../node_modules/ramda/src/both.js
var require_both = __commonJS({
  "../node_modules/ramda/src/both.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isFunction = require_isFunction2();
    var and = require_and();
    var lift = require_lift();
    var both = /* @__PURE__ */ _curry2(function both2(f, g) {
      return _isFunction(f) ? function _both() {
        return f.apply(this, arguments) && g.apply(this, arguments);
      } : lift(and)(f, g);
    });
    module2.exports = both;
  }
});

// ../node_modules/ramda/src/curry.js
var require_curry = __commonJS({
  "../node_modules/ramda/src/curry.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var curryN = require_curryN2();
    var curry = /* @__PURE__ */ _curry1(function curry2(fn) {
      return curryN(fn.length, fn);
    });
    module2.exports = curry;
  }
});

// ../node_modules/ramda/src/call.js
var require_call = __commonJS({
  "../node_modules/ramda/src/call.js"(exports2, module2) {
    var curry = require_curry();
    var call = /* @__PURE__ */ curry(function call2(fn) {
      return fn.apply(this, Array.prototype.slice.call(arguments, 1));
    });
    module2.exports = call;
  }
});

// ../node_modules/ramda/src/internal/_makeFlat.js
var require_makeFlat = __commonJS({
  "../node_modules/ramda/src/internal/_makeFlat.js"(exports2, module2) {
    var _isArrayLike = require_isArrayLike2();
    function _makeFlat(recursive) {
      return function flatt(list) {
        var value, jlen, j;
        var result = [];
        var idx = 0;
        var ilen = list.length;
        while (idx < ilen) {
          if (_isArrayLike(list[idx])) {
            value = recursive ? flatt(list[idx]) : list[idx];
            j = 0;
            jlen = value.length;
            while (j < jlen) {
              result[result.length] = value[j];
              j += 1;
            }
          } else {
            result[result.length] = list[idx];
          }
          idx += 1;
        }
        return result;
      };
    }
    module2.exports = _makeFlat;
  }
});

// ../node_modules/ramda/src/internal/_forceReduced.js
var require_forceReduced = __commonJS({
  "../node_modules/ramda/src/internal/_forceReduced.js"(exports2, module2) {
    function _forceReduced(x) {
      return {
        "@@transducer/value": x,
        "@@transducer/reduced": true
      };
    }
    module2.exports = _forceReduced;
  }
});

// ../node_modules/ramda/src/internal/_flatCat.js
var require_flatCat = __commonJS({
  "../node_modules/ramda/src/internal/_flatCat.js"(exports2, module2) {
    var _forceReduced = require_forceReduced();
    var _isArrayLike = require_isArrayLike2();
    var _reduce = require_reduce();
    var _xfBase = require_xfBase();
    var preservingReduced = function(xf) {
      return {
        "@@transducer/init": _xfBase.init,
        "@@transducer/result": function(result) {
          return xf["@@transducer/result"](result);
        },
        "@@transducer/step": function(result, input) {
          var ret = xf["@@transducer/step"](result, input);
          return ret["@@transducer/reduced"] ? _forceReduced(ret) : ret;
        }
      };
    };
    var _flatCat = function _xcat(xf) {
      var rxf = preservingReduced(xf);
      return {
        "@@transducer/init": _xfBase.init,
        "@@transducer/result": function(result) {
          return rxf["@@transducer/result"](result);
        },
        "@@transducer/step": function(result, input) {
          return !_isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
        }
      };
    };
    module2.exports = _flatCat;
  }
});

// ../node_modules/ramda/src/internal/_xchain.js
var require_xchain = __commonJS({
  "../node_modules/ramda/src/internal/_xchain.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _flatCat = require_flatCat();
    var map = require_map3();
    var _xchain = /* @__PURE__ */ _curry2(function _xchain2(f, xf) {
      return map(f, _flatCat(xf));
    });
    module2.exports = _xchain;
  }
});

// ../node_modules/ramda/src/chain.js
var require_chain = __commonJS({
  "../node_modules/ramda/src/chain.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _makeFlat = require_makeFlat();
    var _xchain = require_xchain();
    var map = require_map3();
    var chain = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["fantasy-land/chain", "chain"], _xchain, function chain2(fn, monad) {
      if (typeof monad === "function") {
        return function(x) {
          return fn(monad(x))(x);
        };
      }
      return _makeFlat(false)(map(fn, monad));
    }));
    module2.exports = chain;
  }
});

// ../node_modules/ramda/src/clamp.js
var require_clamp = __commonJS({
  "../node_modules/ramda/src/clamp.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var clamp = /* @__PURE__ */ _curry3(function clamp2(min, max, value) {
      if (min > max) {
        throw new Error("min must not be greater than max in clamp(min, max, value)");
      }
      return value < min ? min : value > max ? max : value;
    });
    module2.exports = clamp;
  }
});

// ../node_modules/ramda/src/internal/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "../node_modules/ramda/src/internal/_cloneRegExp.js"(exports2, module2) {
    function _cloneRegExp(pattern) {
      return new RegExp(pattern.source, (pattern.global ? "g" : "") + (pattern.ignoreCase ? "i" : "") + (pattern.multiline ? "m" : "") + (pattern.sticky ? "y" : "") + (pattern.unicode ? "u" : ""));
    }
    module2.exports = _cloneRegExp;
  }
});

// ../node_modules/ramda/src/type.js
var require_type = __commonJS({
  "../node_modules/ramda/src/type.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var type = /* @__PURE__ */ _curry1(function type2(val) {
      return val === null ? "Null" : val === void 0 ? "Undefined" : Object.prototype.toString.call(val).slice(8, -1);
    });
    module2.exports = type;
  }
});

// ../node_modules/ramda/src/internal/_clone.js
var require_clone2 = __commonJS({
  "../node_modules/ramda/src/internal/_clone.js"(exports2, module2) {
    var _cloneRegExp = require_cloneRegExp();
    var type = require_type();
    function _clone(value, refFrom, refTo, deep) {
      var copy = function copy2(copiedValue) {
        var len = refFrom.length;
        var idx = 0;
        while (idx < len) {
          if (value === refFrom[idx]) {
            return refTo[idx];
          }
          idx += 1;
        }
        refFrom[idx + 1] = value;
        refTo[idx + 1] = copiedValue;
        for (var key in value) {
          copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
        }
        return copiedValue;
      };
      switch (type(value)) {
        case "Object":
          return copy({});
        case "Array":
          return copy([]);
        case "Date":
          return new Date(value.valueOf());
        case "RegExp":
          return _cloneRegExp(value);
        default:
          return value;
      }
    }
    module2.exports = _clone;
  }
});

// ../node_modules/ramda/src/clone.js
var require_clone3 = __commonJS({
  "../node_modules/ramda/src/clone.js"(exports2, module2) {
    var _clone = require_clone2();
    var _curry1 = require_curry1();
    var clone = /* @__PURE__ */ _curry1(function clone2(value) {
      return value != null && typeof value.clone === "function" ? value.clone() : _clone(value, [], [], true);
    });
    module2.exports = clone;
  }
});

// ../node_modules/ramda/src/comparator.js
var require_comparator = __commonJS({
  "../node_modules/ramda/src/comparator.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var comparator = /* @__PURE__ */ _curry1(function comparator2(pred) {
      return function(a, b) {
        return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
      };
    });
    module2.exports = comparator;
  }
});

// ../node_modules/ramda/src/not.js
var require_not = __commonJS({
  "../node_modules/ramda/src/not.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var not = /* @__PURE__ */ _curry1(function not2(a) {
      return !a;
    });
    module2.exports = not;
  }
});

// ../node_modules/ramda/src/complement.js
var require_complement = __commonJS({
  "../node_modules/ramda/src/complement.js"(exports2, module2) {
    var lift = require_lift();
    var not = require_not();
    var complement = /* @__PURE__ */ lift(not);
    module2.exports = complement;
  }
});

// ../node_modules/ramda/src/internal/_pipe.js
var require_pipe = __commonJS({
  "../node_modules/ramda/src/internal/_pipe.js"(exports2, module2) {
    function _pipe(f, g) {
      return function() {
        return g.call(this, f.apply(this, arguments));
      };
    }
    module2.exports = _pipe;
  }
});

// ../node_modules/ramda/src/internal/_checkForMethod.js
var require_checkForMethod = __commonJS({
  "../node_modules/ramda/src/internal/_checkForMethod.js"(exports2, module2) {
    var _isArray = require_isArray2();
    function _checkForMethod(methodname, fn) {
      return function() {
        var length = arguments.length;
        if (length === 0) {
          return fn();
        }
        var obj = arguments[length - 1];
        return _isArray(obj) || typeof obj[methodname] !== "function" ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
      };
    }
    module2.exports = _checkForMethod;
  }
});

// ../node_modules/ramda/src/slice.js
var require_slice = __commonJS({
  "../node_modules/ramda/src/slice.js"(exports2, module2) {
    var _checkForMethod = require_checkForMethod();
    var _curry3 = require_curry3();
    var slice = /* @__PURE__ */ _curry3(/* @__PURE__ */ _checkForMethod("slice", function slice2(fromIndex, toIndex, list) {
      return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));
    module2.exports = slice;
  }
});

// ../node_modules/ramda/src/tail.js
var require_tail = __commonJS({
  "../node_modules/ramda/src/tail.js"(exports2, module2) {
    var _checkForMethod = require_checkForMethod();
    var _curry1 = require_curry1();
    var slice = require_slice();
    var tail = /* @__PURE__ */ _curry1(/* @__PURE__ */ _checkForMethod("tail", /* @__PURE__ */ slice(1, Infinity)));
    module2.exports = tail;
  }
});

// ../node_modules/ramda/src/pipe.js
var require_pipe2 = __commonJS({
  "../node_modules/ramda/src/pipe.js"(exports2, module2) {
    var _arity = require_arity();
    var _pipe = require_pipe();
    var reduce = require_reduce2();
    var tail = require_tail();
    function pipe() {
      if (arguments.length === 0) {
        throw new Error("pipe requires at least one argument");
      }
      return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    }
    module2.exports = pipe;
  }
});

// ../node_modules/ramda/src/reverse.js
var require_reverse = __commonJS({
  "../node_modules/ramda/src/reverse.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _isString = require_isString2();
    var reverse = /* @__PURE__ */ _curry1(function reverse2(list) {
      return _isString(list) ? list.split("").reverse().join("") : Array.prototype.slice.call(list, 0).reverse();
    });
    module2.exports = reverse;
  }
});

// ../node_modules/ramda/src/compose.js
var require_compose = __commonJS({
  "../node_modules/ramda/src/compose.js"(exports2, module2) {
    var pipe = require_pipe2();
    var reverse = require_reverse();
    function compose() {
      if (arguments.length === 0) {
        throw new Error("compose requires at least one argument");
      }
      return pipe.apply(this, reverse(arguments));
    }
    module2.exports = compose;
  }
});

// ../node_modules/ramda/src/composeK.js
var require_composeK = __commonJS({
  "../node_modules/ramda/src/composeK.js"(exports2, module2) {
    var chain = require_chain();
    var compose = require_compose();
    var map = require_map3();
    function composeK() {
      if (arguments.length === 0) {
        throw new Error("composeK requires at least one argument");
      }
      var init = Array.prototype.slice.call(arguments);
      var last = init.pop();
      return compose(compose.apply(this, map(chain, init)), last);
    }
    module2.exports = composeK;
  }
});

// ../node_modules/ramda/src/internal/_pipeP.js
var require_pipeP = __commonJS({
  "../node_modules/ramda/src/internal/_pipeP.js"(exports2, module2) {
    function _pipeP(f, g) {
      return function() {
        var ctx = this;
        return f.apply(ctx, arguments).then(function(x) {
          return g.call(ctx, x);
        });
      };
    }
    module2.exports = _pipeP;
  }
});

// ../node_modules/ramda/src/pipeP.js
var require_pipeP2 = __commonJS({
  "../node_modules/ramda/src/pipeP.js"(exports2, module2) {
    var _arity = require_arity();
    var _pipeP = require_pipeP();
    var reduce = require_reduce2();
    var tail = require_tail();
    function pipeP() {
      if (arguments.length === 0) {
        throw new Error("pipeP requires at least one argument");
      }
      return _arity(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    }
    module2.exports = pipeP;
  }
});

// ../node_modules/ramda/src/composeP.js
var require_composeP = __commonJS({
  "../node_modules/ramda/src/composeP.js"(exports2, module2) {
    var pipeP = require_pipeP2();
    var reverse = require_reverse();
    function composeP() {
      if (arguments.length === 0) {
        throw new Error("composeP requires at least one argument");
      }
      return pipeP.apply(this, reverse(arguments));
    }
    module2.exports = composeP;
  }
});

// ../node_modules/ramda/src/internal/_arrayFromIterator.js
var require_arrayFromIterator = __commonJS({
  "../node_modules/ramda/src/internal/_arrayFromIterator.js"(exports2, module2) {
    function _arrayFromIterator(iter) {
      var list = [];
      var next;
      while (!(next = iter.next()).done) {
        list.push(next.value);
      }
      return list;
    }
    module2.exports = _arrayFromIterator;
  }
});

// ../node_modules/ramda/src/internal/_containsWith.js
var require_containsWith = __commonJS({
  "../node_modules/ramda/src/internal/_containsWith.js"(exports2, module2) {
    function _containsWith(pred, x, list) {
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        if (pred(x, list[idx])) {
          return true;
        }
        idx += 1;
      }
      return false;
    }
    module2.exports = _containsWith;
  }
});

// ../node_modules/ramda/src/internal/_functionName.js
var require_functionName = __commonJS({
  "../node_modules/ramda/src/internal/_functionName.js"(exports2, module2) {
    function _functionName(f) {
      var match = String(f).match(/^function (\w*)/);
      return match == null ? "" : match[1];
    }
    module2.exports = _functionName;
  }
});

// ../node_modules/ramda/src/identical.js
var require_identical = __commonJS({
  "../node_modules/ramda/src/identical.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var identical = /* @__PURE__ */ _curry2(function identical2(a, b) {
      if (a === b) {
        return a !== 0 || 1 / a === 1 / b;
      } else {
        return a !== a && b !== b;
      }
    });
    module2.exports = identical;
  }
});

// ../node_modules/ramda/src/internal/_equals.js
var require_equals = __commonJS({
  "../node_modules/ramda/src/internal/_equals.js"(exports2, module2) {
    var _arrayFromIterator = require_arrayFromIterator();
    var _containsWith = require_containsWith();
    var _functionName = require_functionName();
    var _has = require_has();
    var identical = require_identical();
    var keys = require_keys3();
    var type = require_type();
    function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
      var a = _arrayFromIterator(aIterator);
      var b = _arrayFromIterator(bIterator);
      function eq(_a, _b) {
        return _equals(_a, _b, stackA.slice(), stackB.slice());
      }
      return !_containsWith(function(b2, aItem) {
        return !_containsWith(eq, aItem, b2);
      }, b, a);
    }
    function _equals(a, b, stackA, stackB) {
      if (identical(a, b)) {
        return true;
      }
      var typeA = type(a);
      if (typeA !== type(b)) {
        return false;
      }
      if (a == null || b == null) {
        return false;
      }
      if (typeof a["fantasy-land/equals"] === "function" || typeof b["fantasy-land/equals"] === "function") {
        return typeof a["fantasy-land/equals"] === "function" && a["fantasy-land/equals"](b) && typeof b["fantasy-land/equals"] === "function" && b["fantasy-land/equals"](a);
      }
      if (typeof a.equals === "function" || typeof b.equals === "function") {
        return typeof a.equals === "function" && a.equals(b) && typeof b.equals === "function" && b.equals(a);
      }
      switch (typeA) {
        case "Arguments":
        case "Array":
        case "Object":
          if (typeof a.constructor === "function" && _functionName(a.constructor) === "Promise") {
            return a === b;
          }
          break;
        case "Boolean":
        case "Number":
        case "String":
          if (!(typeof a === typeof b && identical(a.valueOf(), b.valueOf()))) {
            return false;
          }
          break;
        case "Date":
          if (!identical(a.valueOf(), b.valueOf())) {
            return false;
          }
          break;
        case "Error":
          return a.name === b.name && a.message === b.message;
        case "RegExp":
          if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
            return false;
          }
          break;
      }
      var idx = stackA.length - 1;
      while (idx >= 0) {
        if (stackA[idx] === a) {
          return stackB[idx] === b;
        }
        idx -= 1;
      }
      switch (typeA) {
        case "Map":
          if (a.size !== b.size) {
            return false;
          }
          return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));
        case "Set":
          if (a.size !== b.size) {
            return false;
          }
          return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));
        case "Arguments":
        case "Array":
        case "Object":
        case "Boolean":
        case "Number":
        case "String":
        case "Date":
        case "Error":
        case "RegExp":
        case "Int8Array":
        case "Uint8Array":
        case "Uint8ClampedArray":
        case "Int16Array":
        case "Uint16Array":
        case "Int32Array":
        case "Uint32Array":
        case "Float32Array":
        case "Float64Array":
        case "ArrayBuffer":
          break;
        default:
          return false;
      }
      var keysA = keys(a);
      if (keysA.length !== keys(b).length) {
        return false;
      }
      var extendedStackA = stackA.concat([a]);
      var extendedStackB = stackB.concat([b]);
      idx = keysA.length - 1;
      while (idx >= 0) {
        var key = keysA[idx];
        if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
          return false;
        }
        idx -= 1;
      }
      return true;
    }
    module2.exports = _equals;
  }
});

// ../node_modules/ramda/src/equals.js
var require_equals2 = __commonJS({
  "../node_modules/ramda/src/equals.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _equals = require_equals();
    var equals = /* @__PURE__ */ _curry2(function equals2(a, b) {
      return _equals(a, b, [], []);
    });
    module2.exports = equals;
  }
});

// ../node_modules/ramda/src/internal/_indexOf.js
var require_indexOf = __commonJS({
  "../node_modules/ramda/src/internal/_indexOf.js"(exports2, module2) {
    var equals = require_equals2();
    function _indexOf(list, a, idx) {
      var inf, item;
      if (typeof list.indexOf === "function") {
        switch (typeof a) {
          case "number":
            if (a === 0) {
              inf = 1 / a;
              while (idx < list.length) {
                item = list[idx];
                if (item === 0 && 1 / item === inf) {
                  return idx;
                }
                idx += 1;
              }
              return -1;
            } else if (a !== a) {
              while (idx < list.length) {
                item = list[idx];
                if (typeof item === "number" && item !== item) {
                  return idx;
                }
                idx += 1;
              }
              return -1;
            }
            return list.indexOf(a, idx);
          case "string":
          case "boolean":
          case "function":
          case "undefined":
            return list.indexOf(a, idx);
          case "object":
            if (a === null) {
              return list.indexOf(a, idx);
            }
        }
      }
      while (idx < list.length) {
        if (equals(list[idx], a)) {
          return idx;
        }
        idx += 1;
      }
      return -1;
    }
    module2.exports = _indexOf;
  }
});

// ../node_modules/ramda/src/internal/_contains.js
var require_contains2 = __commonJS({
  "../node_modules/ramda/src/internal/_contains.js"(exports2, module2) {
    var _indexOf = require_indexOf();
    function _contains(a, list) {
      return _indexOf(list, a, 0) >= 0;
    }
    module2.exports = _contains;
  }
});

// ../node_modules/ramda/src/internal/_quote.js
var require_quote = __commonJS({
  "../node_modules/ramda/src/internal/_quote.js"(exports2, module2) {
    function _quote(s) {
      var escaped = s.replace(/\\/g, "\\\\").replace(/[\b]/g, "\\b").replace(/\f/g, "\\f").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t").replace(/\v/g, "\\v").replace(/\0/g, "\\0");
      return '"' + escaped.replace(/"/g, '\\"') + '"';
    }
    module2.exports = _quote;
  }
});

// ../node_modules/ramda/src/internal/_toISOString.js
var require_toISOString = __commonJS({
  "../node_modules/ramda/src/internal/_toISOString.js"(exports2, module2) {
    var pad = function pad2(n) {
      return (n < 10 ? "0" : "") + n;
    };
    var _toISOString = typeof Date.prototype.toISOString === "function" ? function _toISOString2(d) {
      return d.toISOString();
    } : function _toISOString2(d) {
      return d.getUTCFullYear() + "-" + pad(d.getUTCMonth() + 1) + "-" + pad(d.getUTCDate()) + "T" + pad(d.getUTCHours()) + ":" + pad(d.getUTCMinutes()) + ":" + pad(d.getUTCSeconds()) + "." + (d.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z";
    };
    module2.exports = _toISOString;
  }
});

// ../node_modules/ramda/src/internal/_complement.js
var require_complement2 = __commonJS({
  "../node_modules/ramda/src/internal/_complement.js"(exports2, module2) {
    function _complement(f) {
      return function() {
        return !f.apply(this, arguments);
      };
    }
    module2.exports = _complement;
  }
});

// ../node_modules/ramda/src/internal/_filter.js
var require_filter = __commonJS({
  "../node_modules/ramda/src/internal/_filter.js"(exports2, module2) {
    function _filter(fn, list) {
      var idx = 0;
      var len = list.length;
      var result = [];
      while (idx < len) {
        if (fn(list[idx])) {
          result[result.length] = list[idx];
        }
        idx += 1;
      }
      return result;
    }
    module2.exports = _filter;
  }
});

// ../node_modules/ramda/src/internal/_isObject.js
var require_isObject2 = __commonJS({
  "../node_modules/ramda/src/internal/_isObject.js"(exports2, module2) {
    function _isObject(x) {
      return Object.prototype.toString.call(x) === "[object Object]";
    }
    module2.exports = _isObject;
  }
});

// ../node_modules/ramda/src/internal/_xfilter.js
var require_xfilter = __commonJS({
  "../node_modules/ramda/src/internal/_xfilter.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XFilter = /* @__PURE__ */ function() {
      function XFilter2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XFilter2.prototype["@@transducer/init"] = _xfBase.init;
      XFilter2.prototype["@@transducer/result"] = _xfBase.result;
      XFilter2.prototype["@@transducer/step"] = function(result, input) {
        return this.f(input) ? this.xf["@@transducer/step"](result, input) : result;
      };
      return XFilter2;
    }();
    var _xfilter = /* @__PURE__ */ _curry2(function _xfilter2(f, xf) {
      return new XFilter(f, xf);
    });
    module2.exports = _xfilter;
  }
});

// ../node_modules/ramda/src/filter.js
var require_filter2 = __commonJS({
  "../node_modules/ramda/src/filter.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _filter = require_filter();
    var _isObject = require_isObject2();
    var _reduce = require_reduce();
    var _xfilter = require_xfilter();
    var keys = require_keys3();
    var filter = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["filter"], _xfilter, function(pred, filterable) {
      return _isObject(filterable) ? _reduce(function(acc, key) {
        if (pred(filterable[key])) {
          acc[key] = filterable[key];
        }
        return acc;
      }, {}, keys(filterable)) : _filter(pred, filterable);
    }));
    module2.exports = filter;
  }
});

// ../node_modules/ramda/src/reject.js
var require_reject = __commonJS({
  "../node_modules/ramda/src/reject.js"(exports2, module2) {
    var _complement = require_complement2();
    var _curry2 = require_curry2();
    var filter = require_filter2();
    var reject2 = /* @__PURE__ */ _curry2(function reject3(pred, filterable) {
      return filter(_complement(pred), filterable);
    });
    module2.exports = reject2;
  }
});

// ../node_modules/ramda/src/internal/_toString.js
var require_toString = __commonJS({
  "../node_modules/ramda/src/internal/_toString.js"(exports2, module2) {
    var _contains = require_contains2();
    var _map = require_map2();
    var _quote = require_quote();
    var _toISOString = require_toISOString();
    var keys = require_keys3();
    var reject2 = require_reject();
    function _toString(x, seen) {
      var recur = function recur2(y) {
        var xs = seen.concat([x]);
        return _contains(y, xs) ? "<Circular>" : _toString(y, xs);
      };
      var mapPairs = function(obj, keys2) {
        return _map(function(k) {
          return _quote(k) + ": " + recur(obj[k]);
        }, keys2.slice().sort());
      };
      switch (Object.prototype.toString.call(x)) {
        case "[object Arguments]":
          return "(function() { return arguments; }(" + _map(recur, x).join(", ") + "))";
        case "[object Array]":
          return "[" + _map(recur, x).concat(mapPairs(x, reject2(function(k) {
            return /^\d+$/.test(k);
          }, keys(x)))).join(", ") + "]";
        case "[object Boolean]":
          return typeof x === "object" ? "new Boolean(" + recur(x.valueOf()) + ")" : x.toString();
        case "[object Date]":
          return "new Date(" + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ")";
        case "[object Null]":
          return "null";
        case "[object Number]":
          return typeof x === "object" ? "new Number(" + recur(x.valueOf()) + ")" : 1 / x === -Infinity ? "-0" : x.toString(10);
        case "[object String]":
          return typeof x === "object" ? "new String(" + recur(x.valueOf()) + ")" : _quote(x);
        case "[object Undefined]":
          return "undefined";
        default:
          if (typeof x.toString === "function") {
            var repr = x.toString();
            if (repr !== "[object Object]") {
              return repr;
            }
          }
          return "{" + mapPairs(x, keys(x)).join(", ") + "}";
      }
    }
    module2.exports = _toString;
  }
});

// ../node_modules/ramda/src/toString.js
var require_toString2 = __commonJS({
  "../node_modules/ramda/src/toString.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _toString = require_toString();
    var toString = /* @__PURE__ */ _curry1(function toString2(val) {
      return _toString(val, []);
    });
    module2.exports = toString;
  }
});

// ../node_modules/ramda/src/concat.js
var require_concat2 = __commonJS({
  "../node_modules/ramda/src/concat.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isArray = require_isArray2();
    var _isFunction = require_isFunction2();
    var _isString = require_isString2();
    var toString = require_toString2();
    var concat = /* @__PURE__ */ _curry2(function concat2(a, b) {
      if (_isArray(a)) {
        if (_isArray(b)) {
          return a.concat(b);
        }
        throw new TypeError(toString(b) + " is not an array");
      }
      if (_isString(a)) {
        if (_isString(b)) {
          return a + b;
        }
        throw new TypeError(toString(b) + " is not a string");
      }
      if (a != null && _isFunction(a["fantasy-land/concat"])) {
        return a["fantasy-land/concat"](b);
      }
      if (a != null && _isFunction(a.concat)) {
        return a.concat(b);
      }
      throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
    });
    module2.exports = concat;
  }
});

// ../node_modules/ramda/src/cond.js
var require_cond = __commonJS({
  "../node_modules/ramda/src/cond.js"(exports2, module2) {
    var _arity = require_arity();
    var _curry1 = require_curry1();
    var map = require_map3();
    var max = require_max();
    var reduce = require_reduce2();
    var cond = /* @__PURE__ */ _curry1(function cond2(pairs) {
      var arity = reduce(max, 0, map(function(pair) {
        return pair[0].length;
      }, pairs));
      return _arity(arity, function() {
        var idx = 0;
        while (idx < pairs.length) {
          if (pairs[idx][0].apply(this, arguments)) {
            return pairs[idx][1].apply(this, arguments);
          }
          idx += 1;
        }
      });
    });
    module2.exports = cond;
  }
});

// ../node_modules/ramda/src/constructN.js
var require_constructN = __commonJS({
  "../node_modules/ramda/src/constructN.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var curry = require_curry();
    var nAry = require_nAry();
    var constructN = /* @__PURE__ */ _curry2(function constructN2(n, Fn) {
      if (n > 10) {
        throw new Error("Constructor with greater than ten arguments");
      }
      if (n === 0) {
        return function() {
          return new Fn();
        };
      }
      return curry(nAry(n, function($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
        switch (arguments.length) {
          case 1:
            return new Fn($0);
          case 2:
            return new Fn($0, $1);
          case 3:
            return new Fn($0, $1, $2);
          case 4:
            return new Fn($0, $1, $2, $3);
          case 5:
            return new Fn($0, $1, $2, $3, $4);
          case 6:
            return new Fn($0, $1, $2, $3, $4, $5);
          case 7:
            return new Fn($0, $1, $2, $3, $4, $5, $6);
          case 8:
            return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
          case 9:
            return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
          case 10:
            return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
        }
      }));
    });
    module2.exports = constructN;
  }
});

// ../node_modules/ramda/src/construct.js
var require_construct = __commonJS({
  "../node_modules/ramda/src/construct.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var constructN = require_constructN();
    var construct = /* @__PURE__ */ _curry1(function construct2(Fn) {
      return constructN(Fn.length, Fn);
    });
    module2.exports = construct;
  }
});

// ../node_modules/ramda/src/contains.js
var require_contains3 = __commonJS({
  "../node_modules/ramda/src/contains.js"(exports2, module2) {
    var _contains = require_contains2();
    var _curry2 = require_curry2();
    var contains = /* @__PURE__ */ _curry2(_contains);
    module2.exports = contains;
  }
});

// ../node_modules/ramda/src/converge.js
var require_converge = __commonJS({
  "../node_modules/ramda/src/converge.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _map = require_map2();
    var curryN = require_curryN2();
    var max = require_max();
    var pluck = require_pluck();
    var reduce = require_reduce2();
    var converge = /* @__PURE__ */ _curry2(function converge2(after, fns) {
      return curryN(reduce(max, 0, pluck("length", fns)), function() {
        var args = arguments;
        var context = this;
        return after.apply(context, _map(function(fn) {
          return fn.apply(context, args);
        }, fns));
      });
    });
    module2.exports = converge;
  }
});

// ../node_modules/ramda/src/internal/_xreduceBy.js
var require_xreduceBy = __commonJS({
  "../node_modules/ramda/src/internal/_xreduceBy.js"(exports2, module2) {
    var _curryN = require_curryN();
    var _has = require_has();
    var _xfBase = require_xfBase();
    var XReduceBy = /* @__PURE__ */ function() {
      function XReduceBy2(valueFn, valueAcc, keyFn, xf) {
        this.valueFn = valueFn;
        this.valueAcc = valueAcc;
        this.keyFn = keyFn;
        this.xf = xf;
        this.inputs = {};
      }
      XReduceBy2.prototype["@@transducer/init"] = _xfBase.init;
      XReduceBy2.prototype["@@transducer/result"] = function(result) {
        var key;
        for (key in this.inputs) {
          if (_has(key, this.inputs)) {
            result = this.xf["@@transducer/step"](result, this.inputs[key]);
            if (result["@@transducer/reduced"]) {
              result = result["@@transducer/value"];
              break;
            }
          }
        }
        this.inputs = null;
        return this.xf["@@transducer/result"](result);
      };
      XReduceBy2.prototype["@@transducer/step"] = function(result, input) {
        var key = this.keyFn(input);
        this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
        this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
        return result;
      };
      return XReduceBy2;
    }();
    var _xreduceBy = /* @__PURE__ */ _curryN(4, [], function _xreduceBy2(valueFn, valueAcc, keyFn, xf) {
      return new XReduceBy(valueFn, valueAcc, keyFn, xf);
    });
    module2.exports = _xreduceBy;
  }
});

// ../node_modules/ramda/src/reduceBy.js
var require_reduceBy = __commonJS({
  "../node_modules/ramda/src/reduceBy.js"(exports2, module2) {
    var _curryN = require_curryN();
    var _dispatchable = require_dispatchable();
    var _has = require_has();
    var _reduce = require_reduce();
    var _xreduceBy = require_xreduceBy();
    var reduceBy = /* @__PURE__ */ _curryN(4, [], /* @__PURE__ */ _dispatchable([], _xreduceBy, function reduceBy2(valueFn, valueAcc, keyFn, list) {
      return _reduce(function(acc, elt) {
        var key = keyFn(elt);
        acc[key] = valueFn(_has(key, acc) ? acc[key] : valueAcc, elt);
        return acc;
      }, {}, list);
    }));
    module2.exports = reduceBy;
  }
});

// ../node_modules/ramda/src/countBy.js
var require_countBy = __commonJS({
  "../node_modules/ramda/src/countBy.js"(exports2, module2) {
    var reduceBy = require_reduceBy();
    var countBy = /* @__PURE__ */ reduceBy(function(acc, elem) {
      return acc + 1;
    }, 0);
    module2.exports = countBy;
  }
});

// ../node_modules/ramda/src/dec.js
var require_dec = __commonJS({
  "../node_modules/ramda/src/dec.js"(exports2, module2) {
    var add = require_add();
    var dec = /* @__PURE__ */ add(-1);
    module2.exports = dec;
  }
});

// ../node_modules/ramda/src/defaultTo.js
var require_defaultTo = __commonJS({
  "../node_modules/ramda/src/defaultTo.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var defaultTo = /* @__PURE__ */ _curry2(function defaultTo2(d, v) {
      return v == null || v !== v ? d : v;
    });
    module2.exports = defaultTo;
  }
});

// ../node_modules/ramda/src/descend.js
var require_descend = __commonJS({
  "../node_modules/ramda/src/descend.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var descend = /* @__PURE__ */ _curry3(function descend2(fn, a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa > bb ? -1 : aa < bb ? 1 : 0;
    });
    module2.exports = descend;
  }
});

// ../node_modules/ramda/src/difference.js
var require_difference = __commonJS({
  "../node_modules/ramda/src/difference.js"(exports2, module2) {
    var _contains = require_contains2();
    var _curry2 = require_curry2();
    var difference = /* @__PURE__ */ _curry2(function difference2(first, second) {
      var out = [];
      var idx = 0;
      var firstLen = first.length;
      while (idx < firstLen) {
        if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
          out[out.length] = first[idx];
        }
        idx += 1;
      }
      return out;
    });
    module2.exports = difference;
  }
});

// ../node_modules/ramda/src/differenceWith.js
var require_differenceWith = __commonJS({
  "../node_modules/ramda/src/differenceWith.js"(exports2, module2) {
    var _containsWith = require_containsWith();
    var _curry3 = require_curry3();
    var differenceWith = /* @__PURE__ */ _curry3(function differenceWith2(pred, first, second) {
      var out = [];
      var idx = 0;
      var firstLen = first.length;
      while (idx < firstLen) {
        if (!_containsWith(pred, first[idx], second) && !_containsWith(pred, first[idx], out)) {
          out.push(first[idx]);
        }
        idx += 1;
      }
      return out;
    });
    module2.exports = differenceWith;
  }
});

// ../node_modules/ramda/src/dissoc.js
var require_dissoc = __commonJS({
  "../node_modules/ramda/src/dissoc.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var dissoc = /* @__PURE__ */ _curry2(function dissoc2(prop, obj) {
      var result = {};
      for (var p in obj) {
        result[p] = obj[p];
      }
      delete result[prop];
      return result;
    });
    module2.exports = dissoc;
  }
});

// ../node_modules/ramda/src/remove.js
var require_remove2 = __commonJS({
  "../node_modules/ramda/src/remove.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var remove = /* @__PURE__ */ _curry3(function remove2(start, count, list) {
      var result = Array.prototype.slice.call(list, 0);
      result.splice(start, count);
      return result;
    });
    module2.exports = remove;
  }
});

// ../node_modules/ramda/src/update.js
var require_update = __commonJS({
  "../node_modules/ramda/src/update.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var adjust = require_adjust();
    var always = require_always();
    var update = /* @__PURE__ */ _curry3(function update2(idx, x, list) {
      return adjust(always(x), idx, list);
    });
    module2.exports = update;
  }
});

// ../node_modules/ramda/src/dissocPath.js
var require_dissocPath = __commonJS({
  "../node_modules/ramda/src/dissocPath.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isInteger = require_isInteger();
    var assoc = require_assoc();
    var dissoc = require_dissoc();
    var remove = require_remove2();
    var update = require_update();
    var dissocPath = /* @__PURE__ */ _curry2(function dissocPath2(path, obj) {
      switch (path.length) {
        case 0:
          return obj;
        case 1:
          return _isInteger(path[0]) ? remove(path[0], 1, obj) : dissoc(path[0], obj);
        default:
          var head = path[0];
          var tail = Array.prototype.slice.call(path, 1);
          if (obj[head] == null) {
            return obj;
          } else if (_isInteger(path[0])) {
            return update(head, dissocPath2(tail, obj[head]), obj);
          } else {
            return assoc(head, dissocPath2(tail, obj[head]), obj);
          }
      }
    });
    module2.exports = dissocPath;
  }
});

// ../node_modules/ramda/src/divide.js
var require_divide = __commonJS({
  "../node_modules/ramda/src/divide.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var divide = /* @__PURE__ */ _curry2(function divide2(a, b) {
      return a / b;
    });
    module2.exports = divide;
  }
});

// ../node_modules/ramda/src/internal/_xdrop.js
var require_xdrop = __commonJS({
  "../node_modules/ramda/src/internal/_xdrop.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XDrop = /* @__PURE__ */ function() {
      function XDrop2(n, xf) {
        this.xf = xf;
        this.n = n;
      }
      XDrop2.prototype["@@transducer/init"] = _xfBase.init;
      XDrop2.prototype["@@transducer/result"] = _xfBase.result;
      XDrop2.prototype["@@transducer/step"] = function(result, input) {
        if (this.n > 0) {
          this.n -= 1;
          return result;
        }
        return this.xf["@@transducer/step"](result, input);
      };
      return XDrop2;
    }();
    var _xdrop = /* @__PURE__ */ _curry2(function _xdrop2(n, xf) {
      return new XDrop(n, xf);
    });
    module2.exports = _xdrop;
  }
});

// ../node_modules/ramda/src/drop.js
var require_drop = __commonJS({
  "../node_modules/ramda/src/drop.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xdrop = require_xdrop();
    var slice = require_slice();
    var drop = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["drop"], _xdrop, function drop2(n, xs) {
      return slice(Math.max(0, n), Infinity, xs);
    }));
    module2.exports = drop;
  }
});

// ../node_modules/ramda/src/internal/_xtake.js
var require_xtake = __commonJS({
  "../node_modules/ramda/src/internal/_xtake.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduced = require_reduced();
    var _xfBase = require_xfBase();
    var XTake = /* @__PURE__ */ function() {
      function XTake2(n, xf) {
        this.xf = xf;
        this.n = n;
        this.i = 0;
      }
      XTake2.prototype["@@transducer/init"] = _xfBase.init;
      XTake2.prototype["@@transducer/result"] = _xfBase.result;
      XTake2.prototype["@@transducer/step"] = function(result, input) {
        this.i += 1;
        var ret = this.n === 0 ? result : this.xf["@@transducer/step"](result, input);
        return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
      };
      return XTake2;
    }();
    var _xtake = /* @__PURE__ */ _curry2(function _xtake2(n, xf) {
      return new XTake(n, xf);
    });
    module2.exports = _xtake;
  }
});

// ../node_modules/ramda/src/take.js
var require_take = __commonJS({
  "../node_modules/ramda/src/take.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xtake = require_xtake();
    var slice = require_slice();
    var take = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["take"], _xtake, function take2(n, xs) {
      return slice(0, n < 0 ? Infinity : n, xs);
    }));
    module2.exports = take;
  }
});

// ../node_modules/ramda/src/internal/_dropLast.js
var require_dropLast = __commonJS({
  "../node_modules/ramda/src/internal/_dropLast.js"(exports2, module2) {
    var take = require_take();
    function dropLast(n, xs) {
      return take(n < xs.length ? xs.length - n : 0, xs);
    }
    module2.exports = dropLast;
  }
});

// ../node_modules/ramda/src/internal/_xdropLast.js
var require_xdropLast = __commonJS({
  "../node_modules/ramda/src/internal/_xdropLast.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XDropLast = /* @__PURE__ */ function() {
      function XDropLast2(n, xf) {
        this.xf = xf;
        this.pos = 0;
        this.full = false;
        this.acc = new Array(n);
      }
      XDropLast2.prototype["@@transducer/init"] = _xfBase.init;
      XDropLast2.prototype["@@transducer/result"] = function(result) {
        this.acc = null;
        return this.xf["@@transducer/result"](result);
      };
      XDropLast2.prototype["@@transducer/step"] = function(result, input) {
        if (this.full) {
          result = this.xf["@@transducer/step"](result, this.acc[this.pos]);
        }
        this.store(input);
        return result;
      };
      XDropLast2.prototype.store = function(input) {
        this.acc[this.pos] = input;
        this.pos += 1;
        if (this.pos === this.acc.length) {
          this.pos = 0;
          this.full = true;
        }
      };
      return XDropLast2;
    }();
    var _xdropLast = /* @__PURE__ */ _curry2(function _xdropLast2(n, xf) {
      return new XDropLast(n, xf);
    });
    module2.exports = _xdropLast;
  }
});

// ../node_modules/ramda/src/dropLast.js
var require_dropLast2 = __commonJS({
  "../node_modules/ramda/src/dropLast.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _dropLast = require_dropLast();
    var _xdropLast = require_xdropLast();
    var dropLast = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xdropLast, _dropLast));
    module2.exports = dropLast;
  }
});

// ../node_modules/ramda/src/internal/_dropLastWhile.js
var require_dropLastWhile = __commonJS({
  "../node_modules/ramda/src/internal/_dropLastWhile.js"(exports2, module2) {
    var slice = require_slice();
    function dropLastWhile(pred, xs) {
      var idx = xs.length - 1;
      while (idx >= 0 && pred(xs[idx])) {
        idx -= 1;
      }
      return slice(0, idx + 1, xs);
    }
    module2.exports = dropLastWhile;
  }
});

// ../node_modules/ramda/src/internal/_xdropLastWhile.js
var require_xdropLastWhile = __commonJS({
  "../node_modules/ramda/src/internal/_xdropLastWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduce = require_reduce();
    var _xfBase = require_xfBase();
    var XDropLastWhile = /* @__PURE__ */ function() {
      function XDropLastWhile2(fn, xf) {
        this.f = fn;
        this.retained = [];
        this.xf = xf;
      }
      XDropLastWhile2.prototype["@@transducer/init"] = _xfBase.init;
      XDropLastWhile2.prototype["@@transducer/result"] = function(result) {
        this.retained = null;
        return this.xf["@@transducer/result"](result);
      };
      XDropLastWhile2.prototype["@@transducer/step"] = function(result, input) {
        return this.f(input) ? this.retain(result, input) : this.flush(result, input);
      };
      XDropLastWhile2.prototype.flush = function(result, input) {
        result = _reduce(this.xf["@@transducer/step"], result, this.retained);
        this.retained = [];
        return this.xf["@@transducer/step"](result, input);
      };
      XDropLastWhile2.prototype.retain = function(result, input) {
        this.retained.push(input);
        return result;
      };
      return XDropLastWhile2;
    }();
    var _xdropLastWhile = /* @__PURE__ */ _curry2(function _xdropLastWhile2(fn, xf) {
      return new XDropLastWhile(fn, xf);
    });
    module2.exports = _xdropLastWhile;
  }
});

// ../node_modules/ramda/src/dropLastWhile.js
var require_dropLastWhile2 = __commonJS({
  "../node_modules/ramda/src/dropLastWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _dropLastWhile = require_dropLastWhile();
    var _xdropLastWhile = require_xdropLastWhile();
    var dropLastWhile = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xdropLastWhile, _dropLastWhile));
    module2.exports = dropLastWhile;
  }
});

// ../node_modules/ramda/src/internal/_xdropRepeatsWith.js
var require_xdropRepeatsWith = __commonJS({
  "../node_modules/ramda/src/internal/_xdropRepeatsWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XDropRepeatsWith = /* @__PURE__ */ function() {
      function XDropRepeatsWith2(pred, xf) {
        this.xf = xf;
        this.pred = pred;
        this.lastValue = void 0;
        this.seenFirstValue = false;
      }
      XDropRepeatsWith2.prototype["@@transducer/init"] = _xfBase.init;
      XDropRepeatsWith2.prototype["@@transducer/result"] = _xfBase.result;
      XDropRepeatsWith2.prototype["@@transducer/step"] = function(result, input) {
        var sameAsLast = false;
        if (!this.seenFirstValue) {
          this.seenFirstValue = true;
        } else if (this.pred(this.lastValue, input)) {
          sameAsLast = true;
        }
        this.lastValue = input;
        return sameAsLast ? result : this.xf["@@transducer/step"](result, input);
      };
      return XDropRepeatsWith2;
    }();
    var _xdropRepeatsWith = /* @__PURE__ */ _curry2(function _xdropRepeatsWith2(pred, xf) {
      return new XDropRepeatsWith(pred, xf);
    });
    module2.exports = _xdropRepeatsWith;
  }
});

// ../node_modules/ramda/src/nth.js
var require_nth = __commonJS({
  "../node_modules/ramda/src/nth.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isString = require_isString2();
    var nth = /* @__PURE__ */ _curry2(function nth2(offset, list) {
      var idx = offset < 0 ? list.length + offset : offset;
      return _isString(list) ? list.charAt(idx) : list[idx];
    });
    module2.exports = nth;
  }
});

// ../node_modules/ramda/src/last.js
var require_last = __commonJS({
  "../node_modules/ramda/src/last.js"(exports2, module2) {
    var nth = require_nth();
    var last = /* @__PURE__ */ nth(-1);
    module2.exports = last;
  }
});

// ../node_modules/ramda/src/dropRepeatsWith.js
var require_dropRepeatsWith = __commonJS({
  "../node_modules/ramda/src/dropRepeatsWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xdropRepeatsWith = require_xdropRepeatsWith();
    var last = require_last();
    var dropRepeatsWith = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xdropRepeatsWith, function dropRepeatsWith2(pred, list) {
      var result = [];
      var idx = 1;
      var len = list.length;
      if (len !== 0) {
        result[0] = list[0];
        while (idx < len) {
          if (!pred(last(result), list[idx])) {
            result[result.length] = list[idx];
          }
          idx += 1;
        }
      }
      return result;
    }));
    module2.exports = dropRepeatsWith;
  }
});

// ../node_modules/ramda/src/dropRepeats.js
var require_dropRepeats = __commonJS({
  "../node_modules/ramda/src/dropRepeats.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _dispatchable = require_dispatchable();
    var _xdropRepeatsWith = require_xdropRepeatsWith();
    var dropRepeatsWith = require_dropRepeatsWith();
    var equals = require_equals2();
    var dropRepeats = /* @__PURE__ */ _curry1(/* @__PURE__ */ _dispatchable([], /* @__PURE__ */ _xdropRepeatsWith(equals), /* @__PURE__ */ dropRepeatsWith(equals)));
    module2.exports = dropRepeats;
  }
});

// ../node_modules/ramda/src/internal/_xdropWhile.js
var require_xdropWhile = __commonJS({
  "../node_modules/ramda/src/internal/_xdropWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XDropWhile = /* @__PURE__ */ function() {
      function XDropWhile2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XDropWhile2.prototype["@@transducer/init"] = _xfBase.init;
      XDropWhile2.prototype["@@transducer/result"] = _xfBase.result;
      XDropWhile2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f) {
          if (this.f(input)) {
            return result;
          }
          this.f = null;
        }
        return this.xf["@@transducer/step"](result, input);
      };
      return XDropWhile2;
    }();
    var _xdropWhile = /* @__PURE__ */ _curry2(function _xdropWhile2(f, xf) {
      return new XDropWhile(f, xf);
    });
    module2.exports = _xdropWhile;
  }
});

// ../node_modules/ramda/src/dropWhile.js
var require_dropWhile = __commonJS({
  "../node_modules/ramda/src/dropWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xdropWhile = require_xdropWhile();
    var slice = require_slice();
    var dropWhile = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["dropWhile"], _xdropWhile, function dropWhile2(pred, xs) {
      var idx = 0;
      var len = xs.length;
      while (idx < len && pred(xs[idx])) {
        idx += 1;
      }
      return slice(idx, Infinity, xs);
    }));
    module2.exports = dropWhile;
  }
});

// ../node_modules/ramda/src/or.js
var require_or = __commonJS({
  "../node_modules/ramda/src/or.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var or = /* @__PURE__ */ _curry2(function or2(a, b) {
      return a || b;
    });
    module2.exports = or;
  }
});

// ../node_modules/ramda/src/either.js
var require_either = __commonJS({
  "../node_modules/ramda/src/either.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isFunction = require_isFunction2();
    var lift = require_lift();
    var or = require_or();
    var either = /* @__PURE__ */ _curry2(function either2(f, g) {
      return _isFunction(f) ? function _either() {
        return f.apply(this, arguments) || g.apply(this, arguments);
      } : lift(or)(f, g);
    });
    module2.exports = either;
  }
});

// ../node_modules/ramda/src/empty.js
var require_empty2 = __commonJS({
  "../node_modules/ramda/src/empty.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _isArguments = require_isArguments2();
    var _isArray = require_isArray2();
    var _isObject = require_isObject2();
    var _isString = require_isString2();
    var empty = /* @__PURE__ */ _curry1(function empty2(x) {
      return x != null && typeof x["fantasy-land/empty"] === "function" ? x["fantasy-land/empty"]() : x != null && x.constructor != null && typeof x.constructor["fantasy-land/empty"] === "function" ? x.constructor["fantasy-land/empty"]() : x != null && typeof x.empty === "function" ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === "function" ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? "" : _isObject(x) ? {} : _isArguments(x) ? function() {
        return arguments;
      }() : void 0;
    });
    module2.exports = empty;
  }
});

// ../node_modules/ramda/src/takeLast.js
var require_takeLast = __commonJS({
  "../node_modules/ramda/src/takeLast.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var drop = require_drop();
    var takeLast = /* @__PURE__ */ _curry2(function takeLast2(n, xs) {
      return drop(n >= 0 ? xs.length - n : 0, xs);
    });
    module2.exports = takeLast;
  }
});

// ../node_modules/ramda/src/endsWith.js
var require_endsWith = __commonJS({
  "../node_modules/ramda/src/endsWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var equals = require_equals2();
    var takeLast = require_takeLast();
    var endsWith = /* @__PURE__ */ _curry2(function(suffix, list) {
      return equals(takeLast(suffix.length, list), suffix);
    });
    module2.exports = endsWith;
  }
});

// ../node_modules/ramda/src/eqBy.js
var require_eqBy = __commonJS({
  "../node_modules/ramda/src/eqBy.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var equals = require_equals2();
    var eqBy = /* @__PURE__ */ _curry3(function eqBy2(f, x, y) {
      return equals(f(x), f(y));
    });
    module2.exports = eqBy;
  }
});

// ../node_modules/ramda/src/eqProps.js
var require_eqProps = __commonJS({
  "../node_modules/ramda/src/eqProps.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var equals = require_equals2();
    var eqProps = /* @__PURE__ */ _curry3(function eqProps2(prop, obj1, obj2) {
      return equals(obj1[prop], obj2[prop]);
    });
    module2.exports = eqProps;
  }
});

// ../node_modules/ramda/src/evolve.js
var require_evolve = __commonJS({
  "../node_modules/ramda/src/evolve.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var evolve = /* @__PURE__ */ _curry2(function evolve2(transformations, object) {
      var result = {};
      var transformation, key, type;
      for (key in object) {
        transformation = transformations[key];
        type = typeof transformation;
        result[key] = type === "function" ? transformation(object[key]) : transformation && type === "object" ? evolve2(transformation, object[key]) : object[key];
      }
      return result;
    });
    module2.exports = evolve;
  }
});

// ../node_modules/ramda/src/internal/_xfind.js
var require_xfind = __commonJS({
  "../node_modules/ramda/src/internal/_xfind.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduced = require_reduced();
    var _xfBase = require_xfBase();
    var XFind = /* @__PURE__ */ function() {
      function XFind2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.found = false;
      }
      XFind2.prototype["@@transducer/init"] = _xfBase.init;
      XFind2.prototype["@@transducer/result"] = function(result) {
        if (!this.found) {
          result = this.xf["@@transducer/step"](result, void 0);
        }
        return this.xf["@@transducer/result"](result);
      };
      XFind2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f(input)) {
          this.found = true;
          result = _reduced(this.xf["@@transducer/step"](result, input));
        }
        return result;
      };
      return XFind2;
    }();
    var _xfind = /* @__PURE__ */ _curry2(function _xfind2(f, xf) {
      return new XFind(f, xf);
    });
    module2.exports = _xfind;
  }
});

// ../node_modules/ramda/src/find.js
var require_find = __commonJS({
  "../node_modules/ramda/src/find.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xfind = require_xfind();
    var find = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["find"], _xfind, function find2(fn, list) {
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        if (fn(list[idx])) {
          return list[idx];
        }
        idx += 1;
      }
    }));
    module2.exports = find;
  }
});

// ../node_modules/ramda/src/internal/_xfindIndex.js
var require_xfindIndex = __commonJS({
  "../node_modules/ramda/src/internal/_xfindIndex.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduced = require_reduced();
    var _xfBase = require_xfBase();
    var XFindIndex = /* @__PURE__ */ function() {
      function XFindIndex2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.idx = -1;
        this.found = false;
      }
      XFindIndex2.prototype["@@transducer/init"] = _xfBase.init;
      XFindIndex2.prototype["@@transducer/result"] = function(result) {
        if (!this.found) {
          result = this.xf["@@transducer/step"](result, -1);
        }
        return this.xf["@@transducer/result"](result);
      };
      XFindIndex2.prototype["@@transducer/step"] = function(result, input) {
        this.idx += 1;
        if (this.f(input)) {
          this.found = true;
          result = _reduced(this.xf["@@transducer/step"](result, this.idx));
        }
        return result;
      };
      return XFindIndex2;
    }();
    var _xfindIndex = /* @__PURE__ */ _curry2(function _xfindIndex2(f, xf) {
      return new XFindIndex(f, xf);
    });
    module2.exports = _xfindIndex;
  }
});

// ../node_modules/ramda/src/findIndex.js
var require_findIndex = __commonJS({
  "../node_modules/ramda/src/findIndex.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xfindIndex = require_xfindIndex();
    var findIndex = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xfindIndex, function findIndex2(fn, list) {
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        if (fn(list[idx])) {
          return idx;
        }
        idx += 1;
      }
      return -1;
    }));
    module2.exports = findIndex;
  }
});

// ../node_modules/ramda/src/internal/_xfindLast.js
var require_xfindLast = __commonJS({
  "../node_modules/ramda/src/internal/_xfindLast.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XFindLast = /* @__PURE__ */ function() {
      function XFindLast2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XFindLast2.prototype["@@transducer/init"] = _xfBase.init;
      XFindLast2.prototype["@@transducer/result"] = function(result) {
        return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.last));
      };
      XFindLast2.prototype["@@transducer/step"] = function(result, input) {
        if (this.f(input)) {
          this.last = input;
        }
        return result;
      };
      return XFindLast2;
    }();
    var _xfindLast = /* @__PURE__ */ _curry2(function _xfindLast2(f, xf) {
      return new XFindLast(f, xf);
    });
    module2.exports = _xfindLast;
  }
});

// ../node_modules/ramda/src/findLast.js
var require_findLast = __commonJS({
  "../node_modules/ramda/src/findLast.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xfindLast = require_xfindLast();
    var findLast = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xfindLast, function findLast2(fn, list) {
      var idx = list.length - 1;
      while (idx >= 0) {
        if (fn(list[idx])) {
          return list[idx];
        }
        idx -= 1;
      }
    }));
    module2.exports = findLast;
  }
});

// ../node_modules/ramda/src/internal/_xfindLastIndex.js
var require_xfindLastIndex = __commonJS({
  "../node_modules/ramda/src/internal/_xfindLastIndex.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XFindLastIndex = /* @__PURE__ */ function() {
      function XFindLastIndex2(f, xf) {
        this.xf = xf;
        this.f = f;
        this.idx = -1;
        this.lastIdx = -1;
      }
      XFindLastIndex2.prototype["@@transducer/init"] = _xfBase.init;
      XFindLastIndex2.prototype["@@transducer/result"] = function(result) {
        return this.xf["@@transducer/result"](this.xf["@@transducer/step"](result, this.lastIdx));
      };
      XFindLastIndex2.prototype["@@transducer/step"] = function(result, input) {
        this.idx += 1;
        if (this.f(input)) {
          this.lastIdx = this.idx;
        }
        return result;
      };
      return XFindLastIndex2;
    }();
    var _xfindLastIndex = /* @__PURE__ */ _curry2(function _xfindLastIndex2(f, xf) {
      return new XFindLastIndex(f, xf);
    });
    module2.exports = _xfindLastIndex;
  }
});

// ../node_modules/ramda/src/findLastIndex.js
var require_findLastIndex = __commonJS({
  "../node_modules/ramda/src/findLastIndex.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xfindLastIndex = require_xfindLastIndex();
    var findLastIndex = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xfindLastIndex, function findLastIndex2(fn, list) {
      var idx = list.length - 1;
      while (idx >= 0) {
        if (fn(list[idx])) {
          return idx;
        }
        idx -= 1;
      }
      return -1;
    }));
    module2.exports = findLastIndex;
  }
});

// ../node_modules/ramda/src/flatten.js
var require_flatten = __commonJS({
  "../node_modules/ramda/src/flatten.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _makeFlat = require_makeFlat();
    var flatten = /* @__PURE__ */ _curry1(/* @__PURE__ */ _makeFlat(true));
    module2.exports = flatten;
  }
});

// ../node_modules/ramda/src/flip.js
var require_flip = __commonJS({
  "../node_modules/ramda/src/flip.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var curryN = require_curryN2();
    var flip = /* @__PURE__ */ _curry1(function flip2(fn) {
      return curryN(fn.length, function(a, b) {
        var args = Array.prototype.slice.call(arguments, 0);
        args[0] = b;
        args[1] = a;
        return fn.apply(this, args);
      });
    });
    module2.exports = flip;
  }
});

// ../node_modules/ramda/src/forEach.js
var require_forEach = __commonJS({
  "../node_modules/ramda/src/forEach.js"(exports2, module2) {
    var _checkForMethod = require_checkForMethod();
    var _curry2 = require_curry2();
    var forEach = /* @__PURE__ */ _curry2(/* @__PURE__ */ _checkForMethod("forEach", function forEach2(fn, list) {
      var len = list.length;
      var idx = 0;
      while (idx < len) {
        fn(list[idx]);
        idx += 1;
      }
      return list;
    }));
    module2.exports = forEach;
  }
});

// ../node_modules/ramda/src/forEachObjIndexed.js
var require_forEachObjIndexed = __commonJS({
  "../node_modules/ramda/src/forEachObjIndexed.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var keys = require_keys3();
    var forEachObjIndexed = /* @__PURE__ */ _curry2(function forEachObjIndexed2(fn, obj) {
      var keyList = keys(obj);
      var idx = 0;
      while (idx < keyList.length) {
        var key = keyList[idx];
        fn(obj[key], key, obj);
        idx += 1;
      }
      return obj;
    });
    module2.exports = forEachObjIndexed;
  }
});

// ../node_modules/ramda/src/fromPairs.js
var require_fromPairs = __commonJS({
  "../node_modules/ramda/src/fromPairs.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var fromPairs = /* @__PURE__ */ _curry1(function fromPairs2(pairs) {
      var result = {};
      var idx = 0;
      while (idx < pairs.length) {
        result[pairs[idx][0]] = pairs[idx][1];
        idx += 1;
      }
      return result;
    });
    module2.exports = fromPairs;
  }
});

// ../node_modules/ramda/src/groupBy.js
var require_groupBy = __commonJS({
  "../node_modules/ramda/src/groupBy.js"(exports2, module2) {
    var _checkForMethod = require_checkForMethod();
    var _curry2 = require_curry2();
    var reduceBy = require_reduceBy();
    var groupBy = /* @__PURE__ */ _curry2(/* @__PURE__ */ _checkForMethod("groupBy", /* @__PURE__ */ reduceBy(function(acc, item) {
      if (acc == null) {
        acc = [];
      }
      acc.push(item);
      return acc;
    }, null)));
    module2.exports = groupBy;
  }
});

// ../node_modules/ramda/src/groupWith.js
var require_groupWith = __commonJS({
  "../node_modules/ramda/src/groupWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var groupWith = /* @__PURE__ */ _curry2(function(fn, list) {
      var res = [];
      var idx = 0;
      var len = list.length;
      while (idx < len) {
        var nextidx = idx + 1;
        while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
          nextidx += 1;
        }
        res.push(list.slice(idx, nextidx));
        idx = nextidx;
      }
      return res;
    });
    module2.exports = groupWith;
  }
});

// ../node_modules/ramda/src/gt.js
var require_gt = __commonJS({
  "../node_modules/ramda/src/gt.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var gt = /* @__PURE__ */ _curry2(function gt2(a, b) {
      return a > b;
    });
    module2.exports = gt;
  }
});

// ../node_modules/ramda/src/gte.js
var require_gte = __commonJS({
  "../node_modules/ramda/src/gte.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var gte = /* @__PURE__ */ _curry2(function gte2(a, b) {
      return a >= b;
    });
    module2.exports = gte;
  }
});

// ../node_modules/ramda/src/has.js
var require_has2 = __commonJS({
  "../node_modules/ramda/src/has.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _has = require_has();
    var has = /* @__PURE__ */ _curry2(_has);
    module2.exports = has;
  }
});

// ../node_modules/ramda/src/hasIn.js
var require_hasIn = __commonJS({
  "../node_modules/ramda/src/hasIn.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var hasIn = /* @__PURE__ */ _curry2(function hasIn2(prop, obj) {
      return prop in obj;
    });
    module2.exports = hasIn;
  }
});

// ../node_modules/ramda/src/head.js
var require_head = __commonJS({
  "../node_modules/ramda/src/head.js"(exports2, module2) {
    var nth = require_nth();
    var head = /* @__PURE__ */ nth(0);
    module2.exports = head;
  }
});

// ../node_modules/ramda/src/internal/_identity.js
var require_identity2 = __commonJS({
  "../node_modules/ramda/src/internal/_identity.js"(exports2, module2) {
    function _identity(x) {
      return x;
    }
    module2.exports = _identity;
  }
});

// ../node_modules/ramda/src/identity.js
var require_identity3 = __commonJS({
  "../node_modules/ramda/src/identity.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _identity = require_identity2();
    var identity = /* @__PURE__ */ _curry1(_identity);
    module2.exports = identity;
  }
});

// ../node_modules/ramda/src/ifElse.js
var require_ifElse = __commonJS({
  "../node_modules/ramda/src/ifElse.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var curryN = require_curryN2();
    var ifElse = /* @__PURE__ */ _curry3(function ifElse2(condition, onTrue, onFalse) {
      return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
        return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
      });
    });
    module2.exports = ifElse;
  }
});

// ../node_modules/ramda/src/inc.js
var require_inc = __commonJS({
  "../node_modules/ramda/src/inc.js"(exports2, module2) {
    var add = require_add();
    var inc = /* @__PURE__ */ add(1);
    module2.exports = inc;
  }
});

// ../node_modules/ramda/src/indexBy.js
var require_indexBy = __commonJS({
  "../node_modules/ramda/src/indexBy.js"(exports2, module2) {
    var reduceBy = require_reduceBy();
    var indexBy = /* @__PURE__ */ reduceBy(function(acc, elem) {
      return elem;
    }, null);
    module2.exports = indexBy;
  }
});

// ../node_modules/ramda/src/indexOf.js
var require_indexOf2 = __commonJS({
  "../node_modules/ramda/src/indexOf.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _indexOf = require_indexOf();
    var _isArray = require_isArray2();
    var indexOf = /* @__PURE__ */ _curry2(function indexOf2(target, xs) {
      return typeof xs.indexOf === "function" && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });
    module2.exports = indexOf;
  }
});

// ../node_modules/ramda/src/init.js
var require_init = __commonJS({
  "../node_modules/ramda/src/init.js"(exports2, module2) {
    var slice = require_slice();
    var init = /* @__PURE__ */ slice(0, -1);
    module2.exports = init;
  }
});

// ../node_modules/ramda/src/innerJoin.js
var require_innerJoin = __commonJS({
  "../node_modules/ramda/src/innerJoin.js"(exports2, module2) {
    var _containsWith = require_containsWith();
    var _curry3 = require_curry3();
    var _filter = require_filter();
    var innerJoin = /* @__PURE__ */ _curry3(function innerJoin2(pred, xs, ys) {
      return _filter(function(x) {
        return _containsWith(pred, x, ys);
      }, xs);
    });
    module2.exports = innerJoin;
  }
});

// ../node_modules/ramda/src/insert.js
var require_insert = __commonJS({
  "../node_modules/ramda/src/insert.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var insert = /* @__PURE__ */ _curry3(function insert2(idx, elt, list) {
      idx = idx < list.length && idx >= 0 ? idx : list.length;
      var result = Array.prototype.slice.call(list, 0);
      result.splice(idx, 0, elt);
      return result;
    });
    module2.exports = insert;
  }
});

// ../node_modules/ramda/src/insertAll.js
var require_insertAll = __commonJS({
  "../node_modules/ramda/src/insertAll.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var insertAll = /* @__PURE__ */ _curry3(function insertAll2(idx, elts, list) {
      idx = idx < list.length && idx >= 0 ? idx : list.length;
      return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
    });
    module2.exports = insertAll;
  }
});

// ../node_modules/ramda/src/internal/_Set.js
var require_Set2 = __commonJS({
  "../node_modules/ramda/src/internal/_Set.js"(exports2, module2) {
    var _contains = require_contains2();
    var _Set = /* @__PURE__ */ function() {
      function _Set2() {
        this._nativeSet = typeof Set === "function" ? new Set() : null;
        this._items = {};
      }
      _Set2.prototype.add = function(item) {
        return !hasOrAdd(item, true, this);
      };
      _Set2.prototype.has = function(item) {
        return hasOrAdd(item, false, this);
      };
      return _Set2;
    }();
    function hasOrAdd(item, shouldAdd, set) {
      var type = typeof item;
      var prevSize, newSize;
      switch (type) {
        case "string":
        case "number":
          if (item === 0 && 1 / item === -Infinity) {
            if (set._items["-0"]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items["-0"] = true;
              }
              return false;
            }
          }
          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;
              set._nativeSet.add(item);
              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = {};
                set._items[type][item] = true;
              }
              return false;
            } else if (item in set._items[type]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][item] = true;
              }
              return false;
            }
          }
        case "boolean":
          if (type in set._items) {
            var bIdx = item ? 1 : 0;
            if (set._items[type][bIdx]) {
              return true;
            } else {
              if (shouldAdd) {
                set._items[type][bIdx] = true;
              }
              return false;
            }
          } else {
            if (shouldAdd) {
              set._items[type] = item ? [false, true] : [true, false];
            }
            return false;
          }
        case "function":
          if (set._nativeSet !== null) {
            if (shouldAdd) {
              prevSize = set._nativeSet.size;
              set._nativeSet.add(item);
              newSize = set._nativeSet.size;
              return newSize === prevSize;
            } else {
              return set._nativeSet.has(item);
            }
          } else {
            if (!(type in set._items)) {
              if (shouldAdd) {
                set._items[type] = [item];
              }
              return false;
            }
            if (!_contains(item, set._items[type])) {
              if (shouldAdd) {
                set._items[type].push(item);
              }
              return false;
            }
            return true;
          }
        case "undefined":
          if (set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type] = true;
            }
            return false;
          }
        case "object":
          if (item === null) {
            if (!set._items["null"]) {
              if (shouldAdd) {
                set._items["null"] = true;
              }
              return false;
            }
            return true;
          }
        default:
          type = Object.prototype.toString.call(item);
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }
            return false;
          }
          if (!_contains(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }
            return false;
          }
          return true;
      }
    }
    module2.exports = _Set;
  }
});

// ../node_modules/ramda/src/uniqBy.js
var require_uniqBy = __commonJS({
  "../node_modules/ramda/src/uniqBy.js"(exports2, module2) {
    var _Set = require_Set2();
    var _curry2 = require_curry2();
    var uniqBy = /* @__PURE__ */ _curry2(function uniqBy2(fn, list) {
      var set = new _Set();
      var result = [];
      var idx = 0;
      var appliedItem, item;
      while (idx < list.length) {
        item = list[idx];
        appliedItem = fn(item);
        if (set.add(appliedItem)) {
          result.push(item);
        }
        idx += 1;
      }
      return result;
    });
    module2.exports = uniqBy;
  }
});

// ../node_modules/ramda/src/uniq.js
var require_uniq = __commonJS({
  "../node_modules/ramda/src/uniq.js"(exports2, module2) {
    var identity = require_identity3();
    var uniqBy = require_uniqBy();
    var uniq = /* @__PURE__ */ uniqBy(identity);
    module2.exports = uniq;
  }
});

// ../node_modules/ramda/src/intersection.js
var require_intersection = __commonJS({
  "../node_modules/ramda/src/intersection.js"(exports2, module2) {
    var _contains = require_contains2();
    var _curry2 = require_curry2();
    var _filter = require_filter();
    var flip = require_flip();
    var uniq = require_uniq();
    var intersection = /* @__PURE__ */ _curry2(function intersection2(list1, list2) {
      var lookupList, filteredList;
      if (list1.length > list2.length) {
        lookupList = list1;
        filteredList = list2;
      } else {
        lookupList = list2;
        filteredList = list1;
      }
      return uniq(_filter(flip(_contains)(lookupList), filteredList));
    });
    module2.exports = intersection;
  }
});

// ../node_modules/ramda/src/intersperse.js
var require_intersperse = __commonJS({
  "../node_modules/ramda/src/intersperse.js"(exports2, module2) {
    var _checkForMethod = require_checkForMethod();
    var _curry2 = require_curry2();
    var intersperse = /* @__PURE__ */ _curry2(/* @__PURE__ */ _checkForMethod("intersperse", function intersperse2(separator, list) {
      var out = [];
      var idx = 0;
      var length = list.length;
      while (idx < length) {
        if (idx === length - 1) {
          out.push(list[idx]);
        } else {
          out.push(list[idx], separator);
        }
        idx += 1;
      }
      return out;
    }));
    module2.exports = intersperse;
  }
});

// ../node_modules/ramda/src/internal/_objectAssign.js
var require_objectAssign = __commonJS({
  "../node_modules/ramda/src/internal/_objectAssign.js"(exports2, module2) {
    var _has = require_has();
    function _objectAssign(target) {
      if (target == null) {
        throw new TypeError("Cannot convert undefined or null to object");
      }
      var output = Object(target);
      var idx = 1;
      var length = arguments.length;
      while (idx < length) {
        var source = arguments[idx];
        if (source != null) {
          for (var nextKey in source) {
            if (_has(nextKey, source)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
        idx += 1;
      }
      return output;
    }
    module2.exports = _objectAssign;
  }
});

// ../node_modules/ramda/src/internal/_assign.js
var require_assign2 = __commonJS({
  "../node_modules/ramda/src/internal/_assign.js"(exports2, module2) {
    var _objectAssign = require_objectAssign();
    module2.exports = typeof Object.assign === "function" ? Object.assign : _objectAssign;
  }
});

// ../node_modules/ramda/src/objOf.js
var require_objOf = __commonJS({
  "../node_modules/ramda/src/objOf.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var objOf = /* @__PURE__ */ _curry2(function objOf2(key, val) {
      var obj = {};
      obj[key] = val;
      return obj;
    });
    module2.exports = objOf;
  }
});

// ../node_modules/ramda/src/internal/_stepCat.js
var require_stepCat = __commonJS({
  "../node_modules/ramda/src/internal/_stepCat.js"(exports2, module2) {
    var _assign = require_assign2();
    var _identity = require_identity2();
    var _isArrayLike = require_isArrayLike2();
    var _isTransformer = require_isTransformer();
    var objOf = require_objOf();
    var _stepCatArray = {
      "@@transducer/init": Array,
      "@@transducer/step": function(xs, x) {
        xs.push(x);
        return xs;
      },
      "@@transducer/result": _identity
    };
    var _stepCatString = {
      "@@transducer/init": String,
      "@@transducer/step": function(a, b) {
        return a + b;
      },
      "@@transducer/result": _identity
    };
    var _stepCatObject = {
      "@@transducer/init": Object,
      "@@transducer/step": function(result, input) {
        return _assign(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
      },
      "@@transducer/result": _identity
    };
    function _stepCat(obj) {
      if (_isTransformer(obj)) {
        return obj;
      }
      if (_isArrayLike(obj)) {
        return _stepCatArray;
      }
      if (typeof obj === "string") {
        return _stepCatString;
      }
      if (typeof obj === "object") {
        return _stepCatObject;
      }
      throw new Error("Cannot create transformer for " + obj);
    }
    module2.exports = _stepCat;
  }
});

// ../node_modules/ramda/src/into.js
var require_into = __commonJS({
  "../node_modules/ramda/src/into.js"(exports2, module2) {
    var _clone = require_clone2();
    var _curry3 = require_curry3();
    var _isTransformer = require_isTransformer();
    var _reduce = require_reduce();
    var _stepCat = require_stepCat();
    var into = /* @__PURE__ */ _curry3(function into2(acc, xf, list) {
      return _isTransformer(acc) ? _reduce(xf(acc), acc["@@transducer/init"](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
    });
    module2.exports = into;
  }
});

// ../node_modules/ramda/src/invert.js
var require_invert = __commonJS({
  "../node_modules/ramda/src/invert.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _has = require_has();
    var keys = require_keys3();
    var invert = /* @__PURE__ */ _curry1(function invert2(obj) {
      var props = keys(obj);
      var len = props.length;
      var idx = 0;
      var out = {};
      while (idx < len) {
        var key = props[idx];
        var val = obj[key];
        var list = _has(val, out) ? out[val] : out[val] = [];
        list[list.length] = key;
        idx += 1;
      }
      return out;
    });
    module2.exports = invert;
  }
});

// ../node_modules/ramda/src/invertObj.js
var require_invertObj = __commonJS({
  "../node_modules/ramda/src/invertObj.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var keys = require_keys3();
    var invertObj = /* @__PURE__ */ _curry1(function invertObj2(obj) {
      var props = keys(obj);
      var len = props.length;
      var idx = 0;
      var out = {};
      while (idx < len) {
        var key = props[idx];
        out[obj[key]] = key;
        idx += 1;
      }
      return out;
    });
    module2.exports = invertObj;
  }
});

// ../node_modules/ramda/src/invoker.js
var require_invoker = __commonJS({
  "../node_modules/ramda/src/invoker.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isFunction = require_isFunction2();
    var curryN = require_curryN2();
    var toString = require_toString2();
    var invoker = /* @__PURE__ */ _curry2(function invoker2(arity, method) {
      return curryN(arity + 1, function() {
        var target = arguments[arity];
        if (target != null && _isFunction(target[method])) {
          return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
        }
        throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
      });
    });
    module2.exports = invoker;
  }
});

// ../node_modules/ramda/src/is.js
var require_is8 = __commonJS({
  "../node_modules/ramda/src/is.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var is = /* @__PURE__ */ _curry2(function is2(Ctor, val) {
      return val != null && val.constructor === Ctor || val instanceof Ctor;
    });
    module2.exports = is;
  }
});

// ../node_modules/ramda/src/isEmpty.js
var require_isEmpty = __commonJS({
  "../node_modules/ramda/src/isEmpty.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var empty = require_empty2();
    var equals = require_equals2();
    var isEmpty = /* @__PURE__ */ _curry1(function isEmpty2(x) {
      return x != null && equals(x, empty(x));
    });
    module2.exports = isEmpty;
  }
});

// ../node_modules/ramda/src/join.js
var require_join = __commonJS({
  "../node_modules/ramda/src/join.js"(exports2, module2) {
    var invoker = require_invoker();
    var join = /* @__PURE__ */ invoker(1, "join");
    module2.exports = join;
  }
});

// ../node_modules/ramda/src/juxt.js
var require_juxt = __commonJS({
  "../node_modules/ramda/src/juxt.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var converge = require_converge();
    var juxt = /* @__PURE__ */ _curry1(function juxt2(fns) {
      return converge(function() {
        return Array.prototype.slice.call(arguments, 0);
      }, fns);
    });
    module2.exports = juxt;
  }
});

// ../node_modules/ramda/src/keysIn.js
var require_keysIn = __commonJS({
  "../node_modules/ramda/src/keysIn.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var keysIn = /* @__PURE__ */ _curry1(function keysIn2(obj) {
      var prop;
      var ks = [];
      for (prop in obj) {
        ks[ks.length] = prop;
      }
      return ks;
    });
    module2.exports = keysIn;
  }
});

// ../node_modules/ramda/src/lastIndexOf.js
var require_lastIndexOf = __commonJS({
  "../node_modules/ramda/src/lastIndexOf.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isArray = require_isArray2();
    var equals = require_equals2();
    var lastIndexOf = /* @__PURE__ */ _curry2(function lastIndexOf2(target, xs) {
      if (typeof xs.lastIndexOf === "function" && !_isArray(xs)) {
        return xs.lastIndexOf(target);
      } else {
        var idx = xs.length - 1;
        while (idx >= 0) {
          if (equals(xs[idx], target)) {
            return idx;
          }
          idx -= 1;
        }
        return -1;
      }
    });
    module2.exports = lastIndexOf;
  }
});

// ../node_modules/ramda/src/internal/_isNumber.js
var require_isNumber = __commonJS({
  "../node_modules/ramda/src/internal/_isNumber.js"(exports2, module2) {
    function _isNumber(x) {
      return Object.prototype.toString.call(x) === "[object Number]";
    }
    module2.exports = _isNumber;
  }
});

// ../node_modules/ramda/src/length.js
var require_length = __commonJS({
  "../node_modules/ramda/src/length.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _isNumber = require_isNumber();
    var length = /* @__PURE__ */ _curry1(function length2(list) {
      return list != null && _isNumber(list.length) ? list.length : NaN;
    });
    module2.exports = length;
  }
});

// ../node_modules/ramda/src/lens.js
var require_lens = __commonJS({
  "../node_modules/ramda/src/lens.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var map = require_map3();
    var lens = /* @__PURE__ */ _curry2(function lens2(getter, setter) {
      return function(toFunctorFn) {
        return function(target) {
          return map(function(focus) {
            return setter(focus, target);
          }, toFunctorFn(getter(target)));
        };
      };
    });
    module2.exports = lens;
  }
});

// ../node_modules/ramda/src/lensIndex.js
var require_lensIndex = __commonJS({
  "../node_modules/ramda/src/lensIndex.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var lens = require_lens();
    var nth = require_nth();
    var update = require_update();
    var lensIndex = /* @__PURE__ */ _curry1(function lensIndex2(n) {
      return lens(nth(n), update(n));
    });
    module2.exports = lensIndex;
  }
});

// ../node_modules/ramda/src/lensPath.js
var require_lensPath = __commonJS({
  "../node_modules/ramda/src/lensPath.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var assocPath = require_assocPath();
    var lens = require_lens();
    var path = require_path2();
    var lensPath = /* @__PURE__ */ _curry1(function lensPath2(p) {
      return lens(path(p), assocPath(p));
    });
    module2.exports = lensPath;
  }
});

// ../node_modules/ramda/src/lensProp.js
var require_lensProp = __commonJS({
  "../node_modules/ramda/src/lensProp.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var assoc = require_assoc();
    var lens = require_lens();
    var prop = require_prop();
    var lensProp = /* @__PURE__ */ _curry1(function lensProp2(k) {
      return lens(prop(k), assoc(k));
    });
    module2.exports = lensProp;
  }
});

// ../node_modules/ramda/src/lt.js
var require_lt = __commonJS({
  "../node_modules/ramda/src/lt.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var lt = /* @__PURE__ */ _curry2(function lt2(a, b) {
      return a < b;
    });
    module2.exports = lt;
  }
});

// ../node_modules/ramda/src/lte.js
var require_lte = __commonJS({
  "../node_modules/ramda/src/lte.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var lte = /* @__PURE__ */ _curry2(function lte2(a, b) {
      return a <= b;
    });
    module2.exports = lte;
  }
});

// ../node_modules/ramda/src/mapAccum.js
var require_mapAccum = __commonJS({
  "../node_modules/ramda/src/mapAccum.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var mapAccum = /* @__PURE__ */ _curry3(function mapAccum2(fn, acc, list) {
      var idx = 0;
      var len = list.length;
      var result = [];
      var tuple = [acc];
      while (idx < len) {
        tuple = fn(tuple[0], list[idx]);
        result[idx] = tuple[1];
        idx += 1;
      }
      return [tuple[0], result];
    });
    module2.exports = mapAccum;
  }
});

// ../node_modules/ramda/src/mapAccumRight.js
var require_mapAccumRight = __commonJS({
  "../node_modules/ramda/src/mapAccumRight.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var mapAccumRight = /* @__PURE__ */ _curry3(function mapAccumRight2(fn, acc, list) {
      var idx = list.length - 1;
      var result = [];
      var tuple = [acc];
      while (idx >= 0) {
        tuple = fn(list[idx], tuple[0]);
        result[idx] = tuple[1];
        idx -= 1;
      }
      return [result, tuple[0]];
    });
    module2.exports = mapAccumRight;
  }
});

// ../node_modules/ramda/src/mapObjIndexed.js
var require_mapObjIndexed = __commonJS({
  "../node_modules/ramda/src/mapObjIndexed.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduce = require_reduce();
    var keys = require_keys3();
    var mapObjIndexed = /* @__PURE__ */ _curry2(function mapObjIndexed2(fn, obj) {
      return _reduce(function(acc, key) {
        acc[key] = fn(obj[key], key, obj);
        return acc;
      }, {}, keys(obj));
    });
    module2.exports = mapObjIndexed;
  }
});

// ../node_modules/ramda/src/match.js
var require_match = __commonJS({
  "../node_modules/ramda/src/match.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var match = /* @__PURE__ */ _curry2(function match2(rx, str) {
      return str.match(rx) || [];
    });
    module2.exports = match;
  }
});

// ../node_modules/ramda/src/mathMod.js
var require_mathMod = __commonJS({
  "../node_modules/ramda/src/mathMod.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isInteger = require_isInteger();
    var mathMod = /* @__PURE__ */ _curry2(function mathMod2(m, p) {
      if (!_isInteger(m)) {
        return NaN;
      }
      if (!_isInteger(p) || p < 1) {
        return NaN;
      }
      return (m % p + p) % p;
    });
    module2.exports = mathMod;
  }
});

// ../node_modules/ramda/src/maxBy.js
var require_maxBy = __commonJS({
  "../node_modules/ramda/src/maxBy.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var maxBy = /* @__PURE__ */ _curry3(function maxBy2(f, a, b) {
      return f(b) > f(a) ? b : a;
    });
    module2.exports = maxBy;
  }
});

// ../node_modules/ramda/src/sum.js
var require_sum = __commonJS({
  "../node_modules/ramda/src/sum.js"(exports2, module2) {
    var add = require_add();
    var reduce = require_reduce2();
    var sum = /* @__PURE__ */ reduce(add, 0);
    module2.exports = sum;
  }
});

// ../node_modules/ramda/src/mean.js
var require_mean = __commonJS({
  "../node_modules/ramda/src/mean.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var sum = require_sum();
    var mean = /* @__PURE__ */ _curry1(function mean2(list) {
      return sum(list) / list.length;
    });
    module2.exports = mean;
  }
});

// ../node_modules/ramda/src/median.js
var require_median = __commonJS({
  "../node_modules/ramda/src/median.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var mean = require_mean();
    var median = /* @__PURE__ */ _curry1(function median2(list) {
      var len = list.length;
      if (len === 0) {
        return NaN;
      }
      var width = 2 - len % 2;
      var idx = (len - width) / 2;
      return mean(Array.prototype.slice.call(list, 0).sort(function(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
      }).slice(idx, idx + width));
    });
    module2.exports = median;
  }
});

// ../node_modules/ramda/src/memoizeWith.js
var require_memoizeWith = __commonJS({
  "../node_modules/ramda/src/memoizeWith.js"(exports2, module2) {
    var _arity = require_arity();
    var _curry2 = require_curry2();
    var _has = require_has();
    var memoizeWith = /* @__PURE__ */ _curry2(function memoizeWith2(mFn, fn) {
      var cache = {};
      return _arity(fn.length, function() {
        var key = mFn.apply(this, arguments);
        if (!_has(key, cache)) {
          cache[key] = fn.apply(this, arguments);
        }
        return cache[key];
      });
    });
    module2.exports = memoizeWith;
  }
});

// ../node_modules/ramda/src/memoize.js
var require_memoize = __commonJS({
  "../node_modules/ramda/src/memoize.js"(exports2, module2) {
    var memoizeWith = require_memoizeWith();
    var toString = require_toString2();
    var memoize = /* @__PURE__ */ memoizeWith(function() {
      return toString(arguments);
    });
    module2.exports = memoize;
  }
});

// ../node_modules/ramda/src/merge.js
var require_merge3 = __commonJS({
  "../node_modules/ramda/src/merge.js"(exports2, module2) {
    var _assign = require_assign2();
    var _curry2 = require_curry2();
    var merge = /* @__PURE__ */ _curry2(function merge2(l, r) {
      return _assign({}, l, r);
    });
    module2.exports = merge;
  }
});

// ../node_modules/ramda/src/mergeAll.js
var require_mergeAll = __commonJS({
  "../node_modules/ramda/src/mergeAll.js"(exports2, module2) {
    var _assign = require_assign2();
    var _curry1 = require_curry1();
    var mergeAll = /* @__PURE__ */ _curry1(function mergeAll2(list) {
      return _assign.apply(null, [{}].concat(list));
    });
    module2.exports = mergeAll;
  }
});

// ../node_modules/ramda/src/mergeWithKey.js
var require_mergeWithKey = __commonJS({
  "../node_modules/ramda/src/mergeWithKey.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var _has = require_has();
    var mergeWithKey = /* @__PURE__ */ _curry3(function mergeWithKey2(fn, l, r) {
      var result = {};
      var k;
      for (k in l) {
        if (_has(k, l)) {
          result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
        }
      }
      for (k in r) {
        if (_has(k, r) && !_has(k, result)) {
          result[k] = r[k];
        }
      }
      return result;
    });
    module2.exports = mergeWithKey;
  }
});

// ../node_modules/ramda/src/mergeDeepWithKey.js
var require_mergeDeepWithKey = __commonJS({
  "../node_modules/ramda/src/mergeDeepWithKey.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var _isObject = require_isObject2();
    var mergeWithKey = require_mergeWithKey();
    var mergeDeepWithKey = /* @__PURE__ */ _curry3(function mergeDeepWithKey2(fn, lObj, rObj) {
      return mergeWithKey(function(k, lVal, rVal) {
        if (_isObject(lVal) && _isObject(rVal)) {
          return mergeDeepWithKey2(fn, lVal, rVal);
        } else {
          return fn(k, lVal, rVal);
        }
      }, lObj, rObj);
    });
    module2.exports = mergeDeepWithKey;
  }
});

// ../node_modules/ramda/src/mergeDeepLeft.js
var require_mergeDeepLeft = __commonJS({
  "../node_modules/ramda/src/mergeDeepLeft.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var mergeDeepWithKey = require_mergeDeepWithKey();
    var mergeDeepLeft = /* @__PURE__ */ _curry2(function mergeDeepLeft2(lObj, rObj) {
      return mergeDeepWithKey(function(k, lVal, rVal) {
        return lVal;
      }, lObj, rObj);
    });
    module2.exports = mergeDeepLeft;
  }
});

// ../node_modules/ramda/src/mergeDeepRight.js
var require_mergeDeepRight = __commonJS({
  "../node_modules/ramda/src/mergeDeepRight.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var mergeDeepWithKey = require_mergeDeepWithKey();
    var mergeDeepRight = /* @__PURE__ */ _curry2(function mergeDeepRight2(lObj, rObj) {
      return mergeDeepWithKey(function(k, lVal, rVal) {
        return rVal;
      }, lObj, rObj);
    });
    module2.exports = mergeDeepRight;
  }
});

// ../node_modules/ramda/src/mergeDeepWith.js
var require_mergeDeepWith = __commonJS({
  "../node_modules/ramda/src/mergeDeepWith.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var mergeDeepWithKey = require_mergeDeepWithKey();
    var mergeDeepWith = /* @__PURE__ */ _curry3(function mergeDeepWith2(fn, lObj, rObj) {
      return mergeDeepWithKey(function(k, lVal, rVal) {
        return fn(lVal, rVal);
      }, lObj, rObj);
    });
    module2.exports = mergeDeepWith;
  }
});

// ../node_modules/ramda/src/mergeWith.js
var require_mergeWith = __commonJS({
  "../node_modules/ramda/src/mergeWith.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var mergeWithKey = require_mergeWithKey();
    var mergeWith = /* @__PURE__ */ _curry3(function mergeWith2(fn, l, r) {
      return mergeWithKey(function(_2, _l, _r) {
        return fn(_l, _r);
      }, l, r);
    });
    module2.exports = mergeWith;
  }
});

// ../node_modules/ramda/src/min.js
var require_min = __commonJS({
  "../node_modules/ramda/src/min.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var min = /* @__PURE__ */ _curry2(function min2(a, b) {
      return b < a ? b : a;
    });
    module2.exports = min;
  }
});

// ../node_modules/ramda/src/minBy.js
var require_minBy = __commonJS({
  "../node_modules/ramda/src/minBy.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var minBy = /* @__PURE__ */ _curry3(function minBy2(f, a, b) {
      return f(b) < f(a) ? b : a;
    });
    module2.exports = minBy;
  }
});

// ../node_modules/ramda/src/modulo.js
var require_modulo = __commonJS({
  "../node_modules/ramda/src/modulo.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var modulo = /* @__PURE__ */ _curry2(function modulo2(a, b) {
      return a % b;
    });
    module2.exports = modulo;
  }
});

// ../node_modules/ramda/src/multiply.js
var require_multiply = __commonJS({
  "../node_modules/ramda/src/multiply.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var multiply = /* @__PURE__ */ _curry2(function multiply2(a, b) {
      return a * b;
    });
    module2.exports = multiply;
  }
});

// ../node_modules/ramda/src/negate.js
var require_negate = __commonJS({
  "../node_modules/ramda/src/negate.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var negate = /* @__PURE__ */ _curry1(function negate2(n) {
      return -n;
    });
    module2.exports = negate;
  }
});

// ../node_modules/ramda/src/none.js
var require_none = __commonJS({
  "../node_modules/ramda/src/none.js"(exports2, module2) {
    var _complement = require_complement2();
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xany = require_xany();
    var any = require_any();
    var none = /* @__PURE__ */ _curry2(/* @__PURE__ */ _complement(/* @__PURE__ */ _dispatchable(["any"], _xany, any)));
    module2.exports = none;
  }
});

// ../node_modules/ramda/src/nthArg.js
var require_nthArg = __commonJS({
  "../node_modules/ramda/src/nthArg.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var curryN = require_curryN2();
    var nth = require_nth();
    var nthArg = /* @__PURE__ */ _curry1(function nthArg2(n) {
      var arity = n < 0 ? 1 : n + 1;
      return curryN(arity, function() {
        return nth(n, arguments);
      });
    });
    module2.exports = nthArg;
  }
});

// ../node_modules/ramda/src/o.js
var require_o = __commonJS({
  "../node_modules/ramda/src/o.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var o = /* @__PURE__ */ _curry3(function o2(f, g, x) {
      return f(g(x));
    });
    module2.exports = o;
  }
});

// ../node_modules/ramda/src/internal/_of.js
var require_of = __commonJS({
  "../node_modules/ramda/src/internal/_of.js"(exports2, module2) {
    function _of(x) {
      return [x];
    }
    module2.exports = _of;
  }
});

// ../node_modules/ramda/src/of.js
var require_of2 = __commonJS({
  "../node_modules/ramda/src/of.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _of = require_of();
    var of = /* @__PURE__ */ _curry1(_of);
    module2.exports = of;
  }
});

// ../node_modules/ramda/src/omit.js
var require_omit = __commonJS({
  "../node_modules/ramda/src/omit.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var omit = /* @__PURE__ */ _curry2(function omit2(names, obj) {
      var result = {};
      var index = {};
      var idx = 0;
      var len = names.length;
      while (idx < len) {
        index[names[idx]] = 1;
        idx += 1;
      }
      for (var prop in obj) {
        if (!index.hasOwnProperty(prop)) {
          result[prop] = obj[prop];
        }
      }
      return result;
    });
    module2.exports = omit;
  }
});

// ../node_modules/ramda/src/once.js
var require_once2 = __commonJS({
  "../node_modules/ramda/src/once.js"(exports2, module2) {
    var _arity = require_arity();
    var _curry1 = require_curry1();
    var once = /* @__PURE__ */ _curry1(function once2(fn) {
      var called = false;
      var result;
      return _arity(fn.length, function() {
        if (called) {
          return result;
        }
        called = true;
        result = fn.apply(this, arguments);
        return result;
      });
    });
    module2.exports = once;
  }
});

// ../node_modules/ramda/src/over.js
var require_over = __commonJS({
  "../node_modules/ramda/src/over.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var Identity = function(x) {
      return { value: x, map: function(f) {
        return Identity(f(x));
      } };
    };
    var over = /* @__PURE__ */ _curry3(function over2(lens, f, x) {
      return lens(function(y) {
        return Identity(f(y));
      })(x).value;
    });
    module2.exports = over;
  }
});

// ../node_modules/ramda/src/pair.js
var require_pair = __commonJS({
  "../node_modules/ramda/src/pair.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var pair = /* @__PURE__ */ _curry2(function pair2(fst, snd) {
      return [fst, snd];
    });
    module2.exports = pair;
  }
});

// ../node_modules/ramda/src/internal/_createPartialApplicator.js
var require_createPartialApplicator = __commonJS({
  "../node_modules/ramda/src/internal/_createPartialApplicator.js"(exports2, module2) {
    var _arity = require_arity();
    var _curry2 = require_curry2();
    function _createPartialApplicator(concat) {
      return _curry2(function(fn, args) {
        return _arity(Math.max(0, fn.length - args.length), function() {
          return fn.apply(this, concat(args, arguments));
        });
      });
    }
    module2.exports = _createPartialApplicator;
  }
});

// ../node_modules/ramda/src/partial.js
var require_partial2 = __commonJS({
  "../node_modules/ramda/src/partial.js"(exports2, module2) {
    var _concat = require_concat();
    var _createPartialApplicator = require_createPartialApplicator();
    var partial = /* @__PURE__ */ _createPartialApplicator(_concat);
    module2.exports = partial;
  }
});

// ../node_modules/ramda/src/partialRight.js
var require_partialRight = __commonJS({
  "../node_modules/ramda/src/partialRight.js"(exports2, module2) {
    var _concat = require_concat();
    var _createPartialApplicator = require_createPartialApplicator();
    var flip = require_flip();
    var partialRight = /* @__PURE__ */ _createPartialApplicator(/* @__PURE__ */ flip(_concat));
    module2.exports = partialRight;
  }
});

// ../node_modules/ramda/src/partition.js
var require_partition = __commonJS({
  "../node_modules/ramda/src/partition.js"(exports2, module2) {
    var filter = require_filter2();
    var juxt = require_juxt();
    var reject2 = require_reject();
    var partition = /* @__PURE__ */ juxt([filter, reject2]);
    module2.exports = partition;
  }
});

// ../node_modules/ramda/src/pathEq.js
var require_pathEq = __commonJS({
  "../node_modules/ramda/src/pathEq.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var equals = require_equals2();
    var path = require_path2();
    var pathEq = /* @__PURE__ */ _curry3(function pathEq2(_path, val, obj) {
      return equals(path(_path, obj), val);
    });
    module2.exports = pathEq;
  }
});

// ../node_modules/ramda/src/pathOr.js
var require_pathOr = __commonJS({
  "../node_modules/ramda/src/pathOr.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var defaultTo = require_defaultTo();
    var path = require_path2();
    var pathOr = /* @__PURE__ */ _curry3(function pathOr2(d, p, obj) {
      return defaultTo(d, path(p, obj));
    });
    module2.exports = pathOr;
  }
});

// ../node_modules/ramda/src/pathSatisfies.js
var require_pathSatisfies = __commonJS({
  "../node_modules/ramda/src/pathSatisfies.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var path = require_path2();
    var pathSatisfies = /* @__PURE__ */ _curry3(function pathSatisfies2(pred, propPath, obj) {
      return propPath.length > 0 && pred(path(propPath, obj));
    });
    module2.exports = pathSatisfies;
  }
});

// ../node_modules/ramda/src/pick.js
var require_pick = __commonJS({
  "../node_modules/ramda/src/pick.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var pick = /* @__PURE__ */ _curry2(function pick2(names, obj) {
      var result = {};
      var idx = 0;
      while (idx < names.length) {
        if (names[idx] in obj) {
          result[names[idx]] = obj[names[idx]];
        }
        idx += 1;
      }
      return result;
    });
    module2.exports = pick;
  }
});

// ../node_modules/ramda/src/pickAll.js
var require_pickAll = __commonJS({
  "../node_modules/ramda/src/pickAll.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var pickAll = /* @__PURE__ */ _curry2(function pickAll2(names, obj) {
      var result = {};
      var idx = 0;
      var len = names.length;
      while (idx < len) {
        var name = names[idx];
        result[name] = obj[name];
        idx += 1;
      }
      return result;
    });
    module2.exports = pickAll;
  }
});

// ../node_modules/ramda/src/pickBy.js
var require_pickBy = __commonJS({
  "../node_modules/ramda/src/pickBy.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var pickBy = /* @__PURE__ */ _curry2(function pickBy2(test, obj) {
      var result = {};
      for (var prop in obj) {
        if (test(obj[prop], prop, obj)) {
          result[prop] = obj[prop];
        }
      }
      return result;
    });
    module2.exports = pickBy;
  }
});

// ../node_modules/ramda/src/pipeK.js
var require_pipeK = __commonJS({
  "../node_modules/ramda/src/pipeK.js"(exports2, module2) {
    var composeK = require_composeK();
    var reverse = require_reverse();
    function pipeK() {
      if (arguments.length === 0) {
        throw new Error("pipeK requires at least one argument");
      }
      return composeK.apply(this, reverse(arguments));
    }
    module2.exports = pipeK;
  }
});

// ../node_modules/ramda/src/prepend.js
var require_prepend = __commonJS({
  "../node_modules/ramda/src/prepend.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry2 = require_curry2();
    var prepend = /* @__PURE__ */ _curry2(function prepend2(el, list) {
      return _concat([el], list);
    });
    module2.exports = prepend;
  }
});

// ../node_modules/ramda/src/product.js
var require_product = __commonJS({
  "../node_modules/ramda/src/product.js"(exports2, module2) {
    var multiply = require_multiply();
    var reduce = require_reduce2();
    var product = /* @__PURE__ */ reduce(multiply, 1);
    module2.exports = product;
  }
});

// ../node_modules/ramda/src/useWith.js
var require_useWith = __commonJS({
  "../node_modules/ramda/src/useWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var curryN = require_curryN2();
    var useWith = /* @__PURE__ */ _curry2(function useWith2(fn, transformers) {
      return curryN(transformers.length, function() {
        var args = [];
        var idx = 0;
        while (idx < transformers.length) {
          args.push(transformers[idx].call(this, arguments[idx]));
          idx += 1;
        }
        return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
      });
    });
    module2.exports = useWith;
  }
});

// ../node_modules/ramda/src/project.js
var require_project = __commonJS({
  "../node_modules/ramda/src/project.js"(exports2, module2) {
    var _map = require_map2();
    var identity = require_identity3();
    var pickAll = require_pickAll();
    var useWith = require_useWith();
    var project = /* @__PURE__ */ useWith(_map, [pickAll, identity]);
    module2.exports = project;
  }
});

// ../node_modules/ramda/src/propEq.js
var require_propEq = __commonJS({
  "../node_modules/ramda/src/propEq.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var equals = require_equals2();
    var propEq = /* @__PURE__ */ _curry3(function propEq2(name, val, obj) {
      return equals(val, obj[name]);
    });
    module2.exports = propEq;
  }
});

// ../node_modules/ramda/src/propIs.js
var require_propIs = __commonJS({
  "../node_modules/ramda/src/propIs.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var is = require_is8();
    var propIs = /* @__PURE__ */ _curry3(function propIs2(type, name, obj) {
      return is(type, obj[name]);
    });
    module2.exports = propIs;
  }
});

// ../node_modules/ramda/src/propOr.js
var require_propOr = __commonJS({
  "../node_modules/ramda/src/propOr.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var _has = require_has();
    var propOr = /* @__PURE__ */ _curry3(function propOr2(val, p, obj) {
      return obj != null && _has(p, obj) ? obj[p] : val;
    });
    module2.exports = propOr;
  }
});

// ../node_modules/ramda/src/propSatisfies.js
var require_propSatisfies = __commonJS({
  "../node_modules/ramda/src/propSatisfies.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var propSatisfies = /* @__PURE__ */ _curry3(function propSatisfies2(pred, name, obj) {
      return pred(obj[name]);
    });
    module2.exports = propSatisfies;
  }
});

// ../node_modules/ramda/src/props.js
var require_props = __commonJS({
  "../node_modules/ramda/src/props.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var props = /* @__PURE__ */ _curry2(function props2(ps, obj) {
      var len = ps.length;
      var out = [];
      var idx = 0;
      while (idx < len) {
        out[idx] = obj[ps[idx]];
        idx += 1;
      }
      return out;
    });
    module2.exports = props;
  }
});

// ../node_modules/ramda/src/range.js
var require_range = __commonJS({
  "../node_modules/ramda/src/range.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _isNumber = require_isNumber();
    var range = /* @__PURE__ */ _curry2(function range2(from, to) {
      if (!(_isNumber(from) && _isNumber(to))) {
        throw new TypeError("Both arguments to range must be numbers");
      }
      var result = [];
      var n = from;
      while (n < to) {
        result.push(n);
        n += 1;
      }
      return result;
    });
    module2.exports = range;
  }
});

// ../node_modules/ramda/src/reduceRight.js
var require_reduceRight = __commonJS({
  "../node_modules/ramda/src/reduceRight.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var reduceRight = /* @__PURE__ */ _curry3(function reduceRight2(fn, acc, list) {
      var idx = list.length - 1;
      while (idx >= 0) {
        acc = fn(list[idx], acc);
        idx -= 1;
      }
      return acc;
    });
    module2.exports = reduceRight;
  }
});

// ../node_modules/ramda/src/reduceWhile.js
var require_reduceWhile = __commonJS({
  "../node_modules/ramda/src/reduceWhile.js"(exports2, module2) {
    var _curryN = require_curryN();
    var _reduce = require_reduce();
    var _reduced = require_reduced();
    var reduceWhile = /* @__PURE__ */ _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
      return _reduce(function(acc, x) {
        return pred(acc, x) ? fn(acc, x) : _reduced(acc);
      }, a, list);
    });
    module2.exports = reduceWhile;
  }
});

// ../node_modules/ramda/src/reduced.js
var require_reduced2 = __commonJS({
  "../node_modules/ramda/src/reduced.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _reduced = require_reduced();
    var reduced = /* @__PURE__ */ _curry1(_reduced);
    module2.exports = reduced;
  }
});

// ../node_modules/ramda/src/times.js
var require_times = __commonJS({
  "../node_modules/ramda/src/times.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var times = /* @__PURE__ */ _curry2(function times2(fn, n) {
      var len = Number(n);
      var idx = 0;
      var list;
      if (len < 0 || isNaN(len)) {
        throw new RangeError("n must be a non-negative number");
      }
      list = new Array(len);
      while (idx < len) {
        list[idx] = fn(idx);
        idx += 1;
      }
      return list;
    });
    module2.exports = times;
  }
});

// ../node_modules/ramda/src/repeat.js
var require_repeat = __commonJS({
  "../node_modules/ramda/src/repeat.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var always = require_always();
    var times = require_times();
    var repeat = /* @__PURE__ */ _curry2(function repeat2(value, n) {
      return times(always(value), n);
    });
    module2.exports = repeat;
  }
});

// ../node_modules/ramda/src/replace.js
var require_replace = __commonJS({
  "../node_modules/ramda/src/replace.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var replace = /* @__PURE__ */ _curry3(function replace2(regex, replacement, str) {
      return str.replace(regex, replacement);
    });
    module2.exports = replace;
  }
});

// ../node_modules/ramda/src/scan.js
var require_scan2 = __commonJS({
  "../node_modules/ramda/src/scan.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var scan = /* @__PURE__ */ _curry3(function scan2(fn, acc, list) {
      var idx = 0;
      var len = list.length;
      var result = [acc];
      while (idx < len) {
        acc = fn(acc, list[idx]);
        result[idx + 1] = acc;
        idx += 1;
      }
      return result;
    });
    module2.exports = scan;
  }
});

// ../node_modules/ramda/src/sequence.js
var require_sequence = __commonJS({
  "../node_modules/ramda/src/sequence.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var ap = require_ap();
    var map = require_map3();
    var prepend = require_prepend();
    var reduceRight = require_reduceRight();
    var sequence = /* @__PURE__ */ _curry2(function sequence2(of, traversable) {
      return typeof traversable.sequence === "function" ? traversable.sequence(of) : reduceRight(function(x, acc) {
        return ap(map(prepend, x), acc);
      }, of([]), traversable);
    });
    module2.exports = sequence;
  }
});

// ../node_modules/ramda/src/set.js
var require_set = __commonJS({
  "../node_modules/ramda/src/set.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var always = require_always();
    var over = require_over();
    var set = /* @__PURE__ */ _curry3(function set2(lens, v, x) {
      return over(lens, always(v), x);
    });
    module2.exports = set;
  }
});

// ../node_modules/ramda/src/sort.js
var require_sort = __commonJS({
  "../node_modules/ramda/src/sort.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var sort = /* @__PURE__ */ _curry2(function sort2(comparator, list) {
      return Array.prototype.slice.call(list, 0).sort(comparator);
    });
    module2.exports = sort;
  }
});

// ../node_modules/ramda/src/sortBy.js
var require_sortBy = __commonJS({
  "../node_modules/ramda/src/sortBy.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var sortBy = /* @__PURE__ */ _curry2(function sortBy2(fn, list) {
      return Array.prototype.slice.call(list, 0).sort(function(a, b) {
        var aa = fn(a);
        var bb = fn(b);
        return aa < bb ? -1 : aa > bb ? 1 : 0;
      });
    });
    module2.exports = sortBy;
  }
});

// ../node_modules/ramda/src/sortWith.js
var require_sortWith = __commonJS({
  "../node_modules/ramda/src/sortWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var sortWith = /* @__PURE__ */ _curry2(function sortWith2(fns, list) {
      return Array.prototype.slice.call(list, 0).sort(function(a, b) {
        var result = 0;
        var i = 0;
        while (result === 0 && i < fns.length) {
          result = fns[i](a, b);
          i += 1;
        }
        return result;
      });
    });
    module2.exports = sortWith;
  }
});

// ../node_modules/ramda/src/split.js
var require_split = __commonJS({
  "../node_modules/ramda/src/split.js"(exports2, module2) {
    var invoker = require_invoker();
    var split = /* @__PURE__ */ invoker(1, "split");
    module2.exports = split;
  }
});

// ../node_modules/ramda/src/splitAt.js
var require_splitAt = __commonJS({
  "../node_modules/ramda/src/splitAt.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var length = require_length();
    var slice = require_slice();
    var splitAt = /* @__PURE__ */ _curry2(function splitAt2(index, array) {
      return [slice(0, index, array), slice(index, length(array), array)];
    });
    module2.exports = splitAt;
  }
});

// ../node_modules/ramda/src/splitEvery.js
var require_splitEvery = __commonJS({
  "../node_modules/ramda/src/splitEvery.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var slice = require_slice();
    var splitEvery = /* @__PURE__ */ _curry2(function splitEvery2(n, list) {
      if (n <= 0) {
        throw new Error("First argument to splitEvery must be a positive integer");
      }
      var result = [];
      var idx = 0;
      while (idx < list.length) {
        result.push(slice(idx, idx += n, list));
      }
      return result;
    });
    module2.exports = splitEvery;
  }
});

// ../node_modules/ramda/src/splitWhen.js
var require_splitWhen = __commonJS({
  "../node_modules/ramda/src/splitWhen.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var splitWhen = /* @__PURE__ */ _curry2(function splitWhen2(pred, list) {
      var idx = 0;
      var len = list.length;
      var prefix = [];
      while (idx < len && !pred(list[idx])) {
        prefix.push(list[idx]);
        idx += 1;
      }
      return [prefix, Array.prototype.slice.call(list, idx)];
    });
    module2.exports = splitWhen;
  }
});

// ../node_modules/ramda/src/startsWith.js
var require_startsWith = __commonJS({
  "../node_modules/ramda/src/startsWith.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var equals = require_equals2();
    var take = require_take();
    var startsWith = /* @__PURE__ */ _curry2(function(prefix, list) {
      return equals(take(prefix.length, list), prefix);
    });
    module2.exports = startsWith;
  }
});

// ../node_modules/ramda/src/subtract.js
var require_subtract = __commonJS({
  "../node_modules/ramda/src/subtract.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var subtract = /* @__PURE__ */ _curry2(function subtract2(a, b) {
      return Number(a) - Number(b);
    });
    module2.exports = subtract;
  }
});

// ../node_modules/ramda/src/symmetricDifference.js
var require_symmetricDifference = __commonJS({
  "../node_modules/ramda/src/symmetricDifference.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var concat = require_concat2();
    var difference = require_difference();
    var symmetricDifference = /* @__PURE__ */ _curry2(function symmetricDifference2(list1, list2) {
      return concat(difference(list1, list2), difference(list2, list1));
    });
    module2.exports = symmetricDifference;
  }
});

// ../node_modules/ramda/src/symmetricDifferenceWith.js
var require_symmetricDifferenceWith = __commonJS({
  "../node_modules/ramda/src/symmetricDifferenceWith.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var concat = require_concat2();
    var differenceWith = require_differenceWith();
    var symmetricDifferenceWith = /* @__PURE__ */ _curry3(function symmetricDifferenceWith2(pred, list1, list2) {
      return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
    });
    module2.exports = symmetricDifferenceWith;
  }
});

// ../node_modules/ramda/src/takeLastWhile.js
var require_takeLastWhile = __commonJS({
  "../node_modules/ramda/src/takeLastWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var slice = require_slice();
    var takeLastWhile = /* @__PURE__ */ _curry2(function takeLastWhile2(fn, xs) {
      var idx = xs.length - 1;
      while (idx >= 0 && fn(xs[idx])) {
        idx -= 1;
      }
      return slice(idx + 1, Infinity, xs);
    });
    module2.exports = takeLastWhile;
  }
});

// ../node_modules/ramda/src/internal/_xtakeWhile.js
var require_xtakeWhile = __commonJS({
  "../node_modules/ramda/src/internal/_xtakeWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _reduced = require_reduced();
    var _xfBase = require_xfBase();
    var XTakeWhile = /* @__PURE__ */ function() {
      function XTakeWhile2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XTakeWhile2.prototype["@@transducer/init"] = _xfBase.init;
      XTakeWhile2.prototype["@@transducer/result"] = _xfBase.result;
      XTakeWhile2.prototype["@@transducer/step"] = function(result, input) {
        return this.f(input) ? this.xf["@@transducer/step"](result, input) : _reduced(result);
      };
      return XTakeWhile2;
    }();
    var _xtakeWhile = /* @__PURE__ */ _curry2(function _xtakeWhile2(f, xf) {
      return new XTakeWhile(f, xf);
    });
    module2.exports = _xtakeWhile;
  }
});

// ../node_modules/ramda/src/takeWhile.js
var require_takeWhile = __commonJS({
  "../node_modules/ramda/src/takeWhile.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xtakeWhile = require_xtakeWhile();
    var slice = require_slice();
    var takeWhile = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable(["takeWhile"], _xtakeWhile, function takeWhile2(fn, xs) {
      var idx = 0;
      var len = xs.length;
      while (idx < len && fn(xs[idx])) {
        idx += 1;
      }
      return slice(0, idx, xs);
    }));
    module2.exports = takeWhile;
  }
});

// ../node_modules/ramda/src/internal/_xtap.js
var require_xtap = __commonJS({
  "../node_modules/ramda/src/internal/_xtap.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _xfBase = require_xfBase();
    var XTap = /* @__PURE__ */ function() {
      function XTap2(f, xf) {
        this.xf = xf;
        this.f = f;
      }
      XTap2.prototype["@@transducer/init"] = _xfBase.init;
      XTap2.prototype["@@transducer/result"] = _xfBase.result;
      XTap2.prototype["@@transducer/step"] = function(result, input) {
        this.f(input);
        return this.xf["@@transducer/step"](result, input);
      };
      return XTap2;
    }();
    var _xtap = /* @__PURE__ */ _curry2(function _xtap2(f, xf) {
      return new XTap(f, xf);
    });
    module2.exports = _xtap;
  }
});

// ../node_modules/ramda/src/tap.js
var require_tap = __commonJS({
  "../node_modules/ramda/src/tap.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _dispatchable = require_dispatchable();
    var _xtap = require_xtap();
    var tap = /* @__PURE__ */ _curry2(/* @__PURE__ */ _dispatchable([], _xtap, function tap2(fn, x) {
      fn(x);
      return x;
    }));
    module2.exports = tap;
  }
});

// ../node_modules/ramda/src/internal/_isRegExp.js
var require_isRegExp = __commonJS({
  "../node_modules/ramda/src/internal/_isRegExp.js"(exports2, module2) {
    function _isRegExp(x) {
      return Object.prototype.toString.call(x) === "[object RegExp]";
    }
    module2.exports = _isRegExp;
  }
});

// ../node_modules/ramda/src/test.js
var require_test = __commonJS({
  "../node_modules/ramda/src/test.js"(exports2, module2) {
    var _cloneRegExp = require_cloneRegExp();
    var _curry2 = require_curry2();
    var _isRegExp = require_isRegExp();
    var toString = require_toString2();
    var test = /* @__PURE__ */ _curry2(function test2(pattern, str) {
      if (!_isRegExp(pattern)) {
        throw new TypeError("\u2018test\u2019 requires a value of type RegExp as its first argument; received " + toString(pattern));
      }
      return _cloneRegExp(pattern).test(str);
    });
    module2.exports = test;
  }
});

// ../node_modules/ramda/src/toLower.js
var require_toLower = __commonJS({
  "../node_modules/ramda/src/toLower.js"(exports2, module2) {
    var invoker = require_invoker();
    var toLower = /* @__PURE__ */ invoker(0, "toLowerCase");
    module2.exports = toLower;
  }
});

// ../node_modules/ramda/src/toPairs.js
var require_toPairs = __commonJS({
  "../node_modules/ramda/src/toPairs.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var _has = require_has();
    var toPairs = /* @__PURE__ */ _curry1(function toPairs2(obj) {
      var pairs = [];
      for (var prop in obj) {
        if (_has(prop, obj)) {
          pairs[pairs.length] = [prop, obj[prop]];
        }
      }
      return pairs;
    });
    module2.exports = toPairs;
  }
});

// ../node_modules/ramda/src/toPairsIn.js
var require_toPairsIn = __commonJS({
  "../node_modules/ramda/src/toPairsIn.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var toPairsIn = /* @__PURE__ */ _curry1(function toPairsIn2(obj) {
      var pairs = [];
      for (var prop in obj) {
        pairs[pairs.length] = [prop, obj[prop]];
      }
      return pairs;
    });
    module2.exports = toPairsIn;
  }
});

// ../node_modules/ramda/src/toUpper.js
var require_toUpper = __commonJS({
  "../node_modules/ramda/src/toUpper.js"(exports2, module2) {
    var invoker = require_invoker();
    var toUpper = /* @__PURE__ */ invoker(0, "toUpperCase");
    module2.exports = toUpper;
  }
});

// ../node_modules/ramda/src/transduce.js
var require_transduce = __commonJS({
  "../node_modules/ramda/src/transduce.js"(exports2, module2) {
    var _reduce = require_reduce();
    var _xwrap = require_xwrap();
    var curryN = require_curryN2();
    var transduce = /* @__PURE__ */ curryN(4, function transduce2(xf, fn, acc, list) {
      return _reduce(xf(typeof fn === "function" ? _xwrap(fn) : fn), acc, list);
    });
    module2.exports = transduce;
  }
});

// ../node_modules/ramda/src/transpose.js
var require_transpose = __commonJS({
  "../node_modules/ramda/src/transpose.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var transpose = /* @__PURE__ */ _curry1(function transpose2(outerlist) {
      var i = 0;
      var result = [];
      while (i < outerlist.length) {
        var innerlist = outerlist[i];
        var j = 0;
        while (j < innerlist.length) {
          if (typeof result[j] === "undefined") {
            result[j] = [];
          }
          result[j].push(innerlist[j]);
          j += 1;
        }
        i += 1;
      }
      return result;
    });
    module2.exports = transpose;
  }
});

// ../node_modules/ramda/src/traverse.js
var require_traverse2 = __commonJS({
  "../node_modules/ramda/src/traverse.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var map = require_map3();
    var sequence = require_sequence();
    var traverse = /* @__PURE__ */ _curry3(function traverse2(of, f, traversable) {
      return typeof traversable["fantasy-land/traverse"] === "function" ? traversable["fantasy-land/traverse"](f, of) : sequence(of, map(f, traversable));
    });
    module2.exports = traverse;
  }
});

// ../node_modules/ramda/src/trim.js
var require_trim = __commonJS({
  "../node_modules/ramda/src/trim.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var ws = "	\n\v\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
    var zeroWidth = "\u200B";
    var hasProtoTrim = typeof String.prototype.trim === "function";
    var _trim = !hasProtoTrim || /* @__PURE__ */ ws.trim() || !/* @__PURE__ */ zeroWidth.trim() ? function trim2(str) {
      var beginRx = new RegExp("^[" + ws + "][" + ws + "]*");
      var endRx = new RegExp("[" + ws + "][" + ws + "]*$");
      return str.replace(beginRx, "").replace(endRx, "");
    } : function trim2(str) {
      return str.trim();
    };
    var trim = /* @__PURE__ */ _curry1(_trim);
    module2.exports = trim;
  }
});

// ../node_modules/ramda/src/tryCatch.js
var require_tryCatch = __commonJS({
  "../node_modules/ramda/src/tryCatch.js"(exports2, module2) {
    var _arity = require_arity();
    var _concat = require_concat();
    var _curry2 = require_curry2();
    var tryCatch = /* @__PURE__ */ _curry2(function _tryCatch(tryer, catcher) {
      return _arity(tryer.length, function() {
        try {
          return tryer.apply(this, arguments);
        } catch (e) {
          return catcher.apply(this, _concat([e], arguments));
        }
      });
    });
    module2.exports = tryCatch;
  }
});

// ../node_modules/ramda/src/unapply.js
var require_unapply = __commonJS({
  "../node_modules/ramda/src/unapply.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var unapply = /* @__PURE__ */ _curry1(function unapply2(fn) {
      return function() {
        return fn(Array.prototype.slice.call(arguments, 0));
      };
    });
    module2.exports = unapply;
  }
});

// ../node_modules/ramda/src/unary.js
var require_unary = __commonJS({
  "../node_modules/ramda/src/unary.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var nAry = require_nAry();
    var unary = /* @__PURE__ */ _curry1(function unary2(fn) {
      return nAry(1, fn);
    });
    module2.exports = unary;
  }
});

// ../node_modules/ramda/src/uncurryN.js
var require_uncurryN = __commonJS({
  "../node_modules/ramda/src/uncurryN.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var curryN = require_curryN2();
    var uncurryN = /* @__PURE__ */ _curry2(function uncurryN2(depth, fn) {
      return curryN(depth, function() {
        var currentDepth = 1;
        var value = fn;
        var idx = 0;
        var endIdx;
        while (currentDepth <= depth && typeof value === "function") {
          endIdx = currentDepth === depth ? arguments.length : idx + value.length;
          value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
          currentDepth += 1;
          idx = endIdx;
        }
        return value;
      });
    });
    module2.exports = uncurryN;
  }
});

// ../node_modules/ramda/src/unfold.js
var require_unfold = __commonJS({
  "../node_modules/ramda/src/unfold.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var unfold = /* @__PURE__ */ _curry2(function unfold2(fn, seed) {
      var pair = fn(seed);
      var result = [];
      while (pair && pair.length) {
        result[result.length] = pair[0];
        pair = fn(pair[1]);
      }
      return result;
    });
    module2.exports = unfold;
  }
});

// ../node_modules/ramda/src/union.js
var require_union = __commonJS({
  "../node_modules/ramda/src/union.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry2 = require_curry2();
    var compose = require_compose();
    var uniq = require_uniq();
    var union = /* @__PURE__ */ _curry2(/* @__PURE__ */ compose(uniq, _concat));
    module2.exports = union;
  }
});

// ../node_modules/ramda/src/uniqWith.js
var require_uniqWith = __commonJS({
  "../node_modules/ramda/src/uniqWith.js"(exports2, module2) {
    var _containsWith = require_containsWith();
    var _curry2 = require_curry2();
    var uniqWith = /* @__PURE__ */ _curry2(function uniqWith2(pred, list) {
      var idx = 0;
      var len = list.length;
      var result = [];
      var item;
      while (idx < len) {
        item = list[idx];
        if (!_containsWith(pred, item, result)) {
          result[result.length] = item;
        }
        idx += 1;
      }
      return result;
    });
    module2.exports = uniqWith;
  }
});

// ../node_modules/ramda/src/unionWith.js
var require_unionWith = __commonJS({
  "../node_modules/ramda/src/unionWith.js"(exports2, module2) {
    var _concat = require_concat();
    var _curry3 = require_curry3();
    var uniqWith = require_uniqWith();
    var unionWith = /* @__PURE__ */ _curry3(function unionWith2(pred, list1, list2) {
      return uniqWith(pred, _concat(list1, list2));
    });
    module2.exports = unionWith;
  }
});

// ../node_modules/ramda/src/unless.js
var require_unless = __commonJS({
  "../node_modules/ramda/src/unless.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var unless = /* @__PURE__ */ _curry3(function unless2(pred, whenFalseFn, x) {
      return pred(x) ? x : whenFalseFn(x);
    });
    module2.exports = unless;
  }
});

// ../node_modules/ramda/src/unnest.js
var require_unnest = __commonJS({
  "../node_modules/ramda/src/unnest.js"(exports2, module2) {
    var _identity = require_identity2();
    var chain = require_chain();
    var unnest = /* @__PURE__ */ chain(_identity);
    module2.exports = unnest;
  }
});

// ../node_modules/ramda/src/until.js
var require_until = __commonJS({
  "../node_modules/ramda/src/until.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var until = /* @__PURE__ */ _curry3(function until2(pred, fn, init) {
      var val = init;
      while (!pred(val)) {
        val = fn(val);
      }
      return val;
    });
    module2.exports = until;
  }
});

// ../node_modules/ramda/src/valuesIn.js
var require_valuesIn = __commonJS({
  "../node_modules/ramda/src/valuesIn.js"(exports2, module2) {
    var _curry1 = require_curry1();
    var valuesIn = /* @__PURE__ */ _curry1(function valuesIn2(obj) {
      var prop;
      var vs = [];
      for (prop in obj) {
        vs[vs.length] = obj[prop];
      }
      return vs;
    });
    module2.exports = valuesIn;
  }
});

// ../node_modules/ramda/src/view.js
var require_view = __commonJS({
  "../node_modules/ramda/src/view.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var Const = function(x) {
      return { value: x, "fantasy-land/map": function() {
        return this;
      } };
    };
    var view = /* @__PURE__ */ _curry2(function view2(lens, x) {
      return lens(Const)(x).value;
    });
    module2.exports = view;
  }
});

// ../node_modules/ramda/src/when.js
var require_when = __commonJS({
  "../node_modules/ramda/src/when.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var when = /* @__PURE__ */ _curry3(function when2(pred, whenTrueFn, x) {
      return pred(x) ? whenTrueFn(x) : x;
    });
    module2.exports = when;
  }
});

// ../node_modules/ramda/src/where.js
var require_where = __commonJS({
  "../node_modules/ramda/src/where.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var _has = require_has();
    var where = /* @__PURE__ */ _curry2(function where2(spec, testObj) {
      for (var prop in spec) {
        if (_has(prop, spec) && !spec[prop](testObj[prop])) {
          return false;
        }
      }
      return true;
    });
    module2.exports = where;
  }
});

// ../node_modules/ramda/src/whereEq.js
var require_whereEq = __commonJS({
  "../node_modules/ramda/src/whereEq.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var equals = require_equals2();
    var map = require_map3();
    var where = require_where();
    var whereEq = /* @__PURE__ */ _curry2(function whereEq2(spec, testObj) {
      return where(map(equals, spec), testObj);
    });
    module2.exports = whereEq;
  }
});

// ../node_modules/ramda/src/without.js
var require_without = __commonJS({
  "../node_modules/ramda/src/without.js"(exports2, module2) {
    var _contains = require_contains2();
    var _curry2 = require_curry2();
    var flip = require_flip();
    var reject2 = require_reject();
    var without = /* @__PURE__ */ _curry2(function(xs, list) {
      return reject2(flip(_contains)(xs), list);
    });
    module2.exports = without;
  }
});

// ../node_modules/ramda/src/xprod.js
var require_xprod = __commonJS({
  "../node_modules/ramda/src/xprod.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var xprod = /* @__PURE__ */ _curry2(function xprod2(a, b) {
      var idx = 0;
      var ilen = a.length;
      var j;
      var jlen = b.length;
      var result = [];
      while (idx < ilen) {
        j = 0;
        while (j < jlen) {
          result[result.length] = [a[idx], b[j]];
          j += 1;
        }
        idx += 1;
      }
      return result;
    });
    module2.exports = xprod;
  }
});

// ../node_modules/ramda/src/zip.js
var require_zip2 = __commonJS({
  "../node_modules/ramda/src/zip.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var zip = /* @__PURE__ */ _curry2(function zip2(a, b) {
      var rv = [];
      var idx = 0;
      var len = Math.min(a.length, b.length);
      while (idx < len) {
        rv[idx] = [a[idx], b[idx]];
        idx += 1;
      }
      return rv;
    });
    module2.exports = zip;
  }
});

// ../node_modules/ramda/src/zipObj.js
var require_zipObj = __commonJS({
  "../node_modules/ramda/src/zipObj.js"(exports2, module2) {
    var _curry2 = require_curry2();
    var zipObj = /* @__PURE__ */ _curry2(function zipObj2(keys, values) {
      var idx = 0;
      var len = Math.min(keys.length, values.length);
      var out = {};
      while (idx < len) {
        out[keys[idx]] = values[idx];
        idx += 1;
      }
      return out;
    });
    module2.exports = zipObj;
  }
});

// ../node_modules/ramda/src/zipWith.js
var require_zipWith = __commonJS({
  "../node_modules/ramda/src/zipWith.js"(exports2, module2) {
    var _curry3 = require_curry3();
    var zipWith = /* @__PURE__ */ _curry3(function zipWith2(fn, a, b) {
      var rv = [];
      var idx = 0;
      var len = Math.min(a.length, b.length);
      while (idx < len) {
        rv[idx] = fn(a[idx], b[idx]);
        idx += 1;
      }
      return rv;
    });
    module2.exports = zipWith;
  }
});

// ../node_modules/ramda/src/index.js
var require_src10 = __commonJS({
  "../node_modules/ramda/src/index.js"(exports2, module2) {
    module2.exports = {};
    module2.exports.F = require_F();
    module2.exports.T = require_T();
    module2.exports.__ = require__();
    module2.exports.add = require_add();
    module2.exports.addIndex = require_addIndex();
    module2.exports.adjust = require_adjust();
    module2.exports.all = require_all();
    module2.exports.allPass = require_allPass();
    module2.exports.always = require_always();
    module2.exports.and = require_and();
    module2.exports.any = require_any();
    module2.exports.anyPass = require_anyPass();
    module2.exports.ap = require_ap();
    module2.exports.aperture = require_aperture2();
    module2.exports.append = require_append();
    module2.exports.apply = require_apply();
    module2.exports.applySpec = require_applySpec();
    module2.exports.applyTo = require_applyTo();
    module2.exports.ascend = require_ascend();
    module2.exports.assoc = require_assoc();
    module2.exports.assocPath = require_assocPath();
    module2.exports.binary = require_binary();
    module2.exports.bind = require_bind2();
    module2.exports.both = require_both();
    module2.exports.call = require_call();
    module2.exports.chain = require_chain();
    module2.exports.clamp = require_clamp();
    module2.exports.clone = require_clone3();
    module2.exports.comparator = require_comparator();
    module2.exports.complement = require_complement();
    module2.exports.compose = require_compose();
    module2.exports.composeK = require_composeK();
    module2.exports.composeP = require_composeP();
    module2.exports.concat = require_concat2();
    module2.exports.cond = require_cond();
    module2.exports.construct = require_construct();
    module2.exports.constructN = require_constructN();
    module2.exports.contains = require_contains3();
    module2.exports.converge = require_converge();
    module2.exports.countBy = require_countBy();
    module2.exports.curry = require_curry();
    module2.exports.curryN = require_curryN2();
    module2.exports.dec = require_dec();
    module2.exports.defaultTo = require_defaultTo();
    module2.exports.descend = require_descend();
    module2.exports.difference = require_difference();
    module2.exports.differenceWith = require_differenceWith();
    module2.exports.dissoc = require_dissoc();
    module2.exports.dissocPath = require_dissocPath();
    module2.exports.divide = require_divide();
    module2.exports.drop = require_drop();
    module2.exports.dropLast = require_dropLast2();
    module2.exports.dropLastWhile = require_dropLastWhile2();
    module2.exports.dropRepeats = require_dropRepeats();
    module2.exports.dropRepeatsWith = require_dropRepeatsWith();
    module2.exports.dropWhile = require_dropWhile();
    module2.exports.either = require_either();
    module2.exports.empty = require_empty2();
    module2.exports.endsWith = require_endsWith();
    module2.exports.eqBy = require_eqBy();
    module2.exports.eqProps = require_eqProps();
    module2.exports.equals = require_equals2();
    module2.exports.evolve = require_evolve();
    module2.exports.filter = require_filter2();
    module2.exports.find = require_find();
    module2.exports.findIndex = require_findIndex();
    module2.exports.findLast = require_findLast();
    module2.exports.findLastIndex = require_findLastIndex();
    module2.exports.flatten = require_flatten();
    module2.exports.flip = require_flip();
    module2.exports.forEach = require_forEach();
    module2.exports.forEachObjIndexed = require_forEachObjIndexed();
    module2.exports.fromPairs = require_fromPairs();
    module2.exports.groupBy = require_groupBy();
    module2.exports.groupWith = require_groupWith();
    module2.exports.gt = require_gt();
    module2.exports.gte = require_gte();
    module2.exports.has = require_has2();
    module2.exports.hasIn = require_hasIn();
    module2.exports.head = require_head();
    module2.exports.identical = require_identical();
    module2.exports.identity = require_identity3();
    module2.exports.ifElse = require_ifElse();
    module2.exports.inc = require_inc();
    module2.exports.indexBy = require_indexBy();
    module2.exports.indexOf = require_indexOf2();
    module2.exports.init = require_init();
    module2.exports.innerJoin = require_innerJoin();
    module2.exports.insert = require_insert();
    module2.exports.insertAll = require_insertAll();
    module2.exports.intersection = require_intersection();
    module2.exports.intersperse = require_intersperse();
    module2.exports.into = require_into();
    module2.exports.invert = require_invert();
    module2.exports.invertObj = require_invertObj();
    module2.exports.invoker = require_invoker();
    module2.exports.is = require_is8();
    module2.exports.isEmpty = require_isEmpty();
    module2.exports.isNil = require_isNil();
    module2.exports.join = require_join();
    module2.exports.juxt = require_juxt();
    module2.exports.keys = require_keys3();
    module2.exports.keysIn = require_keysIn();
    module2.exports.last = require_last();
    module2.exports.lastIndexOf = require_lastIndexOf();
    module2.exports.length = require_length();
    module2.exports.lens = require_lens();
    module2.exports.lensIndex = require_lensIndex();
    module2.exports.lensPath = require_lensPath();
    module2.exports.lensProp = require_lensProp();
    module2.exports.lift = require_lift();
    module2.exports.liftN = require_liftN();
    module2.exports.lt = require_lt();
    module2.exports.lte = require_lte();
    module2.exports.map = require_map3();
    module2.exports.mapAccum = require_mapAccum();
    module2.exports.mapAccumRight = require_mapAccumRight();
    module2.exports.mapObjIndexed = require_mapObjIndexed();
    module2.exports.match = require_match();
    module2.exports.mathMod = require_mathMod();
    module2.exports.max = require_max();
    module2.exports.maxBy = require_maxBy();
    module2.exports.mean = require_mean();
    module2.exports.median = require_median();
    module2.exports.memoize = require_memoize();
    module2.exports.memoizeWith = require_memoizeWith();
    module2.exports.merge = require_merge3();
    module2.exports.mergeAll = require_mergeAll();
    module2.exports.mergeDeepLeft = require_mergeDeepLeft();
    module2.exports.mergeDeepRight = require_mergeDeepRight();
    module2.exports.mergeDeepWith = require_mergeDeepWith();
    module2.exports.mergeDeepWithKey = require_mergeDeepWithKey();
    module2.exports.mergeWith = require_mergeWith();
    module2.exports.mergeWithKey = require_mergeWithKey();
    module2.exports.min = require_min();
    module2.exports.minBy = require_minBy();
    module2.exports.modulo = require_modulo();
    module2.exports.multiply = require_multiply();
    module2.exports.nAry = require_nAry();
    module2.exports.negate = require_negate();
    module2.exports.none = require_none();
    module2.exports.not = require_not();
    module2.exports.nth = require_nth();
    module2.exports.nthArg = require_nthArg();
    module2.exports.o = require_o();
    module2.exports.objOf = require_objOf();
    module2.exports.of = require_of2();
    module2.exports.omit = require_omit();
    module2.exports.once = require_once2();
    module2.exports.or = require_or();
    module2.exports.over = require_over();
    module2.exports.pair = require_pair();
    module2.exports.partial = require_partial2();
    module2.exports.partialRight = require_partialRight();
    module2.exports.partition = require_partition();
    module2.exports.path = require_path2();
    module2.exports.pathEq = require_pathEq();
    module2.exports.pathOr = require_pathOr();
    module2.exports.pathSatisfies = require_pathSatisfies();
    module2.exports.pick = require_pick();
    module2.exports.pickAll = require_pickAll();
    module2.exports.pickBy = require_pickBy();
    module2.exports.pipe = require_pipe2();
    module2.exports.pipeK = require_pipeK();
    module2.exports.pipeP = require_pipeP2();
    module2.exports.pluck = require_pluck();
    module2.exports.prepend = require_prepend();
    module2.exports.product = require_product();
    module2.exports.project = require_project();
    module2.exports.prop = require_prop();
    module2.exports.propEq = require_propEq();
    module2.exports.propIs = require_propIs();
    module2.exports.propOr = require_propOr();
    module2.exports.propSatisfies = require_propSatisfies();
    module2.exports.props = require_props();
    module2.exports.range = require_range();
    module2.exports.reduce = require_reduce2();
    module2.exports.reduceBy = require_reduceBy();
    module2.exports.reduceRight = require_reduceRight();
    module2.exports.reduceWhile = require_reduceWhile();
    module2.exports.reduced = require_reduced2();
    module2.exports.reject = require_reject();
    module2.exports.remove = require_remove2();
    module2.exports.repeat = require_repeat();
    module2.exports.replace = require_replace();
    module2.exports.reverse = require_reverse();
    module2.exports.scan = require_scan2();
    module2.exports.sequence = require_sequence();
    module2.exports.set = require_set();
    module2.exports.slice = require_slice();
    module2.exports.sort = require_sort();
    module2.exports.sortBy = require_sortBy();
    module2.exports.sortWith = require_sortWith();
    module2.exports.split = require_split();
    module2.exports.splitAt = require_splitAt();
    module2.exports.splitEvery = require_splitEvery();
    module2.exports.splitWhen = require_splitWhen();
    module2.exports.startsWith = require_startsWith();
    module2.exports.subtract = require_subtract();
    module2.exports.sum = require_sum();
    module2.exports.symmetricDifference = require_symmetricDifference();
    module2.exports.symmetricDifferenceWith = require_symmetricDifferenceWith();
    module2.exports.tail = require_tail();
    module2.exports.take = require_take();
    module2.exports.takeLast = require_takeLast();
    module2.exports.takeLastWhile = require_takeLastWhile();
    module2.exports.takeWhile = require_takeWhile();
    module2.exports.tap = require_tap();
    module2.exports.test = require_test();
    module2.exports.times = require_times();
    module2.exports.toLower = require_toLower();
    module2.exports.toPairs = require_toPairs();
    module2.exports.toPairsIn = require_toPairsIn();
    module2.exports.toString = require_toString2();
    module2.exports.toUpper = require_toUpper();
    module2.exports.transduce = require_transduce();
    module2.exports.transpose = require_transpose();
    module2.exports.traverse = require_traverse2();
    module2.exports.trim = require_trim();
    module2.exports.tryCatch = require_tryCatch();
    module2.exports.type = require_type();
    module2.exports.unapply = require_unapply();
    module2.exports.unary = require_unary();
    module2.exports.uncurryN = require_uncurryN();
    module2.exports.unfold = require_unfold();
    module2.exports.union = require_union();
    module2.exports.unionWith = require_unionWith();
    module2.exports.uniq = require_uniq();
    module2.exports.uniqBy = require_uniqBy();
    module2.exports.uniqWith = require_uniqWith();
    module2.exports.unless = require_unless();
    module2.exports.unnest = require_unnest();
    module2.exports.until = require_until();
    module2.exports.update = require_update();
    module2.exports.useWith = require_useWith();
    module2.exports.values = require_values2();
    module2.exports.valuesIn = require_valuesIn();
    module2.exports.view = require_view();
    module2.exports.when = require_when();
    module2.exports.where = require_where();
    module2.exports.whereEq = require_whereEq();
    module2.exports.without = require_without();
    module2.exports.xprod = require_xprod();
    module2.exports.zip = require_zip2();
    module2.exports.zipObj = require_zipObj();
    module2.exports.zipWith = require_zipWith();
  }
});

// src/models/Service.js
var require_Service = __commonJS({
  "src/models/Service.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var Service = class {
      constructor(data = {}) {
        this.org = data.org;
        this.serviceName = data.serviceName || "my-app";
      }
      async copy(data = {}) {
        const options = {
          accessKey: this.org.accessKey,
          method: "POST",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}/copy`,
          body: data
        };
        return await request(options);
      }
      async create(data = {}) {
        const options = {
          accessKey: this.org.accessKey,
          method: "POST",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}`,
          body: data
        };
        return await request(options);
      }
      async get() {
        const options = {
          accessKey: this.org.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}`
        };
        return await request(options);
      }
      async put(data = {}) {
        const options = {
          accessKey: this.org.accessKey,
          method: "PATCH",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}`,
          body: data
        };
        return await request(options);
      }
      async delete() {
        const options = {
          accessKey: this.org.accessKey,
          method: "DELETE",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}`
        };
        return await request(options);
      }
      async listInstances() {
        const options = {
          accessKey: this.org.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}/instances`
        };
        return await request(options);
      }
      async getParams() {
        const options = {
          accessKey: this.org.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}/params`
        };
        const { params } = await request(options);
        return params;
      }
      async putParams(newParams) {
        const options = {
          accessKey: this.org.accessKey,
          method: "PATCH",
          endpoint: `/orgs/${this.org.orgName}/services/${this.serviceName}/params`,
          body: { params: newParams }
        };
        const { params } = await request(options);
        return params;
      }
      getDashboardUrl() {
        let dashboardUrl = `https://cloud.serverless.com/orgs/${this.org.orgName}/apps/${this.serviceName}`;
        if (process.env.SERVERLESS_PLATFORM_STAGE !== "prod") {
          dashboardUrl = `https://cloud.serverless-dev.com/orgs/${this.org.orgName}/apps/${this.serviceName}`;
        }
        return dashboardUrl;
      }
    };
    module2.exports = Service;
  }
});

// src/models/Org.js
var require_Org = __commonJS({
  "src/models/Org.js"(exports2, module2) {
    "use strict";
    var R = require_src10();
    var request = require_request();
    var Service = require_Service();
    var Org = class {
      constructor(data = {}) {
        this.user = data.user;
        this.accessKey = data.accessKey;
        this.orgName = data.orgName;
      }
      update(data = {}) {
        this.orgName = data.orgName || this.orgName;
        this.accessKey = data.accessKey || this.accessKey;
        this.user = data.user || this.user;
      }
      async getAccessKey() {
        this.accessKey = process.env.SERVERLESS_ACCESS_KEY || await this.user.getToken();
        return this.accessKey;
      }
      async isAuthorized() {
        this.orgName = this.orgName || await this.user.getDefaultOrgName();
        this.accessKey = await this.getAccessKey();
        try {
          await this._activate();
        } catch (e) {
          if (e.message.includes("Your credentials do not have access to the Organization")) {
            return false;
          }
        }
        return true;
      }
      async listServices() {
        const options = {
          accessKey: this.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.orgName}/services`
        };
        return await request(options);
      }
      async listServicesWithInstances() {
        const services = await this.listServices();
        const servicesWithInstances = await Promise.all(services.map(async (s) => {
          const service = new Service({ org: this, serviceName: s.serviceName });
          const serviceInstances = await service.listInstances();
          if (!serviceInstances || serviceInstances.length === 0) {
            return null;
          }
          return s;
        }));
        return R.reject(R.isNil, servicesWithInstances);
      }
      async getParams() {
        const options = {
          accessKey: this.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.orgName}/params`
        };
        const { params } = await request(options);
        return params;
      }
      async putParams(newParams) {
        const options = {
          accessKey: this.accessKey,
          method: "PATCH",
          endpoint: `/orgs/${this.orgName}/params`,
          body: { params: newParams }
        };
        const { params } = await request(options);
        return params;
      }
      async _activate() {
        const options = {
          accessKey: this.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.orgName}/is-activated`
        };
        return await request(options);
      }
    };
    module2.exports = Org;
  }
});

// src/models/Instance.js
var require_Instance = __commonJS({
  "src/models/Instance.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var Instance = class {
      constructor(data = {}) {
        this.org = data.org;
        this.service = data.service;
        this.instanceName = data.instanceName || "demo";
        this.instanceType = data.instanceType;
        this.url = data.url;
      }
      async get() {
        const options = {
          accessKey: this.org.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}`
        };
        const res = await request(options);
        this.url = res.instanceUrl;
        this.instanceType = res.instanceType;
        return res;
      }
      async create() {
        const options = {
          accessKey: this.org.accessKey,
          method: "POST",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}`
        };
        const res = await request(options);
        this.url = res.instanceUrl;
        this.instanceType = res.instanceType;
        return res;
      }
      async delete() {
        const options = {
          accessKey: this.org.accessKey,
          method: "DELETE",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}`
        };
        return await request(options);
      }
      async test() {
        const options = {
          accessKey: this.org.accessKey,
          method: "POST",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}/test`
        };
        return await request(options);
      }
      async getLogs() {
        const messages = [];
        let nextToken;
        do {
          const query = nextToken ? `?nextToken=${nextToken}` : "";
          const options = {
            accessKey: this.org.accessKey,
            method: "GET",
            endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}/logs${query}`
          };
          const response = await request(options);
          messages.push(...response.messages);
          nextToken = response.nextToken;
        } while (nextToken);
        return messages;
      }
      async getParams() {
        const options = {
          accessKey: this.org.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}/params`
        };
        const { params } = await request(options);
        return params;
      }
      async putParams(newParams) {
        const options = {
          accessKey: this.org.accessKey,
          method: "PATCH",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instanceName}/params`,
          body: { params: newParams }
        };
        const { params } = await request(options);
        return params;
      }
    };
    module2.exports = Instance;
  }
});

// ../archive/src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => Archive
});
async function* serialize(entries, contents) {
  const headerSizeBuffer = Buffer.alloc(sizeOffset);
  const headerBuffer = Buffer.from(JSON.stringify({ entries }));
  const size = headerBuffer.length;
  headerSizeBuffer.writeInt32BE(size, 0);
  let chunks = [headerSizeBuffer, headerBuffer];
  let buffered = headerSizeBuffer.length + headerBuffer.length;
  const expected = new Set(Object.values(entries).map((stat) => stat.hash));
  for await (const batch of contents) {
    for (const { hash, data } of batch) {
      if (expected.has(hash)) {
        expected.delete(hash);
        const recordBuffer = Buffer.alloc(recordOffset);
        recordBuffer.writeInt32BE(data.length, 0);
        const hashBuffer = Buffer.from(hash, "hex");
        if (hashBuffer.length !== hashOffset) {
          throw new Error("Bad hash");
        }
        hashBuffer.copy(recordBuffer, sizeOffset);
        chunks.push(recordBuffer);
        chunks.push(data);
        buffered += recordBuffer.length + data.length;
        if (buffered > 256 * 1024) {
          yield Buffer.concat(chunks);
          chunks = [];
          buffered = 0;
        }
      }
    }
  }
  if (expected.size > 0) {
    throw new Error(`Missing ${expected.size} records`);
  }
  if (chunks.length) {
    yield Buffer.concat(chunks);
  }
}
var import_stream, State, sizeOffset, hashOffset, recordOffset, Archive;
var init_src = __esm({
  "../archive/src/index.ts"() {
    import_stream = __toModule(require("stream"));
    (function(State2) {
      State2[State2["Start"] = 0] = "Start";
      State2[State2["Header"] = 1] = "Header";
      State2[State2["Data"] = 2] = "Data";
    })(State || (State = {}));
    sizeOffset = 4;
    hashOffset = 16;
    recordOffset = sizeOffset + hashOffset;
    Archive = class {
      constructor() {
        this.entries = {};
        this.contents = {};
      }
      static async from(records) {
        const archive = new Archive();
        for await (const batch of records) {
          for (const { name, hash, mode, data } of batch) {
            archive.entries[name] = { hash, mode };
            archive.contents[hash] = data;
          }
        }
        return archive;
      }
      static parse(incoming, batchSize = 1e3) {
        const expected = {};
        const batch = [];
        const chunks = [];
        let state = 0;
        let buffered = 0;
        let headerSize = 0;
        let entries = {};
        let currentRecordSize = void 0;
        let currentRecordHash = "";
        function take(bytes) {
          const result = Buffer.alloc(bytes);
          for (let remaining = bytes; remaining > 0; ) {
            const chunk = chunks.shift();
            if (chunk) {
              if (remaining >= chunk.length) {
                chunk.copy(result, bytes - remaining);
                remaining -= chunk.length;
              } else {
                chunk.copy(result, bytes - remaining, 0, remaining);
                chunks.unshift(chunk.slice(remaining));
                remaining = 0;
              }
            } else {
              throw new Error("Not enough data");
            }
          }
          buffered -= bytes;
          return result;
        }
        const transform = new import_stream.Transform({
          objectMode: true,
          transform(chunk, _enc, callback) {
            chunks.push(chunk);
            buffered += chunk.length;
            try {
              if (state === 0 && buffered >= sizeOffset) {
                headerSize = take(sizeOffset).readInt32BE(0);
                state = 1;
              }
              if (state === 1 && buffered >= headerSize) {
                const headerBuffer = take(headerSize);
                const headerString = headerBuffer.toString("utf8");
                const header = JSON.parse(headerString);
                entries = header.entries;
                for (const [name, { hash }] of Object.entries(entries)) {
                  expected[hash] = expected[hash] || [];
                  expected[hash].push(name);
                }
                state = 2;
              }
              if (state === 2) {
                let hasMore = buffered >= (currentRecordSize === void 0 ? recordOffset : currentRecordSize);
                while (hasMore) {
                  if (currentRecordSize === void 0) {
                    const b = take(recordOffset);
                    currentRecordSize = b.readInt32BE(0);
                    currentRecordHash = b.toString("hex", sizeOffset);
                    hasMore = buffered >= currentRecordSize;
                  } else {
                    const data = take(currentRecordSize);
                    const names = expected[currentRecordHash];
                    if (names) {
                      for (const name of names) {
                        const { hash, mode } = entries[name];
                        batch.push({ name, hash, mode, data });
                      }
                    } else {
                      throw new Error("Unexpected content with no entry pointing to it");
                    }
                    currentRecordSize = void 0;
                    currentRecordHash = "";
                    hasMore = buffered >= recordOffset;
                  }
                }
              }
              while (batch.length >= batchSize) {
                this.push(batch.splice(0, batchSize));
              }
              callback();
            } catch (err) {
              callback(err);
            }
          },
          flush(callback) {
            if (batch.length) {
              callback(null, batch);
            } else {
              callback();
            }
          }
        });
        incoming.on("error", (err) => {
          if (err.code === "NoSuchKey") {
            transform.destroy();
          } else {
            transform.destroy(err);
          }
        });
        return incoming.pipe(transform);
      }
      static concat(entries, streams) {
        const result = new Archive();
        result.entries = entries;
        const merged = import_stream.Readable.from(serialize(entries, async function* () {
          for (const stream2 of streams) {
            for await (const batch of stream2) {
              for (const { hash, data } of batch) {
                result.contents[hash] = data;
              }
              yield batch;
            }
          }
        }()));
        Object.assign(merged, { result });
        return merged;
      }
      getEntries() {
        return this.entries;
      }
      getContents() {
        return this.contents;
      }
      async *records(batchSize = 1e3) {
        let batch = [];
        for (const name of Object.keys(this.entries)) {
          const { hash, mode } = this.entries[name];
          const data = this.contents[hash];
          batch.push({ name, hash, mode, data });
          if (batch.length === batchSize) {
            yield batch;
            batch = [];
          }
        }
        if (batch.length) {
          yield batch;
        }
      }
      toStream() {
        const records = serialize(this.entries, this.records());
        return import_stream.Readable.from(records);
      }
      async toBuffer() {
        const chunks = [];
        const readable = import_stream.Readable.from(serialize(this.entries, this.records()));
        await new Promise((resolve2, reject2) => {
          readable.on("readable", () => {
            let data;
            while (data = readable.read()) {
              chunks.push(data);
            }
          });
          readable.on("error", (err) => {
            reject2(err);
          });
          readable.on("end", () => {
            resolve2(null);
          });
        });
        readable.removeAllListeners();
        return Buffer.concat(chunks);
      }
    };
  }
});

// src/models/Code.js
var require_Code = __commonJS({
  "src/models/Code.js"(exports2, module2) {
    "use strict";
    var AdmZip = require_adm_zip();
    var { default: Archive2 } = (init_src(), src_exports);
    var request = require_request();
    var ONE_MINUTE_MS = 6e4;
    var Code = class {
      constructor(data) {
        this.fs = data.fs;
        this.org = data.org;
        this.service = data.service;
        this.instance = data.instance;
        this.src = this.fs.serviceRoot;
        this.changesUploadUrl = null;
        this.map = {};
        this.previousMap = {};
        this.stat = {};
      }
      timerMs() {
        const start = process.hrtime.bigint();
        return function() {
          const end = process.hrtime.bigint();
          return parseFloat((Number(end - start) / 1e6).toFixed(2));
        };
      }
      async getUrlsAndMap() {
        const getUrlsTimers = this.timerMs();
        const timeToExpire = this.deployTokenExpiration - Date.now();
        if (timeToExpire > ONE_MINUTE_MS) {
          return getUrlsTimers();
        }
        const options = {
          accessKey: await this.org.getAccessKey(),
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/code`,
          params: {
            instanceType: this.instance.instanceType
          }
        };
        const { deployToken, deployTokenExpiration, deployTokenIsJwt, deployUrls, useArchive, map } = await request(options);
        const { instanceUrl, previousMapDownloadUrl, changesUploadUrl } = deployUrls;
        this.useArchive = useArchive;
        this.deployToken = deployToken;
        this.deployTokenExpiration = deployTokenExpiration;
        this.deployTokenIsJwt = deployTokenIsJwt;
        this.instance.url = instanceUrl;
        this.changesUploadUrl = changesUploadUrl;
        if (useArchive && map) {
          this.previousMap = map;
        } else {
          const previousMap = await request({
            method: "GET",
            url: previousMapDownloadUrl
          }).catch(() => {
          });
          if (previousMap) {
            this.previousMap = previousMap;
          }
        }
        return getUrlsTimers();
      }
      async downloadSource() {
        const options = {
          accessKey: await this.org.getAccessKey(),
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/source`,
          responseType: "arraybuffer"
        };
        const buffer = await request(options);
        const sourceZip = new AdmZip(buffer);
        sourceZip.extractAllTo(this.src);
      }
      async processChanges() {
        const options = {
          accessKey: await this.org.getAccessKey(),
          method: "POST",
          body: {
            deployToken: this.deployToken,
            deployTokenIsJwt: this.deployTokenIsJwt,
            map: this.map,
            useArchive: this.useArchive
          },
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/code`
        };
        await request(options);
      }
      shouldSyncAll(filePathsFromWatch) {
        let syncAll = true;
        if (filePathsFromWatch) {
          syncAll = false;
          filePathsFromWatch.forEach((filePath) => {
            if (filePath.includes("package-lock.json") || filePath.includes("package.json") || filePath.includes("node_modules")) {
              syncAll = true;
            }
          });
        }
        return syncAll;
      }
      async sync(filePathsFromWatch) {
        const syncTimer = this.timerMs();
        const filePaths = this.shouldSyncAll(filePathsFromWatch) ? this.fs.glob(this.src) : Array.from(filePathsFromWatch);
        const getUrlsTimer = this.timerMs();
        await this.getUrlsAndMap();
        const getUrlsTimeMs = getUrlsTimer();
        const archiveTimer = this.timerMs();
        const buffer = await this.archiveChanges(filePaths);
        const archiveTimeMs = archiveTimer();
        const uploadTimer = this.timerMs();
        await request({
          method: "PUT",
          url: this.changesUploadUrl,
          body: buffer,
          headers: this.useArchive ? {
            "content-type": "application/octet-stream"
          } : {}
        });
        const uploadTimeMs = uploadTimer();
        const processChangesTimer = this.timerMs();
        await this.processChanges();
        const processChangesTimeMs = processChangesTimer();
        return {
          archiveTimeMs,
          uploadTimeMs,
          processChangesTimeMs,
          getUrlsTimeMs,
          syncTimeMs: syncTimer()
        };
      }
      async archiveChanges(filePaths) {
        const { map, previousMap, stat } = this;
        const hashedFiles = this.fs.hash(this.src, filePaths, this.useArchive);
        const files = async function* () {
          for await (const batch of hashedFiles) {
            const changed = [];
            for (const result of batch) {
              const { relativePath: name, data, hash, mode, size } = result;
              if (data) {
                const existing = map[name];
                if (!existing || existing.hash !== hash) {
                  changed.push({ name, hash, mode, data });
                }
                map[name] = { hash, mode };
                stat[name] = { size };
              } else {
                delete map[name];
                delete stat[name];
              }
            }
            yield changed;
          }
        }();
        if (this.useArchive) {
          const archive = await Archive2.from(files);
          return await archive.toBuffer();
        } else {
          const zip = new AdmZip();
          for await (const batch of files) {
            for (const { name, mode, data } of batch) {
              zip.addFile(name, data, { mode });
            }
          }
          const fileSizeBytes = Object.values(this.stat).reduce((memo, { size }) => memo + size, 0);
          if (fileSizeBytes > 134217728) {
            throw new Error("Your code size must not exceed 128MB.");
          }
          const deletedFiles = Object.keys(previousMap).filter((name) => {
            return map[name] === void 0;
          });
          this.previousMap = map;
          this.map = JSON.parse(JSON.stringify(map));
          const mapContent = JSON.stringify(map);
          zip.addFile("source.map", Buffer.alloc(mapContent.length, mapContent));
          const deletedFilesContent = JSON.stringify(deletedFiles);
          zip.addFile("deleted.files", Buffer.alloc(deletedFilesContent.length, deletedFilesContent));
          return zip.toBuffer();
        }
      }
    };
    module2.exports = Code;
  }
});

// src/models/Data.js
var require_Data = __commonJS({
  "src/models/Data.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var Data = class {
      constructor(data = {}) {
        this.fs = data.fs;
        this.org = data.org;
        this.service = data.service;
        this.instance = data.instance;
      }
      async export() {
        const { dataFileName } = this.fs;
        const options = {
          accessKey: this.org.accessKey,
          method: "GET",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/data`,
          params: {
            dataFileName
          }
        };
        const data = await request(options);
        await this.fs.writeDataFile(data);
      }
      async import(overwrite) {
        const { dataFileName } = this.fs;
        const items = await this.fs.readDataFile();
        const options = {
          accessKey: this.org.accessKey,
          method: "PUT",
          endpoint: `/orgs/${this.org.orgName}/services/${this.service.serviceName}/instances/${this.instance.instanceName}/data`,
          body: {
            items,
            overwrite
          },
          params: {
            dataFileName
          }
        };
        await request(options);
      }
    };
    module2.exports = Data;
  }
});

// src/models/Analytics.js
var require_Analytics = __commonJS({
  "src/models/Analytics.js"(exports2, module2) {
    "use strict";
    var request = require_request();
    var Analytics = class {
      constructor({ org }) {
        this.org = org;
      }
      async publish(eventName, eventData) {
        eventData.shell = true;
        try {
          await request({
            accessKey: this.org.accessKey,
            method: "POST",
            body: {
              eventName,
              eventData
            },
            endpoint: `/orgs/${this.org.orgName}/analytics`
          });
        } catch (e) {
          if (process.env.SLS_DEBUG) {
            console.error(e);
          }
        }
      }
    };
    module2.exports = Analytics;
  }
});

// src/models/Platform.js
var require_Platform = __commonJS({
  "src/models/Platform.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = require("events");
    var { ServerlessSDK } = require_src9();
    var Platform = class extends EventEmitter {
      constructor({ accessKey } = {}) {
        super();
        this.sdk = new ServerlessSDK({ accessKey });
      }
      waitForEvent(type, timeout = 1e4) {
        return Promise.race([
          new Promise((resolve2, reject2) => {
            if (type) {
              this.on("event", (event) => {
                if (event.event === type) {
                  resolve2(event);
                }
              });
            } else {
              this.once("event", resolve2);
            }
            this.on("error", reject2);
          }),
          new Promise((_resolve, reject2) => {
            setTimeout(() => {
              reject2(new Error("waitForEvent timed out"));
            }, timeout);
          })
        ]);
      }
      async connect({ orgName, appName, instanceName }) {
        try {
          await this.sdk.connect({
            orgName,
            filter: { appName, instanceName, events: [] },
            onEvent: (event) => this.emit("event", event),
            onError: () => {
            }
          });
        } catch (error) {
          if (error.message.includes("401")) {
            error.message = `Your credentials do not have access to the Organization with the name of: ${orgName}.  Try logging into a different account.`;
          }
          throw Error(error);
        }
      }
      disconnect() {
        this.removeAllListeners();
        this.sdk.disconnect();
      }
    };
    module2.exports = Platform;
  }
});

// ../node_modules/is-wsl/node_modules/is-docker/index.js
var require_is_docker = __commonJS({
  "../node_modules/is-wsl/node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs.statSync("/.dockerenv");
        return true;
      } catch (_2) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_2) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// ../node_modules/is-wsl/index.js
var require_is_wsl = __commonJS({
  "../node_modules/is-wsl/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var isDocker = require_is_docker();
    var isWsl = () => {
      if (process.platform !== "linux") {
        return false;
      }
      if (os.release().toLowerCase().includes("microsoft")) {
        if (isDocker()) {
          return false;
        }
        return true;
      }
      try {
        return fs.readFileSync("/proc/version", "utf8").toLowerCase().includes("microsoft") ? !isDocker() : false;
      } catch (_2) {
        return false;
      }
    };
    if (process.env.__IS_WSL_TEST__) {
      module2.exports = isWsl;
    } else {
      module2.exports = isWsl();
    }
  }
});

// ../node_modules/open/node_modules/is-docker/index.js
var require_is_docker2 = __commonJS({
  "../node_modules/open/node_modules/is-docker/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var isDocker;
    function hasDockerEnv() {
      try {
        fs.statSync("/.dockerenv");
        return true;
      } catch (_2) {
        return false;
      }
    }
    function hasDockerCGroup() {
      try {
        return fs.readFileSync("/proc/self/cgroup", "utf8").includes("docker");
      } catch (_2) {
        return false;
      }
    }
    module2.exports = () => {
      if (isDocker === void 0) {
        isDocker = hasDockerEnv() || hasDockerCGroup();
      }
      return isDocker;
    };
  }
});

// ../node_modules/define-lazy-prop/index.js
var require_define_lazy_prop = __commonJS({
  "../node_modules/define-lazy-prop/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (object, propertyName, fn) => {
      const define2 = (value) => Object.defineProperty(object, propertyName, { value, enumerable: true, writable: true });
      Object.defineProperty(object, propertyName, {
        configurable: true,
        enumerable: true,
        get() {
          const result = fn();
          define2(result);
          return result;
        },
        set(value) {
          define2(value);
        }
      });
      return object;
    };
  }
});

// ../node_modules/open/index.js
var require_open = __commonJS({
  "../node_modules/open/index.js"(exports2, module2) {
    var path = require("path");
    var childProcess = require("child_process");
    var { promises: fs, constants: fsConstants } = require("fs");
    var isWsl = require_is_wsl();
    var isDocker = require_is_docker2();
    var defineLazyProperty = require_define_lazy_prop();
    var localXdgOpenPath = path.join(__dirname, "xdg-open");
    var { platform, arch } = process;
    var getWslDrivesMountPoint = (() => {
      const defaultMountPoint = "/mnt/";
      let mountPoint;
      return async function() {
        if (mountPoint) {
          return mountPoint;
        }
        const configFilePath = "/etc/wsl.conf";
        let isConfigFileExists = false;
        try {
          await fs.access(configFilePath, fsConstants.F_OK);
          isConfigFileExists = true;
        } catch {
        }
        if (!isConfigFileExists) {
          return defaultMountPoint;
        }
        const configContent = await fs.readFile(configFilePath, { encoding: "utf8" });
        const configMountPoint = /(?<!#.*)root\s*=\s*(?<mountPoint>.*)/g.exec(configContent);
        if (!configMountPoint) {
          return defaultMountPoint;
        }
        mountPoint = configMountPoint.groups.mountPoint.trim();
        mountPoint = mountPoint.endsWith("/") ? mountPoint : `${mountPoint}/`;
        return mountPoint;
      };
    })();
    var pTryEach = async (array, mapper) => {
      let latestError;
      for (const item of array) {
        try {
          return await mapper(item);
        } catch (error) {
          latestError = error;
        }
      }
      throw latestError;
    };
    var baseOpen = async (options) => {
      options = __spreadValues({
        wait: false,
        background: false,
        newInstance: false,
        allowNonzeroExitCode: false
      }, options);
      if (Array.isArray(options.app)) {
        return pTryEach(options.app, (singleApp) => baseOpen(__spreadProps(__spreadValues({}, options), {
          app: singleApp
        })));
      }
      let { name: app, arguments: appArguments = [] } = options.app || {};
      appArguments = [...appArguments];
      if (Array.isArray(app)) {
        return pTryEach(app, (appName) => baseOpen(__spreadProps(__spreadValues({}, options), {
          app: {
            name: appName,
            arguments: appArguments
          }
        })));
      }
      let command;
      const cliArguments = [];
      const childProcessOptions = {};
      if (platform === "darwin") {
        command = "open";
        if (options.wait) {
          cliArguments.push("--wait-apps");
        }
        if (options.background) {
          cliArguments.push("--background");
        }
        if (options.newInstance) {
          cliArguments.push("--new");
        }
        if (app) {
          cliArguments.push("-a", app);
        }
      } else if (platform === "win32" || isWsl && !isDocker()) {
        const mountPoint = await getWslDrivesMountPoint();
        command = isWsl ? `${mountPoint}c/Windows/System32/WindowsPowerShell/v1.0/powershell.exe` : `${process.env.SYSTEMROOT}\\System32\\WindowsPowerShell\\v1.0\\powershell`;
        cliArguments.push("-NoProfile", "-NonInteractive", "\u2013ExecutionPolicy", "Bypass", "-EncodedCommand");
        if (!isWsl) {
          childProcessOptions.windowsVerbatimArguments = true;
        }
        const encodedArguments = ["Start"];
        if (options.wait) {
          encodedArguments.push("-Wait");
        }
        if (app) {
          encodedArguments.push(`"\`"${app}\`""`, "-ArgumentList");
          if (options.target) {
            appArguments.unshift(options.target);
          }
        } else if (options.target) {
          encodedArguments.push(`"${options.target}"`);
        }
        if (appArguments.length > 0) {
          appArguments = appArguments.map((arg) => `"\`"${arg}\`""`);
          encodedArguments.push(appArguments.join(","));
        }
        options.target = Buffer.from(encodedArguments.join(" "), "utf16le").toString("base64");
      } else {
        if (app) {
          command = app;
        } else {
          const isBundled = !__dirname || __dirname === "/";
          let exeLocalXdgOpen = false;
          try {
            await fs.access(localXdgOpenPath, fsConstants.X_OK);
            exeLocalXdgOpen = true;
          } catch {
          }
          const useSystemXdgOpen = process.versions.electron || platform === "android" || isBundled || !exeLocalXdgOpen;
          command = useSystemXdgOpen ? "xdg-open" : localXdgOpenPath;
        }
        if (appArguments.length > 0) {
          cliArguments.push(...appArguments);
        }
        if (!options.wait) {
          childProcessOptions.stdio = "ignore";
          childProcessOptions.detached = true;
        }
      }
      if (options.target) {
        cliArguments.push(options.target);
      }
      if (platform === "darwin" && appArguments.length > 0) {
        cliArguments.push("--args", ...appArguments);
      }
      const subprocess = childProcess.spawn(command, cliArguments, childProcessOptions);
      if (options.wait) {
        return new Promise((resolve2, reject2) => {
          subprocess.once("error", reject2);
          subprocess.once("close", (exitCode) => {
            if (options.allowNonzeroExitCode && exitCode > 0) {
              reject2(new Error(`Exited with code ${exitCode}`));
              return;
            }
            resolve2(subprocess);
          });
        });
      }
      subprocess.unref();
      return subprocess;
    };
    var open = (target, options) => {
      if (typeof target !== "string") {
        throw new TypeError("Expected a `target`");
      }
      return baseOpen(__spreadProps(__spreadValues({}, options), {
        target
      }));
    };
    var openApp = (name, options) => {
      if (typeof name !== "string") {
        throw new TypeError("Expected a `name`");
      }
      const { arguments: appArguments = [] } = options || {};
      if (appArguments !== void 0 && appArguments !== null && !Array.isArray(appArguments)) {
        throw new TypeError("Expected `appArguments` as Array type");
      }
      return baseOpen(__spreadProps(__spreadValues({}, options), {
        app: {
          name,
          arguments: appArguments
        }
      }));
    };
    function detectArchBinary(binary) {
      if (typeof binary === "string" || Array.isArray(binary)) {
        return binary;
      }
      const { [arch]: archBinary } = binary;
      if (!archBinary) {
        throw new Error(`${arch} is not supported`);
      }
      return archBinary;
    }
    function detectPlatformBinary({ [platform]: platformBinary }, { wsl }) {
      if (wsl && isWsl) {
        return detectArchBinary(wsl);
      }
      if (!platformBinary) {
        throw new Error(`${platform} is not supported`);
      }
      return detectArchBinary(platformBinary);
    }
    var apps = {};
    defineLazyProperty(apps, "chrome", () => detectPlatformBinary({
      darwin: "google chrome",
      win32: "chrome",
      linux: ["google-chrome", "google-chrome-stable", "chromium"]
    }, {
      wsl: {
        ia32: "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe",
        x64: ["/mnt/c/Program Files/Google/Chrome/Application/chrome.exe", "/mnt/c/Program Files (x86)/Google/Chrome/Application/chrome.exe"]
      }
    }));
    defineLazyProperty(apps, "firefox", () => detectPlatformBinary({
      darwin: "firefox",
      win32: "C:\\Program Files\\Mozilla Firefox\\firefox.exe",
      linux: "firefox"
    }, {
      wsl: "/mnt/c/Program Files/Mozilla Firefox/firefox.exe"
    }));
    defineLazyProperty(apps, "edge", () => detectPlatformBinary({
      darwin: "microsoft edge",
      win32: "msedge",
      linux: ["microsoft-edge", "microsoft-edge-dev"]
    }, {
      wsl: "/mnt/c/Program Files (x86)/Microsoft/Edge/Application/msedge.exe"
    }));
    open.apps = apps;
    open.openApp = openApp;
    module2.exports = open;
  }
});

// src/commands/login.js
var require_login = __commonJS({
  "src/commands/login.js"(exports2, module2) {
    "use strict";
    var open = require_open();
    var User = require_User();
    var Org = require_Org();
    var Analytics = require_Analytics();
    var trySendAnalytics = async () => {
      try {
        const user = new User();
        const org = new Org({ user });
        if (await org.isAuthorized()) {
          const analytics = new Analytics({ org });
          await analytics.publish("cloud.cli.login", {});
        }
      } catch (e) {
        if (process.env.SLS_DEBUG) {
          console.error(e);
        }
      }
    };
    module2.exports = async (cli) => {
      cli.viewSpinner("Awaiting login");
      const user = new User();
      cli.logInfo("Your browser should open automatically.");
      const loginUrl = await user.startLogin();
      cli.logInfo("If not, open the following login url:");
      cli.logUrl(loginUrl);
      open(loginUrl);
      await user.endLogin();
      await trySendAnalytics();
      cli.logSuccess("Successfully logged into Serverless Cloud.");
    };
  }
});

// src/commands/clone.js
var require_clone4 = __commonJS({
  "src/commands/clone.js"(exports2, module2) {
    "use strict";
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var Code = require_Code();
    var login = require_login();
    var clone = async (cli) => {
      cli.viewSpinner("Loading");
      let { orgName, serviceName, instanceName } = cli.names;
      let shouldCreateDir = cli.options.dir === false ? false : true;
      const loginToken = cli.options.login;
      const user = new User();
      if (loginToken) {
        orgName = await user.restoreOrgLogin(loginToken);
        cli.logSuccess("Successfully logged in.");
      }
      const fs = new FS();
      await fs.read();
      if (fs.serviceFile) {
        serviceName = serviceName || fs.serviceFile.serverless.app;
        orgName = orgName || fs.serviceFile.serverless.org;
        shouldCreateDir = false;
      }
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      let shouldOverwrite = cli.options.overwrite || cli.options.o;
      if (!shouldCreateDir && !await fs.isCwdEmpty() && !shouldOverwrite) {
        cli.logInfo(`This directory is not empty. Are you sure you want to overwrite it?`);
        shouldOverwrite = await cli.confirm();
        if (!shouldOverwrite) {
          await cli.quit();
        }
      }
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      if (!serviceName) {
        cli.viewSpinner("Loading");
        const servicesList = (await org.listServicesWithInstances()).map((service2) => service2.serviceName);
        if (servicesList.length > 1) {
          cli.logQuestion("Which app do you want to clone?");
          serviceName = await cli.select(servicesList);
        } else {
          serviceName = servicesList[0];
        }
      }
      const service = new Service({ org, serviceName });
      if (!instanceName) {
        cli.viewSpinner("Loading");
        const instancesList = (await service.listInstances()).map((instance2) => instance2.instanceName);
        if (instancesList.length > 1) {
          cli.logQuestion(`Which instance of the ${serviceName} app do you want to clone?`);
          instanceName = await cli.select(instancesList);
        } else {
          instanceName = instancesList[0] || user.username;
        }
      }
      const sourceInstanceName = instanceName;
      const targetInstanceName = user.username;
      if (shouldCreateDir) {
        fs.createServiceDir(serviceName);
      }
      const instance = new Instance({
        org,
        service,
        instanceName: targetInstanceName
      });
      const code = new Code({
        fs,
        org,
        service,
        instance
      });
      await fs.emptyDir();
      cli.viewSpinner(`Loading`);
      try {
        if (sourceInstanceName !== targetInstanceName) {
          await service.copy({
            sourceInstanceName,
            targetInstanceName,
            copyCode: true,
            copyData: true,
            overwrite: shouldOverwrite,
            instanceType: "personal"
          });
        }
        await code.getUrlsAndMap();
        await code.downloadSource();
      } catch (e) {
        if (e.message.includes("404") || e.message.includes("params.Body")) {
          cli.logInfo(`This instance is empty and does not contain any code.`);
          cli.viewSpinner("Loading");
          const coreTemplates = await fs.listCoreTemplates();
          cli.logInfo("Please choose a code template to generate instead.");
          const selectedTemplate = await cli.select(coreTemplates);
          const templateName = selectedTemplate.name;
          cli.viewSpinner("Generating app files");
          await fs.initService({ orgName, serviceName, templateName });
          cli.viewSpinner("Installing dependencies");
          await fs.installDependenciesIfExists();
          cli.logSuccess(`Successfully generated app "${serviceName}" in this directory.`);
          cli.logSuccess(`Successfully cloned instance "${sourceInstanceName}"`);
          if (shouldCreateDir) {
            cli.logSuccess(`Please cd into the "${serviceName}" directory and run "cloud" to start developing.`);
          }
          return;
        } else {
          throw e;
        }
      }
      await fs.readServiceFileIfExists();
      await fs.writeServiceFile({ serviceName, orgName });
      cli.viewSpinner("Installing dependencies");
      await fs.installDependenciesIfExists();
      cli.logSuccess(`Successfully cloned instance "${sourceInstanceName}"`);
      if (shouldCreateDir) {
        cli.logSuccess(`Please cd into the "${serviceName}" directory and run "cloud" to start developing.`);
      }
    };
    module2.exports = clone;
  }
});

// src/commands/init.js
var require_init2 = __commonJS({
  "src/commands/init.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var FS = require_FS();
    var Org = require_Org();
    var User = require_User();
    var Analytics = require_Analytics();
    var login = require_login();
    var clone = require_clone4();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      let shouldOverwrite = cli.options.overwrite || cli.options.o;
      let orgName = cli.options.org;
      let serviceName = cli.options.app;
      let templateName = cli.options.template;
      if (!await fs.isCwdEmpty() && !shouldOverwrite) {
        cli.logInfo(`This directory is not empty. Are you sure you want to overwrite it?`);
        shouldOverwrite = await cli.confirm();
        if (!shouldOverwrite) {
          await cli.quit();
        }
      }
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      let shouldCreate;
      let shouldClone;
      if (!serviceName) {
        cli.viewSpinner(`Loading`);
        let existingServicesNames = (await org.listServices()).map((service) => service.serviceName);
        if (existingServicesNames.length === 0) {
          shouldCreate = true;
        } else {
          cli.logQuestion("Do you want to create a new app or work on an existing one?");
          const selectItems = ["Create new app", "Work on an existing app"];
          const answer = await cli.select(selectItems);
          if (answer === selectItems[0]) {
            shouldCreate = true;
          } else {
            shouldClone = true;
          }
        }
        if (shouldCreate) {
          if (!templateName) {
            cli.viewSpinner("Loading");
            const coreTemplates = await fs.listCoreTemplates();
            cli.logInfo("Please choose an app template to generate in this directory.");
            const selectedTemplate = await cli.select(coreTemplates);
            templateName = selectedTemplate.name;
          }
          serviceName = await cli.promptServiceName(path.basename(fs.serviceRoot));
          cli.viewSpinner("Generating app files");
          await fs.initService({ orgName, serviceName, templateName });
          cli.viewSpinner("Installing dependencies");
          await fs.installDependenciesIfExists();
          const analytics = new Analytics({ org });
          analytics.publish("cloud.dev.initiated", {
            appName: `${orgName}:${serviceName}`
          });
          cli.logSuccess(`Successfully generated app ${cli.styles.bold(serviceName)} in this directory.`);
        }
        if (shouldClone) {
          cli.names.orgName = orgName;
          cli.options.overwrite = shouldOverwrite;
          cli.options.dir = false;
          return await clone(cli);
        }
      }
    };
  }
});

// src/utils/parseLog.js
var require_parseLog = __commonJS({
  "src/utils/parseLog.js"(exports2, module2) {
    function parseLog(data) {
      let text = data.replace(/'\s*\+\s*'/gm, "").replace(/\\n/gm, "\n").replace(/^'/, "").replace(/'$/, "");
      return text;
    }
    module2.exports = parseLog;
  }
});

// src/utils/outputInstanceLogs.js
var require_outputInstanceLogs = __commonJS({
  "src/utils/outputInstanceLogs.js"(exports2, module2) {
    var parseLog = require_parseLog();
    var shouldFilterLog = (text) => {
      try {
        const obj = JSON.parse(text);
        if (obj._slsLog) {
          return true;
        }
      } catch (e) {
        return false;
      }
      return false;
    };
    module2.exports = (cli, event) => {
      if (event.event === "instance.logs") {
        if (event.data.logs && Array.isArray(event.data.logs)) {
          event.data.logs.forEach((log) => {
            const timestamp = cli.styles.dim(`${new Date(log.createdAt).toLocaleTimeString([], { hour12: false })} ${cli.icons.line} `);
            if (!log.data) {
              return;
            }
            const text = parseLog(log.data);
            if (shouldFilterLog(text)) {
              return;
            }
            if (log.type === "warn") {
              cli.log(timestamp + cli.styles.grey(text));
            } else if (log.type === "error" || log.type === "stderr") {
              cli.log(timestamp + cli.styles.red(text));
            } else {
              cli.log(timestamp + text);
            }
          });
        }
      } else if (event.event === "cloud.test.log") {
        const { type, message, createdAt } = event.data.object;
        const text = parseLog(message);
        if (shouldFilterLog(text)) {
          return;
        }
        const timestamp = createdAt ? cli.styles.dim(`${new Date(createdAt).toLocaleTimeString([], { hour12: false })} ${cli.icons.line} `) : "";
        if (type === "warn") {
          cli.log(timestamp + cli.styles.grey(message));
        } else if (type === "error") {
          cli.log(timestamp + cli.styles.red(message));
        } else {
          cli.log(timestamp + message);
        }
      }
    };
  }
});

// src/commands/start.js
var require_start = __commonJS({
  "src/commands/start.js"(exports2, module2) {
    "use strict";
    var stringifyTimer = require_stringifyTimer();
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var Code = require_Code();
    var Data = require_Data();
    var Analytics = require_Analytics();
    var Platform = require_Platform();
    var login = require_login();
    var init = require_init2();
    var outputInstanceLogs = require_outputInstanceLogs();
    module2.exports = async (cli) => {
      cli.viewSpinner("Starting");
      const fs = new FS();
      await fs.read();
      let isSeedingEnabled = cli.options.seed || cli.options.s;
      const isReseedingEnabled = cli.options.reseed || cli.options.rs;
      let orgName;
      const loginToken = cli.options.login;
      const user = new User();
      if (loginToken) {
        orgName = await user.restoreOrgLogin(loginToken);
        cli.logSuccess("Successfully logged in.");
      }
      if (!user.isLoggedIn()) {
        cli.logInfo("You must login to proceed.");
        await login(cli);
        user.load();
      }
      if (!fs.serviceFile) {
        await init(cli);
        await fs.read();
        if (fs.dataFile) {
          isSeedingEnabled = true;
        }
      }
      orgName = orgName || cli.options.org || fs.serviceFile.serverless.org;
      let serviceName = cli.options.app || fs.serviceFile.serverless.app;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
        fs.writeServiceFile({ orgName });
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      if (!serviceName) {
        serviceName = await cli.promptServiceName(fs.defaults.app);
        fs.writeServiceFile({ serviceName });
      }
      cli.viewSpinner("Loading");
      const instanceName = user.username;
      cli.viewSpinner("Connecting");
      const service = new Service({ org, serviceName });
      const platform = new Platform({ accessKey: org.accessKey });
      const analytics = new Analytics({ org });
      const devModeStart = process.hrtime.bigint();
      cli.onQuit(async () => {
        const updatedServiceFile = await fs.readJsonFileIfExists(fs.serviceFilePath);
        const devModeEnd = process.hrtime.bigint();
        try {
          await analytics.publish("cloud.dev.ended", {
            timeInSeconds: Number(devModeEnd - devModeStart) / 1e9,
            dependencies: Object.keys(updatedServiceFile.dependencies || {}),
            appName: `${orgName}:${serviceName}`
          });
        } catch (err) {
          if (process.env.SLS_DEBUG) {
            console.error(err);
          }
        }
      });
      const instance = new Instance({
        org,
        service,
        instanceName
      });
      const code = new Code({
        fs,
        org,
        service,
        instance
      });
      const data = new Data({
        fs,
        org,
        service,
        instance
      });
      await Promise.all([
        analytics.publish("cloud.dev.enabled", {
          dependencies: Object.keys(fs.serviceFile.dependencies || {}),
          appName: `${orgName}:${serviceName}`
        }),
        platform.connect({
          orgName: org.orgName,
          appName: service.serviceName,
          instanceName: instance.instanceName
        }),
        code.sync()
      ]);
      platform.on("event", (event) => outputInstanceLogs(cli, event));
      cli.logSuccess(`Connected to your instance of the ${cli.styles.bold(service.serviceName)} app.`);
      cli.logSuccess("Enabled automatic file syncing and log streaming.");
      if (isReseedingEnabled) {
        cli.logSuccess("Enabled automatic data reseeding");
      }
      cli.logUrl(instance.url);
      cli.viewInput();
      const seed = async () => {
        cli.viewSpinner("Seeding");
        await data.import();
        cli.logSuccess(`Seeded data from the ${cli.styles.bold(fs.dataFileName)} file.`);
        cli.viewInput();
      };
      if (isSeedingEnabled) {
        await seed();
      }
      let inProgress = false;
      let isCodeUpdatedLogShown = false;
      let queuedFilePaths = new Set();
      fs.watch(async (filePaths) => {
        for (const filePath of filePaths) {
          queuedFilePaths.add(filePath);
        }
        if (inProgress) {
          return;
        }
        inProgress = true;
        while (queuedFilePaths.size > 0) {
          const filePathsToProcess = queuedFilePaths;
          queuedFilePaths = new Set();
          if (isReseedingEnabled && filePathsToProcess.has(fs.dataFilePath)) {
            cli.viewSpinner("Seeding", { timer: true });
            await seed();
          }
          cli.viewSpinner("Updating", { timer: true });
          const metrics = await code.sync(filePathsToProcess);
          analytics.publish("cloud.dev.synced", __spreadProps(__spreadValues({}, metrics), {
            serviceName: service.serviceName,
            instanceName: instance.instanceName,
            appName: `${orgName}:${serviceName}`
          })).catch(() => {
          });
        }
        inProgress = false;
        if (!isCodeUpdatedLogShown) {
          cli.logSuccess(`Successfully updated your code in ${stringifyTimer(cli.timer)}.`);
          isCodeUpdatedLogShown = true;
        }
        cli.viewInput();
      });
      return null;
    };
  }
});

// src/commands/logout.js
var require_logout = __commonJS({
  "src/commands/logout.js"(exports2, module2) {
    "use strict";
    var User = require_User();
    module2.exports = async (cli) => {
      cli.viewSpinner("Logging out");
      const user = new User();
      if (user.isLoggedIn()) {
        user.logout();
        cli.logSuccess("Successfully logged out of Serverless Cloud.");
      } else {
        cli.logInfo("You are already logged out of Serverless Cloud.");
      }
    };
  }
});

// src/commands/deploy.js
var require_deploy = __commonJS({
  "src/commands/deploy.js"(exports2, module2) {
    "use strict";
    var isCI2 = require_isCI();
    var stringifyTimer = require_stringifyTimer();
    var FS = require_FS();
    var Code = require_Code();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn() && !isCI2) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let { orgName, serviceName, instanceName } = cli.names;
      serviceName = serviceName || fs.serviceFile.serverless.app;
      orgName = orgName || fs.serviceFile.serverless.org;
      const instanceType = cli.options.type || "stage";
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      if (!instanceName) {
        if (isCI2) {
          throw new Error(`Please specify a stage name: "cloud deploy dev"`);
        }
        cli.logInfo(`Please enter the name of the stage you want to deploy to.`);
        instanceName = await cli.prompt(`type a stage name`);
      }
      cli.viewSpinner(`Validating`);
      const service = new Service({ org, serviceName });
      cli.viewSpinner(`Deploying to ${instanceName} (${instanceType})`, { timer: true });
      const instance = new Instance({
        org,
        service,
        instanceName,
        instanceType
      });
      const code = new Code({
        fs,
        org,
        service,
        instance
      });
      await code.sync();
      await instance.get();
      if (isCI2) {
        cli.logSuccess(`Successfully deployed to the "${instanceName}" stage.`);
      } else {
        cli.logSuccess(`Successfully deployed to the "${instanceName}" stage in ${stringifyTimer(cli.timer)}.`);
      }
      cli.logUrl(instance.url);
    };
  }
});

// src/commands/delete.js
var require_delete = __commonJS({
  "src/commands/delete.js"(exports2, module2) {
    "use strict";
    var isCI2 = require_isCI();
    var stringifyTimer = require_stringifyTimer();
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn() && !isCI2) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let instanceName = cli.args[0];
      const serviceName = cli.options.app || fs.serviceFile.serverless.app;
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      if (!orgName) {
        throw new Error(`Please specify a serverless org name in package.json or with the --org CLI param.`);
      }
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      if (!instanceName) {
        if (isCI2) {
          throw new Error(`Please specify a stage name: "cloud delete preview"`);
        }
        cli.logInfo(`Please enter the name of the stage you want to delete.`);
        instanceName = await cli.prompt(`type a stage name`);
      }
      cli.viewSpinner(`Validating`);
      const service = new Service({ org, serviceName });
      const instance = new Instance({
        org,
        service,
        instanceName
      });
      await instance.get();
      if (!["preview", "personal"].includes(instance.instanceType)) {
        throw new Error(`${instance.instanceType} instances must be deleted through the dashboard`);
      }
      cli.viewSpinner(`Deleting ${instanceName} (${instance.url})`, { timer: true });
      await instance.delete();
      cli.logSuccess(`Successfully deleted the "${instanceName}" stage in ${stringifyTimer(cli.timer)}.`);
    };
  }
});

// src/commands/share.js
var require_share = __commonJS({
  "src/commands/share.js"(exports2, module2) {
    "use strict";
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let shouldOverwrite = cli.options.overwrite || cli.options.o;
      const sourceInstanceName = user.username;
      const targetInstanceName = cli.args[0] || `${sourceInstanceName}-${Math.random().toString(36).substr(2, 5)}`;
      const serviceName = cli.options.app || fs.serviceFile.serverless.app;
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      const service = new Service({ org, serviceName });
      const instances = await service.listInstances();
      const existingInstance = instances.find((i) => i.instanceName === targetInstanceName);
      if (existingInstance && existingInstance.instanceType !== "preview") {
        throw new Error(`You cannot overwrite an existing ${existingInstance.instanceType} instance.`);
      }
      if (existingInstance && !shouldOverwrite) {
        cli.logInfo(`This preview instance already exists. Are you sure you want to overwrite it?`);
        shouldOverwrite = await cli.confirm();
        if (!shouldOverwrite) {
          if (cli.isShellActive) {
            await cli.logError("Canceled");
            return;
          } else {
            await cli.quit();
          }
        }
      }
      cli.viewSpinner("Sharing");
      if (sourceInstanceName !== targetInstanceName) {
        const res = await service.copy({
          sourceInstanceName,
          targetInstanceName,
          copyCode: true,
          copyData: true,
          copyStorage: true,
          instanceType: "preview"
        });
        if (res.hitSizeLimit) {
          cli.logInfo(`Your storage bucket contains more than 128MB of data, the first 128MB was copied.`);
        }
      }
      const instance = new Instance({
        org,
        service,
        instanceName: targetInstanceName
      });
      await instance.get();
      cli.logSuccess(`Successfully created preview intance "${targetInstanceName}".`);
      cli.logUrl(instance.url);
    };
  }
});

// src/commands/promote.js
var require_promote = __commonJS({
  "src/commands/promote.js"(exports2, module2) {
    "use strict";
    var isCI2 = require_isCI();
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn() && !isCI2) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      const serviceName = cli.options.app || fs.serviceFile.serverless.app;
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      const service = new Service({ org, serviceName });
      const instances = await service.listInstances();
      let sourceInstanceName = cli.args[0];
      let targetInstanceName = cli.args[1];
      if (!sourceInstanceName) {
        if (isCI2) {
          throw new Error(`Please specify a source stage name: "cloud promote dev"`);
        }
        cli.logInfo(`Please enter the name of the stage you want to promote.`);
        sourceInstanceName = await cli.prompt(`type a stage name`);
      }
      if (!targetInstanceName) {
        if (isCI2) {
          throw new Error(`Please specify a target stage name: "cloud promote dev prod"`);
        }
        cli.logInfo(`Please enter the name of the stage you want to promote to.`);
        targetInstanceName = await cli.prompt(`type a stage name`);
      }
      if (sourceInstanceName === targetInstanceName) {
        throw new Error(`The stage names you specified are identical. Please specify two different stages.`);
      }
      const existingSourceInstance = instances.find((i) => i.instanceName === targetInstanceName);
      const existingTargetInstance = instances.find((i) => i.instanceName === sourceInstanceName);
      if (existingSourceInstance && existingSourceInstance.instanceType !== "stage" || existingTargetInstance && existingTargetInstance.instanceType !== "stage") {
        throw new Error(`One of the instances you specified are not of type "stage". You can only promote between stage instances.`);
      }
      cli.viewSpinner("Promoting");
      if (sourceInstanceName !== targetInstanceName) {
        await service.copy({
          sourceInstanceName,
          targetInstanceName,
          copyCode: true,
          copyData: false,
          instanceType: "stage"
        });
      }
      cli.logSuccess(`Successfully promoted from the "${sourceInstanceName}" stage to the "${targetInstanceName}" stage.`);
    };
  }
});

// src/commands/version.js
var require_version2 = __commonJS({
  "src/commands/version.js"(exports2, module2) {
    "use strict";
    var { version } = require_package2();
    module2.exports = async (cli) => {
      cli.log(`v${version}`);
    };
  }
});

// src/commands/import.js
var require_import = __commonJS({
  "src/commands/import.js"(exports2, module2) {
    "use strict";
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var Data = require_Data();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const dataFileName = cli.args[0];
      const fs = new FS({ user, dataFileName });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let shouldOverwrite = cli.options.overwrite;
      const serviceName = cli.options.app || fs.serviceFile.serverless.app;
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      const instanceName = user.username;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      cli.viewSpinner("Importing");
      const service = new Service({ org, serviceName });
      const instance = new Instance({
        org,
        service,
        instanceName
      });
      const data = new Data({
        fs,
        org,
        service,
        instance
      });
      await data.import(shouldOverwrite);
      const message = `Data Imported from "${fs.dataFileName}"`;
      cli.logSuccess(message);
    };
  }
});

// src/commands/export.js
var require_export = __commonJS({
  "src/commands/export.js"(exports2, module2) {
    "use strict";
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var Data = require_Data();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const dataFileName = cli.args[0];
      const fs = new FS({ user, dataFileName });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let shouldOverwrite = cli.options.overwrite || cli.options.o;
      const serviceName = cli.options.app || fs.serviceFile.serverless.app;
      const instanceName = user.username;
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      if (!shouldOverwrite && fs.dataFile) {
        cli.logInfo(`This directory already contains a "${fs.dataFileName}" file. Are you sure you want to overwrite it?`);
        shouldOverwrite = await cli.confirm();
        if (!shouldOverwrite) {
          if (cli.isShellActive) {
            await cli.logError("Canceled");
            return;
          } else {
            await cli.quit();
          }
        }
      }
      cli.viewSpinner("Exporting");
      const service = new Service({ org, serviceName });
      const instance = new Instance({
        org,
        service,
        instanceName
      });
      const data = new Data({
        fs,
        org,
        service,
        instance
      });
      await data.export();
      cli.logSuccess(`Data Exported to "${fs.dataFileName}"`);
    };
  }
});

// src/utils/outputTestResults.js
var require_outputTestResults = __commonJS({
  "src/utils/outputTestResults.js"(exports2, module2) {
    module2.exports = (cli, event) => {
      const { results, message, error, test_time_ms } = event.data.object;
      const took = test_time_ms ? cli.styles.dim(`(${test_time_ms / 1e3}s)`) : "";
      if (error) {
        cli.log(error);
      }
      if (message) {
        cli.log(message);
      }
      if (results) {
        if (results.success) {
          cli.logSuccess(`${results.numPassedTests}/${results.numTotalTests} tests passed ${took}`);
        } else {
          cli.logError(`${results.numFailedTests}/${results.numTotalTests} tests failed ${took}`);
        }
        cli.log();
        for (const result of results.testResults) {
          cli.log(`${result.name.replace(/\/(var|tmp)\/task\//, "")}`, 2);
          cli.log();
          if (result.status === "failed") {
            cli.log(result.message);
          } else {
            for (let assertionResult of result.assertionResults) {
              if (assertionResult.status === "failed") {
                cli.logError(assertionResult.title, 4);
                cli.log();
                for (let failureMessage of assertionResult.failureMessages) {
                  for (let line of failureMessage.split("\n")) {
                    cli.log(line, 6);
                  }
                }
                cli.log();
              } else {
                cli.logSuccess(cli.styles.dim(assertionResult.title), 4);
              }
            }
          }
          cli.log();
        }
        process.exitCode = results.success ? 0 : 1;
      }
    };
  }
});

// src/commands/test.js
var require_test2 = __commonJS({
  "src/commands/test.js"(exports2, module2) {
    "use strict";
    var isCI2 = require_isCI();
    var Code = require_Code();
    var FS = require_FS();
    var Instance = require_Instance();
    var Org = require_Org();
    var Platform = require_Platform();
    var Service = require_Service();
    var User = require_User();
    var login = require_login();
    var outputInstanceLogs = require_outputInstanceLogs();
    var outputTestResults = require_outputTestResults();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn() && !isCI2) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      const serviceName = cli.options.service || fs.serviceFile.serverless.app || fs.serviceFile.serverless.service;
      const instanceName = cli.isShellActive ? user.username : `test-${Math.random().toString(36).substr(2, 5)}`;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      if (!cli.isShellActive) {
        cli.viewSpinner(`Starting test instance (${instanceName})`);
      }
      const service = new Service({ org, serviceName });
      const instance = new Instance({
        org,
        service,
        instanceType: "test",
        instanceName
      });
      if (!cli.isShellActive) {
        const code = new Code({
          fs,
          org,
          service,
          instance
        });
        await code.sync();
        cli.logSuccess(`Test instance started: ${instance.url}`);
      }
      const platform = new Platform({ accessKey: org.accessKey });
      if (!cli.isShellActive) {
        platform.on("event", (event) => outputInstanceLogs(cli, event));
      }
      try {
        const promise = platform.waitForEvent("cloud.test.completed", 6e4);
        await platform.connect({
          orgName: org.orgName,
          appName: service.serviceName,
          instanceName: instance.instanceName
        });
        cli.viewSpinner("Running tests");
        await instance.test();
        const event = await promise;
        outputTestResults(cli, event);
        process.exitCode = event.data.object.results && event.data.object.results.success ? 0 : 1;
      } catch (error) {
        console.log(error);
        cli.logError(error);
      }
      platform.disconnect();
      if (!cli.isShellActive) {
        cli.viewSpinner("Deleting instance");
        await instance.delete();
        cli.logSuccess("Test instance deleted");
        cli.log(`Exiting with status code ${process.exitCode}`);
      }
    };
  }
});

// src/commands/docs.js
var require_docs = __commonJS({
  "src/commands/docs.js"(exports2, module2) {
    "use strict";
    var open = require_open();
    module2.exports = async (cli) => {
      cli.viewSpinner("Opening docs");
      cli.logInfo("Your browser should open automatically");
      const docsUrl = "https://serverless.com/cloud/docs";
      cli.logInfo("If not, open the following docs url:");
      cli.logUrl(docsUrl);
      open(docsUrl);
    };
  }
});

// src/commands/url.js
var require_url = __commonJS({
  "src/commands/url.js"(exports2, module2) {
    "use strict";
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var Instance = require_Instance();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let orgName = cli.options.org || fs.serviceFile.serverless.org;
      const serviceName = cli.options.app || fs.serviceFile.serverless.app;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      cli.viewSpinner("Loading");
      const service = new Service({ org, serviceName });
      const instance = new Instance({
        org,
        service,
        instanceName: user.username
      });
      await instance.get();
      cli.logUrl(instance.url);
    };
  }
});

// src/commands/open.js
var require_open2 = __commonJS({
  "src/commands/open.js"(exports2, module2) {
    "use strict";
    var open = require_open();
    var FS = require_FS();
    var User = require_User();
    var Org = require_Org();
    var Service = require_Service();
    var login = require_login();
    module2.exports = async (cli) => {
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      cli.viewSpinner("Opening Dashboard");
      let orgName = fs.serviceFile.serverless.org;
      const serviceName = fs.serviceFile.serverless.app;
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      const service = new Service({ org, serviceName });
      cli.logInfo("Your browser should open automatically");
      cli.logInfo("If not, open the following app page url:");
      cli.logUrl(service.getDashboardUrl());
      open(service.getDashboardUrl());
    };
  }
});

// src/commands/fork.js
var require_fork = __commonJS({
  "src/commands/fork.js"(exports2, module2) {
    "use strict";
    var FS = require_FS();
    var Org = require_Org();
    var User = require_User();
    var Service = require_Service();
    var Instance = require_Instance();
    var Code = require_Code();
    var login = require_login();
    module2.exports = async (cli) => {
      let shouldOverwrite = cli.options.overwrite || cli.options.o;
      let orgName = cli.options.org;
      let instanceName = cli.options.instance || "production";
      let [sourceOrgName, sourceServiceName] = cli.args[0].split("/");
      let serviceName = cli.options.app || sourceServiceName;
      if (!sourceOrgName || !serviceName) {
        cli.logError(`Usage: cloud fork <org-name>/<app-name> (--instance <new-instance-name> --app <new-app-name>) `);
        return;
      }
      cli.viewSpinner("Loading");
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      if (!await fs.isCwdEmpty() && !shouldOverwrite) {
        cli.logInfo(`This directory is not empty. Are you sure you want to overwrite it?`);
        const shouldOverwrite2 = await cli.confirm();
        if (!shouldOverwrite2) {
          await cli.quit();
        }
      }
      if (!orgName) {
        orgName = await cli.selectOrg(user);
      }
      cli.viewSpinner("Loading");
      const org = new Org({ user, orgName });
      if (!await org.isAuthorized()) {
        cli.logError(`You don't have access to the "${orgName}" org.`);
        orgName = await cli.selectOrg(user);
      }
      org.update({ orgName });
      cli.viewSpinner(`Forking ${sourceOrgName}/${sourceServiceName} => ${orgName}/${serviceName}`);
      const service = new Service({ org, serviceName });
      await service.copy({
        sourceOrgName,
        sourceServiceName,
        sourceInstanceName: instanceName,
        serviceName,
        targetInstanceName: instanceName,
        copyCode: true,
        copyData: false,
        instanceType: "stage"
      });
      const instance = new Instance({
        org,
        service,
        instanceName
      });
      const code = new Code({
        fs,
        org,
        service,
        instance
      });
      await fs.emptyDir();
      await code.getUrlsAndMap();
      await code.downloadSource();
      await fs.readServiceFileIfExists();
      await fs.writeServiceFile({ serviceName, orgName });
      cli.logSuccess(`Successfully forked "${sourceOrgName}/${serviceName}"`);
    };
  }
});

// src/commands/install.js
var require_install = __commonJS({
  "src/commands/install.js"(exports2, module2) {
    "use strict";
    var spawn = require_spawn();
    var FS = require_FS();
    var User = require_User();
    var login = require_login();
    module2.exports = async (cli) => {
      const packageName = cli.args[0];
      if (packageName) {
        cli.viewSpinner(`Installing ${packageName}`);
      } else {
        cli.viewSpinner(`Installing dependencies`);
      }
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      const args = ["install"];
      if (packageName) {
        args.push(packageName);
      }
      try {
        await spawn("npm", args, { cwd: exports2.serviceRoot });
        if (packageName) {
          cli.logSuccess(`Successfully installed the ${cli.styles.bold(packageName)} package.`);
        } else {
          cli.logSuccess(`Successfully installed dependencies.`);
        }
      } catch (e) {
        const outputString = e.stdBuffer.toString();
        if (outputString.includes("E404") || outputString.includes("ENOVERSIONS")) {
          throw new Error(`Package ${cli.styles.bold(packageName)} does not exist on npm.`);
        }
        throw new Error(`Failed to install the ${cli.styles.bold(packageName)} package due to the following error:
${outputString}`);
      }
    };
  }
});

// src/commands/uninstall.js
var require_uninstall = __commonJS({
  "src/commands/uninstall.js"(exports2, module2) {
    "use strict";
    var spawn = require_spawn();
    var FS = require_FS();
    var User = require_User();
    var login = require_login();
    module2.exports = async (cli) => {
      const user = new User();
      if (!user.isLoggedIn()) {
        cli.logInfo("Please login to proceed.");
        await login(cli);
        user.load();
      }
      const fs = new FS({ user });
      await fs.read();
      if (!fs.serviceFile) {
        throw new Error(`You must be inside a Serverless Cloud app directory to run this command.`);
      }
      let packageName = cli.args[0];
      if (!packageName) {
        cli.logInfo(`Please enter the name of the npm package you want to uninstall.`);
        packageName = await cli.prompt(`type a package name`);
      }
      cli.viewSpinner(`Installing ${packageName}`);
      const args = ["uninstall", packageName];
      try {
        await spawn("npm", args, { cwd: exports2.serviceRoot });
        cli.logSuccess(`Successfully uninstalled the ${cli.styles.bold(packageName)} package.`);
      } catch (e) {
        const outputString = e.stdBuffer.toString();
        throw new Error(`Failed to uninstall the ${cli.styles.bold(packageName)} package due to the following error:
${outputString}`);
      }
    };
  }
});

// src/commands/index.js
var require_commands = __commonJS({
  "src/commands/index.js"(exports2, module2) {
    "use strict";
    var help = require_help();
    var start = require_start();
    var login = require_login();
    var logout = require_logout();
    var deploy = require_deploy();
    var _delete = require_delete();
    var share = require_share();
    var promote = require_promote();
    var clone = require_clone4();
    var version = require_version2();
    var importCommand = require_import();
    var exportCommand = require_export();
    var test = require_test2();
    var docs = require_docs();
    var url = require_url();
    var open = require_open2();
    var fork = require_fork();
    var install = require_install();
    var uninstall = require_uninstall();
    module2.exports = {
      help,
      start,
      test,
      deploy,
      delete: _delete,
      share,
      promote,
      clone,
      import: importCommand,
      export: exportCommand,
      login,
      logout,
      version,
      docs,
      url,
      open,
      fork,
      install,
      uninstall
    };
  }
});

// src/context/CLI.js
var require_CLI = __commonJS({
  "src/context/CLI.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var figures = require_figures();
    var chalk = require_source();
    var keypress = require_keypress();
    var ansiEscapes = require_ansi_escapes();
    var stripAnsi = require_strip_ansi();
    var minimist = require_minimist();
    var emoji = require_node_emoji();
    var spawn = require_spawn();
    var fetchLatestVersion = require_latest_version();
    var isInstalledGlobally = require_is_installed_globally();
    var { gt: versionGreaterThan, satisfies: versionSatisfies } = require_semver();
    var parseSlug = require_parseSlug();
    var runWithTimeout = require_runWithTimeout();
    var { version: currentVersion } = require_package2();
    var commands = require_commands();
    var CLI2 = class {
      constructor() {
        this._initStyles();
        this._initIcons();
        this._initTips();
        this._initSuggestions();
        this._viewType = null;
        this._viewMessage = null;
        this.inputValue = "";
        this.allowedInputCharacter = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890-_@~/^. ";
        this.options = {};
        this._commandsHistory = [];
      }
      async prompt(question, options = {}) {
        this._isPromptActive = true;
        if (options.default) {
          this.inputValue = options.default;
        }
        this.viewInput(question);
        const sleep = async (ms) => new Promise((res) => setTimeout(res, ms));
        while (!this._promptResponse)
          await sleep(50);
        const promptResponse = this._promptResponse;
        this.logInfo(`You've entered ${this.styles.bold(promptResponse)}.`);
        this._promptResponse = null;
        this._isPromptActive = false;
        return promptResponse;
      }
      async promptServiceName(defaultServiceName = null) {
        this.logInfo("Please enter a name for your app.");
        const specifiedServiceName = await this.prompt("type an app name", { default: defaultServiceName });
        if (!specifiedServiceName.match(/^[a-z0-9-]+$/)) {
          this.logError("App name must consist only of lowercase characters and hyphens. Please try again.");
          return await this.promptServiceName();
        }
        return specifiedServiceName;
      }
      async confirm() {
        const selectItems = ["no", "yes"];
        const answer = await this.select(selectItems);
        if (answer === selectItems[1]) {
          return true;
        }
        if (answer === selectItems[0]) {
          return false;
        }
        return false;
      }
      async run(inputValue) {
        if (!this.isShellActive) {
          this.viewSpinner(`Starting`);
          this._hideCursor();
          this._logLogo();
          this._watchKeyboard();
          await this._autoUpdate();
        }
        this._parseCommand(inputValue);
        let errorOccurred = false;
        try {
          const nonShellCommands = ["clone"];
          if (this.isShellActive && nonShellCommands.includes(this.command)) {
            throw new Error(`Command "${this.command}" is currently not supported in the shell`);
          }
          if (!commands[this.command]) {
            throw new Error(`Command "${this.command}" is not a valid command`);
          }
          await commands[this.command](this);
          if (this.autoRunCommand) {
            await commands[this.autoRunCommand](this);
            this.autoRunCommand = null;
          }
        } catch (error) {
          errorOccurred = true;
          this.logError(error.message);
        }
        if (this.isShellActive) {
          if (["install", "uninstall"].includes(this.command) && !errorOccurred) {
            return;
          }
          return this.viewInput();
        }
        return this._stop();
      }
      viewInput(viewMessage = this._getTip()) {
        clearInterval(this._timerInterval);
        clearInterval(this._spinnerInterval);
        this.switchView({ viewType: "input", viewMessage });
      }
      viewSpinner(viewMessage = "Loading", { timer = false } = {}) {
        if (!process.stdin.isTTY) {
          console.log(viewMessage);
          return;
        }
        clearInterval(this._spinnerInterval);
        clearInterval(this._timerInterval);
        if (timer) {
          this.timer = 0;
          this._timerInterval = setInterval(() => this.timer = +this.timer + 1, 1e3);
        }
        this._spinnerFrequency = 40;
        this._spinnerFrames = ["\u280B", "\u2819", "\u2839", "\u2838", "\u283C", "\u2834", "\u2826", "\u2827", "\u2807", "\u280F"];
        this._spinnerFrameIndex = 0;
        this._spinnerInterval = setInterval(() => this._updateSpinner(viewMessage, { timer }), this._spinnerFrequency);
      }
      async select(selectItems = [], selectedItemIndex = 0) {
        clearInterval(this._timerInterval);
        clearInterval(this._spinnerInterval);
        this._selectItems = selectItems;
        this._selectedItemIndex = selectedItemIndex;
        if (this._selectItems.length === 1) {
          this._selectedItem = this._selectItems[0];
          return this._selectedItem;
        }
        this.switchView({ viewType: "select" });
        const sleep = async (ms) => new Promise((res) => setTimeout(res, ms));
        while (!this._selectedItem)
          await sleep(50);
        const selectedItem = this._selectedItem;
        if (typeof selectedItem === "object") {
          this.logInfo(`You've selected ${this.styles.bold(selectedItem.title)}.`);
        } else {
          this.logInfo(`You've selected ${this.styles.bold(selectedItem)}.`);
        }
        this._selectedItem = null;
        this._selectedItemIndex = null;
        this._selectItems = [];
        return selectedItem;
      }
      async selectOrg(user) {
        this.viewSpinner("Loading");
        let orgName;
        const orgsList = (await user.listOrgs()).map((org) => org.orgName);
        if (orgsList.length > 1) {
          this.logInfo("Please select an organization.");
          orgName = await this.select(orgsList);
        } else {
          orgName = orgsList[0];
        }
        return orgName;
      }
      async selectService(org) {
        let serviceName;
        this.viewSpinner("Loading");
        const servicesList = (await org.listServicesWithInstances()).map((service) => service.serviceName);
        if (servicesList.length > 1) {
          this.logInfo("Please select a service.");
          serviceName = await this.select(servicesList);
        } else {
          serviceName = servicesList[0];
        }
        return serviceName;
      }
      async selectInstance(service) {
        let instanceName;
        this.viewSpinner("Loading");
        const instancesList = (await service.listInstances()).map((instance) => instance.instanceName);
        if (instancesList.length > 1) {
          this.logInfo(`Please select an instance.`);
          instanceName = await this.select(instancesList);
        } else {
          instanceName = instancesList[0];
        }
        return instanceName;
      }
      viewMessage(viewMessage) {
        this.switchView({ viewMessage });
      }
      viewType(viewType) {
        this.switchView({ viewType });
      }
      switchView({ viewType, viewMessage }) {
        if (viewType)
          this._viewType = viewType;
        if (viewMessage)
          this._viewMessage = viewMessage;
        return this._view();
      }
      logSuccess(msg, indent = 0) {
        this.log(`${this.icons.tick} ${msg}`, indent);
      }
      logError(msg, indent = 0) {
        this.log(`${this.icons.cross} ${this.styles.red(msg)}`, indent);
      }
      logInfo(msg, indent = 0) {
        this.log(`${this.icons.info} ${msg}`, indent);
      }
      logWarning(msg, indent = 0) {
        this.log(`${this.icons.warning} ${msg}`, indent);
      }
      logQuestion(msg, indent = 0) {
        this.log(`${this.icons.question} ${msg}`, indent);
      }
      logUrl(url, indent = 0) {
        this.log(`${this.icons.arrow} ${url}`, indent);
      }
      logTime(msg, indent = 0) {
        this.log(`${this.styles.dim(`${new Date(Date.now()).toLocaleTimeString()} ${this.icons.line}`)} ${msg}`, indent);
      }
      log(msg = "", indent = 0) {
        this._ensureTopPadding();
        this._eraseCursorLineAndBelow();
        this._log(`${" ".repeat(indent)}${msg}
`);
        this._view();
      }
      onQuit(fn) {
        this._onQuit = fn;
      }
      async quit(quitMessage = "Canceled") {
        this.inputValue = "";
        this._clearIntervals();
        if (!this._quitting) {
          this.logError(quitMessage);
        }
        this._eraseCursorLineAndBelow();
        if (!this._quitting && this._onQuit) {
          this._quitting = true;
          await runWithTimeout(this._onQuit(), 1e3);
        }
        this._stop();
      }
      _stop(exitCode = 0) {
        this._clearIntervals();
        process.stdin.pause();
        this._eraseCursorLineAndBelow();
        this._log("\n");
        this._showCursor();
        process.exit(exitCode);
      }
      _clearIntervals() {
        clearInterval(this._timerInterval);
        clearInterval(this._spinnerInterval);
        clearInterval(this._tipsInterval);
      }
      _parseCommand(inputValue) {
        var _a;
        const minimistInput = inputValue ? inputValue.split(" ") : process.argv.slice(2);
        const minimistOutput = minimist(minimistInput);
        this.command = (_a = minimistOutput._[0]) == null ? void 0 : _a.toLowerCase();
        this.args = minimistOutput._.slice(1);
        this.options = Object.assign({}, this.options, minimistOutput);
        if (this.options.help || this.options.h)
          this.command = "help";
        if (this.options.version || this.options.v)
          this.command = "version";
        this.names = parseSlug(this.args[0]);
        this.names.orgName = this.names.orgName || this.options.org;
        this.names.serviceName = this.names.serviceName || this.options.app;
        this.names.instanceName = this.names.instanceName || this.options.instance;
        if (inputValue === "start") {
          delete commands.start;
        }
        const isStartCommand = !inputValue && (!this.command || this.command === "start");
        if (isStartCommand) {
          this.isShellActive = true;
          this.command = "start";
        }
        delete this.options._;
      }
      _logLogo() {
        if (!this._canRenderBolt() || process.env.IS_CHILD_PROCESS) {
          return;
        }
        let logo = os.EOL;
        logo += "serverless ";
        logo += `${this.icons.bolt}`;
        logo += "cloud";
        if (process.env.SERVERLESS_PLATFORM_STAGE === "dev") {
          logo += this.styles.grey(" (dev)");
        }
        logo += os.EOL;
        this._log(logo);
      }
      _log(msg) {
        process.stdout.write(msg);
      }
      _showCursor() {
        this._log(ansiEscapes.cursorShow);
      }
      _hideCursor() {
        this._log(ansiEscapes.cursorHide);
      }
      _moveCursorLeft() {
        this._log(ansiEscapes.cursorLeft);
      }
      _moveCursorUp(rowCount) {
        this._log(ansiEscapes.cursorUp(rowCount));
      }
      _eraseCursorLineAndBelow() {
        this._log(ansiEscapes.eraseDown);
      }
      _restorCursorPosition(outputString) {
        const startingPosition = this._getRelativeVerticalCursorPosition(outputString);
        this._moveCursorUp(startingPosition);
        this._moveCursorLeft();
      }
      _getRelativeVerticalCursorPosition(outputString) {
        const paddingLinesCount = 1;
        let lines = stripAnsi(outputString).split("\n");
        let linesCount = lines.length;
        for (const line of lines) {
          const lineWidth = Number(line.length);
          const terminalWidth = Number(process.stdout.columns);
          const brokenLinesCount = Math.floor(lineWidth / terminalWidth);
          linesCount += brokenLinesCount;
        }
        const totalLinesCount = paddingLinesCount + linesCount;
        return totalLinesCount;
      }
      _view() {
        let view = this._getView();
        if (!view)
          return;
        this._eraseCursorLineAndBelow();
        this._log(`
${view}
`);
        this._restorCursorPosition(view);
      }
      _getView() {
        if (this._viewType === "input") {
          return this._getInputView();
        }
        if (this._viewType === "timer") {
          return this._getTimerView();
        }
        if (this._viewType === "spinner") {
          return this._getSpinnerView();
        }
        if (this._viewType === "select") {
          return this._getSelectView();
        }
      }
      _getInputView() {
        let view = "";
        if (this._canRenderBolt()) {
          view += `${this.icons.bolt}`;
        }
        view += `${this.icons.pointer} `;
        if (this.inputValue !== "") {
          const suggestedCommand = this._suggestCommand();
          if (suggestedCommand && !this._isPromptActive) {
            const suggestedFragment = suggestedCommand.replace(this.inputValue, "");
            return view += `${this.inputValue}${this.styles.dim(suggestedFragment)}`;
          }
          return view += `${this.inputValue}\u258A`;
        }
        return view += `\u258A${this.styles.dim(this._viewMessage)}`;
      }
      _getTimerView() {
        return this.styles.grey(`${this.timer}s ${this.icons.pointer} ${this._viewMessage}`);
      }
      _getSpinnerView() {
        return `${this._getSpinnerFrame()} ${this._viewMessage}`;
      }
      _getSelectView() {
        if (this._isSelectingLongList())
          return this._getLongSelectView();
        return this._getNormalSelectView();
      }
      _isSelectingLongList() {
        const margin = 4;
        if (this._selectItems.length >= process.stdout.rows - margin) {
          return true;
        }
        return false;
      }
      _getNormalSelectView() {
        let view = "";
        this._selectItems.forEach((selectItem, selectItemIndex) => {
          if (selectItemIndex !== this._selectedItemIndex) {
            if (typeof selectItem === "object") {
              view += `  ${this.styles.grey(`${selectItem.title} - ${selectItem.description}`)}`;
            } else {
              view += `  ${this.styles.grey(`${selectItem}`)}`;
            }
          } else {
            if (typeof selectItem === "object") {
              view += `${this.icons.pointer} ${selectItem.title} ${this.styles.grey(`- ${selectItem.description}`)}`;
            } else {
              view += `${this.icons.pointer} ${selectItem}`;
            }
          }
          const notLastSelectItem = selectItemIndex < this._selectItems.length - 1;
          if (notLastSelectItem) {
            view += "\n";
          }
        });
        return view;
      }
      _getLongSelectView() {
        let view = "";
        const previousItem = this._selectItems[this._getPreviousItemIndex()];
        const selectedItem = this._selectItems[this._selectedItemIndex];
        const nextItem = this._selectItems[this._getNextItemIndex()];
        if (typeof selectedItem === "object") {
          view += `  ${this.styles.grey(`${previousItem.title}`)}
`;
          view += `${this.icons.pointer} ${selectedItem.title} ${this.styles.grey(`(${selectedItem.description})`)}
`;
          view += `  ${this.styles.grey(`${nextItem.title}`)}`;
        } else {
          view += `  ${this.styles.grey(`${previousItem}`)}
`;
          view += `${this.icons.pointer} ${selectedItem}
`;
          view += `  ${this.styles.grey(`${nextItem}`)}`;
        }
        return view;
      }
      _getPreviousItemIndex() {
        const isFirstItemSelected = this._selectedItemIndex === 0;
        return isFirstItemSelected ? this._selectItems.length - 1 : this._selectedItemIndex - 1;
      }
      _getNextItemIndex() {
        const isLastItemSelected = this._selectedItemIndex === this._selectItems.length - 1;
        return isLastItemSelected ? 0 : this._selectedItemIndex + 1;
      }
      async _autoUpdate() {
        const skipUpdate = process.env.CLOUD_SKIP_UPDATE || process.argv.slice(2).includes("--skip-update");
        const latestVersion = await fetchLatestVersion("@serverless/cloud");
        if (!skipUpdate && versionGreaterThan(latestVersion, currentVersion)) {
          if (!versionSatisfies(latestVersion, `^${currentVersion}`)) {
            this.logError(`A new major version of the Serverless Cloud CLI is available (v${latestVersion}). You are currently running v${currentVersion}. To proceed, please update your Serverless Cloud CLI to the latest version.`);
            return this._stop(1);
          }
          this.viewSpinner(`Updating CLI ${this.styles.dim(`(this may take a few minutes)`)}`);
          if (process.env.IS_CHILD_PROCESS) {
            throw new Error(`Update installed, but your enviroment is still loading the outdated version.`);
          }
          try {
            await spawn("npm", ["install", "@serverless/cloud", isInstalledGlobally ? "--global" : "--save-development"]);
            process.stdin.pause();
            this._clearIntervals();
            await spawn(process.argv.shift(), process.argv, {
              cwd: process.cwd(),
              env: __spreadProps(__spreadValues({}, process.env), { IS_CHILD_PROCESS: true }),
              detached: false,
              stdio: "inherit"
            });
            process.exit();
          } catch (e) {
            const outputString = e.stdBuffer.toString();
            this.logError(`Serverless Cloud CLI auto update failed due to the following error:
`);
            this.logError(outputString);
            this.logError(`You are currently running v${currentVersion}. Please manually update the CLI to the latest version (v${latestVersion}) to proceed.`);
            return this._stop(1);
          }
        }
      }
      _watchKeyboard() {
        keypress(process.stdin);
        process.stdin.on("keypress", async (character, key = {}) => {
          if (this._shouldQuit(key)) {
            return await this.quit();
          }
          if (this._shouldSubmitSelection(key)) {
            return await this._submitSelection();
          }
          if (this._shouldSelectPrevious(key)) {
            return await this._selectPrevious();
          }
          if (this._shouldSelectNext(key)) {
            return await this._selectNext();
          }
          if (this._shouldSubmitPromptResponse(key)) {
            return await this._submitPromptResponse();
          }
          if (this._shouldGetPreviousCommand(key)) {
            return await this._getPreviousCommand();
          }
          if (this._shouldGetNextCommand(key)) {
            return await this._getNextCommand();
          }
          if (this._shouldClearScreen(key)) {
            return this._clearScreen();
          }
          if (this._shouldRunCommand(key)) {
            return await this._runCommand();
          }
          if (this._shouldAutoComplete(key)) {
            return this._autoComplete();
          }
          if (this._shouldDeleteLastWord(key)) {
            return this._deleteLastWord();
          }
          if (this._shouldDeleteLastCharacter(key)) {
            return this._deleteLastCharacter();
          }
          if (this._shouldClearInputValue(key)) {
            return this._clearInputValue();
          }
          if (this._shouldUpdateInputValue(character)) {
            return this._updateInputValue(character);
          }
        });
        if (process.stdin.isTTY) {
          process.stdin.setRawMode(true);
        }
        process.stdin.resume();
      }
      _shouldSubmitPromptResponse(key) {
        return !!(key.name === "return" && this.inputValue !== "" && this._isPromptActive);
      }
      _shouldSubmitSelection(key) {
        return !!(key.name === "return" && this._viewType === "select");
      }
      _shouldRunCommand(key) {
        return !!(key.name === "return" && this.inputValue !== "" && this._viewType === "input");
      }
      _shouldAutoComplete(key) {
        return !!((key.name === "tab" || key.name === "right") && this.inputValue !== "" && !this._isPromptActive);
      }
      _shouldDeleteLastCharacter(key) {
        return !!(key.name === "backspace");
      }
      _shouldDeleteLastWord(key) {
        return !!(key.sequence === "" || key.name === "backspace" && key.meta);
      }
      _shouldClearInputValue(key) {
        return !!(key.sequence === "");
      }
      _shouldGetPreviousCommand(key) {
        return !!(key.name === "up");
      }
      _shouldGetNextCommand(key) {
        return !!(key.name === "down");
      }
      _shouldSelectPrevious(key) {
        return !!(key.name === "up") && this._viewType === "select";
      }
      _shouldSelectNext(key) {
        return !!(key.name === "down") && this._viewType === "select";
      }
      _shouldClearScreen(key) {
        const inputValue = this.inputValue.trim();
        if (key.name === "return" && inputValue === "clear") {
          return true;
        }
        return false;
      }
      _shouldQuit(key) {
        const inputValue = this.inputValue.trim().toLowerCase();
        const quitCommands = ["quit", "q", "exit", "cancel"];
        if (key.name === "return" && quitCommands.includes(inputValue)) {
          return true;
        }
        if (key.ctrl && key.name === "c") {
          return true;
        }
        return false;
      }
      _shouldUpdateInputValue(character) {
        return !!(this.allowedInputCharacter.includes(character) && this._viewType === "input");
      }
      async _submitPromptResponse() {
        this._promptResponse = this.inputValue;
        this.inputValue = "";
      }
      async _submitSelection() {
        this._selectedItem = this._selectItems[this._selectedItemIndex];
      }
      async _runCommand() {
        this._updateCommandsHistory();
        this._ensureNoCloudRootCommand();
        const inputValue = this.inputValue;
        this.inputValue = "";
        this._commandRunningInShell = true;
        await this.run(inputValue);
        this._commandRunningInShell = false;
      }
      async _autoComplete() {
        const suggestedCommand = this._suggestCommand();
        if (suggestedCommand) {
          this.inputValue = `${suggestedCommand} `;
          this.viewInput();
        }
      }
      _suggestCommand() {
        return this._suggestions.find((suggestion) => suggestion.startsWith(this.inputValue) && suggestion !== this.inputValue);
      }
      _ensureNoCloudRootCommand() {
        if (this.inputValue.startsWith("cloud ")) {
          this.inputValue = this.inputValue.replace("cloud ", "");
        }
      }
      _updateCommandsHistory() {
        this.inputValue = this.inputValue.trim();
        this._commandsHistory.push(this.inputValue);
        this._commandsHistoryIndex = null;
      }
      _getPreviousCommand() {
        if (this._commandsHistory.length === 0) {
          return;
        }
        if (!this._commandsHistoryIndex && this._commandsHistoryIndex !== 0) {
          this._commandsHistoryIndex = this._commandsHistory.length - 1;
        } else {
          this._commandsHistoryIndex = this._commandsHistoryIndex - 1;
        }
        if (!this._commandsHistory[this._commandsHistoryIndex]) {
          this._commandsHistoryIndex = this._commandsHistory.length - 1;
        }
        this.inputValue = this._commandsHistory[this._commandsHistoryIndex];
        this.viewInput();
      }
      _getNextCommand() {
        if (this._commandsHistory.length === 0) {
          return;
        }
        if (!this._commandsHistoryIndex && this._commandsHistoryIndex !== 0) {
          this._commandsHistoryIndex = 0;
        } else {
          this._commandsHistoryIndex = this._commandsHistoryIndex + 1;
        }
        if (!this._commandsHistory[this._commandsHistoryIndex]) {
          this._commandsHistoryIndex = 0;
        }
        this.inputValue = this._commandsHistory[this._commandsHistoryIndex];
        this.viewInput();
      }
      _selectPrevious() {
        this._selectedItemIndex = this._getPreviousItemIndex();
        this.switchView({ viewType: "select" });
      }
      _selectNext() {
        this._selectedItemIndex = this._getNextItemIndex();
        this.switchView({ viewType: "select" });
      }
      _deleteLastCharacter() {
        this.inputValue = this.inputValue.slice(0, -1);
        this.viewInput(this._viewMessage);
      }
      _deleteLastWord() {
        this.inputValue = this.inputValue.trim();
        this.inputValue = this.inputValue.substring(0, this.inputValue.lastIndexOf(" "));
        this.viewInput(this._viewMessage);
      }
      _clearInputValue() {
        this.inputValue = "";
        this.viewInput(this._viewMessage);
      }
      _updateInputValue(character) {
        this.inputValue += character;
        this.viewInput(this._viewMessage);
      }
      _clearScreen() {
        this._updateCommandsHistory();
        this._log(ansiEscapes.clearScreen);
        this._logLogo();
        this.loggedTopPadding = false;
        this.inputValue = "";
        this.viewInput();
        this._hideCursor();
      }
      _ensureTopPadding() {
        if (!this.loggedTopPadding) {
          this._log("\n");
          this.loggedTopPadding = true;
        }
      }
      _updateSpinner(viewMessage, { timer = false } = {}) {
        this._spinnerFrameIndex = ++this._spinnerFrameIndex % this._spinnerFrames.length;
        if (timer) {
          viewMessage = `${viewMessage} ${this.styles.grey(`(${this.timer}s)`)}`;
        }
        this.switchView({ viewType: "spinner", viewMessage });
      }
      _getSpinnerFrame() {
        return this.styles.red(this._spinnerFrames[this._spinnerFrameIndex]);
      }
      _initSuggestions() {
        this._suggestions = [
          "deploy",
          "deploy dev",
          "promote",
          "promote dev",
          "promote dev prod",
          "share",
          "import",
          "import --overwrite",
          "export",
          "export --overwrite",
          "exit",
          "clear",
          "cancel",
          "login",
          "logout",
          "help",
          "test",
          "url",
          "open",
          "docs",
          "quit",
          "version",
          "install",
          "uninstall"
        ];
      }
      _initTips() {
        this._tipsCollection = [
          "type `share` to share your changes",
          "type `test` to test your changes",
          "type `import` to import data from a data.json file",
          "type `export` to export data to a data.json file",
          "type `deploy <stage>` to deploy to a stage",
          "type `export <file-name>` to specify export file name",
          "type `import <file-name>` to specify import file name",
          "type `docs` to open the docs in your browser",
          "type `help` to see the list of available commands",
          "type `quit` to quit the shell",
          "type `clear` to clear the screen",
          "type `url` to view your personal instance url",
          "type `open` to open your app page in the browser",
          "type `promote <from> <to>` to promote between stages",
          "type `install` to install your package.json dependencies",
          "type `install <npm-package>` to install an npm package",
          "type `uninstall <npm-package>` to uninstall an npm package"
        ];
        this._tipsFrequency = 5e3;
        this._tipsCollectionIndex = 0;
        this._tipsInterval = setInterval(() => this._updateTip(), this._tipsFrequency);
      }
      _getTip() {
        return this.styles.dim(this._tipsCollection[this._tipsCollectionIndex]);
      }
      _updateTip() {
        this._tipsCollectionIndex = ++this._tipsCollectionIndex % this._tipsCollection.length;
        if (this._viewType === "input" && !this._isPromptActive)
          this.viewInput(this._getTip());
      }
      _initStyles() {
        this.styles = {};
        this.styles.dim = chalk.dim;
        this.styles.grey = chalk.grey;
        this.styles.gray = chalk.grey;
        this.styles.italic = chalk.italic;
        this.styles.bold = chalk.bold;
        this.styles.underline = chalk.underline;
        this.styles.title = chalk.bold.underline;
        this.styles.red = chalk.rgb(255, 99, 99);
        this.styles.green = chalk.green;
        this.styles.yellow = chalk.yellow;
        this.styles.blue = chalk.blue;
        this.styles.cyan = chalk.cyan;
        this.styles.white = chalk.white;
      }
      _initIcons() {
        this.icons = {};
        this.icons.bolt = this.styles.red(emoji.get("zap"));
        this.icons.tick = this.styles.green(figures.tick);
        this.icons.cross = this.styles.red(figures.cross);
        this.icons.warning = this.styles.red(figures.warning);
        this.icons.info = this.styles.red(figures.info);
        this.icons.line = figures.line;
        this.icons.arrow = this.styles.red(figures.arrowRight);
        this.icons.arrowDown = figures.arrowDown;
        this.icons.pointer = this.styles.red(figures.pointerSmall);
        this.icons.question = this.styles.red("?");
      }
      _canRenderBolt() {
        const { TERM_PROGRAM, TERM } = process.env;
        let userTerminalAppName = TERM_PROGRAM || TERM;
        const isMac = process.platform === "darwin";
        const workingTerminals = ["vscode", "Hyper"];
        if (isMac && workingTerminals.includes(userTerminalAppName)) {
          return true;
        }
        const notWorkingTerminals = ["Apple_Terminal", "MacTerm", "iTerm.app", "screen", "xterm-256color"];
        if (notWorkingTerminals.includes(userTerminalAppName)) {
          return false;
        }
        return false;
      }
    };
    module2.exports = CLI2;
  }
});

// src/context/CI.js
var require_CI = __commonJS({
  "src/context/CI.js"(exports2, module2) {
    "use strict";
    var minimist = require_minimist();
    var commands = require_commands();
    var parseSlug = require_parseSlug();
    var commandsAvailableInCI = ["deploy", "test", "promote", "delete"];
    var CI2 = class {
      constructor() {
        this.isShellActive = false;
        this.styles = {
          dim: (msg) => msg
        };
        this.icons = {
          line: "-"
        };
      }
      async run() {
        const minimistInput = process.argv.slice(2);
        const minimistOutput = minimist(minimistInput);
        this.command = minimistOutput._[0];
        this.args = minimistOutput._.slice(1);
        this.options = minimistOutput;
        this.names = parseSlug(this.args[0]);
        this.names.orgName = this.names.orgName || this.options.org;
        this.names.serviceName = this.names.serviceName || this.options.app;
        this.names.instanceName = this.names.instanceName || this.options.instance;
        if (!commandsAvailableInCI.includes(this.command)) {
          throw new Error(`Command ${this.command} is not available in CI/CD context`);
        }
        await commands[this.command](this);
        process.exit();
      }
      log(msg = "", indent = 0) {
        console.log(`${" ".repeat(indent)}${msg}`);
      }
      logInfo(msg, indent) {
        this.log(msg, indent);
      }
      logSuccess(msg, indent) {
        this.log(msg, indent);
      }
      logError(msg, indent) {
        this.log(msg, indent);
      }
      logTime(msg) {
        this.log(msg);
      }
      logUrl(msg) {
        this.log(msg);
      }
      viewSpinner(msg) {
        this.log(msg);
      }
    };
    module2.exports = CI2;
  }
});

// src/index.js
"use strict";
require_validateNodeVersion()();
require_setStage()();
var isCI = require_isCI();
var CLI = require_CLI();
var CI = require_CI();
(async () => {
  if (isCI) {
    const ci = new CI();
    return await ci.run();
  }
  const cli = new CLI();
  return await cli.run();
})();
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
/*!
 * @description Recursive object extending
 * @author Viacheslav Lotsmanov <lotsmanov89@gmail.com>
 * @license MIT
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2013-2018 Viacheslav Lotsmanov
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-git-url <https://github.com/jonschlinkert/is-git-url>
 *
 * Copyright (c) 2014-2015, 2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-natural-number.js | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/is-natural-number.js
*/
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
/*!
 * normalize-path <https://github.com/jonschlinkert/normalize-path>
 *
 * Copyright (c) 2014-2018, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * strip-dirs | MIT (c) Shinnosuke Watanabe
 * https://github.com/shinnn/node-strip-dirs
*/
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * @file Tests if ES6 @@toStringTag is supported.
 * @see {@link http://www.ecma-international.org/ecma-262/6.0/#sec-@@tostringtag|26.3.1 @@toStringTag}
 * @version 1.4.1
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-to-string-tag-x
 */
/**
 * @file Tests if ES6 Symbol is supported.
 * @version 1.4.2
 * @author Xotic750 <Xotic750@gmail.com>
 * @copyright  Xotic750
 * @license {@link <https://opensource.org/licenses/MIT> MIT}
 * @module has-symbol-support-x
 */
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
/**
 * @preserve
 * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
 *
 * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
 * @see http://github.com/homebrewing/brauhaus-diff
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/murmurhash-js
 * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
 * @see http://sites.google.com/site/murmurhash/
 */
/**
 * Archiver Core
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
/**
 * Archiver Vending
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
/**
 * JSON Format Plugin
 *
 * @module plugins/json
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
/**
 * TAR Format Plugin
 *
 * @module plugins/tar
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
/**
 * ZIP Format Plugin
 *
 * @module plugins/zip
 * @license [MIT]{@link https://github.com/archiverjs/node-archiver/blob/master/LICENSE}
 * @copyright (c) 2012-2014 Chris Talkington, contributors.
 */
/**
 * ZipStream
 *
 * @ignore
 * @license [MIT]{@link https://github.com/archiverjs/node-zip-stream/blob/master/LICENSE}
 * @copyright (c) 2014 Chris Talkington, contributors.
 */
